<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>RouteCodex Daemon Admin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #070a14;
        --panel: rgba(255, 255, 255, 0.05);
        --panel-2: rgba(255, 255, 255, 0.03);
        --border: rgba(255, 255, 255, 0.08);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.62);
        --accent: #4ea1ff;
        --ok: #4cd964;
        --warn: #ffb547;
        --err: #ff5f5f;
        --radius: 12px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: radial-gradient(circle at 25% 0, #131a36 0, var(--bg) 50%, #03040a 100%);
        color: var(--text);
      }

      .container {
        max-width: 1680px;
        margin: 22px auto 40px;
        padding: 0 16px;
      }

      .card {
        border: 1px solid var(--border);
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border-radius: var(--radius);
        padding: 14px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        flex-wrap: wrap;
        margin-bottom: 14px;
      }

      .title h1 {
        margin: 0;
        font-size: 16px;
        font-weight: 650;
      }

      .title p {
        margin: 3px 0 0;
        font-size: 12px;
        color: var(--muted);
      }

      .statusline {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.03);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        color: var(--muted);
      }

      .toast {
        position: fixed;
        right: 14px;
        bottom: 14px;
        max-width: 520px;
        padding: 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(20, 20, 20, 0.92);
        color: var(--fg);
        box-shadow: 0 12px 34px rgba(0,0,0,0.45);
        z-index: 99999;
        font-size: 13px;
        line-height: 1.35;
        display: none;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .toast.show { display: block; }
      .toast.ok { border-color: rgba(38, 200, 120, 0.45); }
      .toast.err { border-color: rgba(255, 90, 90, 0.55); }

      .kv {
        border: 1px solid rgba(255, 255, 255, 0.10);
        border-radius: 12px;
        padding: 8px 10px;
        background: rgba(0, 0, 0, 0.18);
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 12px;
        line-height: 1.45;
        color: rgba(255, 255, 255, 0.86);
        overflow: visible;
        max-height: none;
      }

      .kv details {
        border-left: 1px solid rgba(255, 255, 255, 0.10);
        margin-left: 10px;
        padding-left: 10px;
      }

      .kv summary {
        cursor: pointer;
        list-style: none;
        user-select: none;
        display: flex;
        gap: 10px;
        align-items: baseline;
        padding: 2px 0;
      }

      .kv summary::-webkit-details-marker { display: none; }

      .kv .kv-key {
        color: rgba(255, 255, 255, 0.92);
        min-width: 180px;
        max-width: 520px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .kv .kv-meta {
        color: rgba(255, 255, 255, 0.55);
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .kv .kv-leaf {
        display: flex;
        gap: 10px;
        padding: 2px 0;
      }

      .kv .kv-val {
        color: rgba(255, 255, 255, 0.78);
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .kv-tools {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin: 0 0 8px;
      }

      .kv-editor .kv-leaf,
      .kv-editor summary {
        align-items: center;
      }

      .kv-editor .kv-type {
        color: rgba(255, 255, 255, 0.55);
        min-width: 92px;
        max-width: 140px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .kv-editor .kv-actions {
        display: inline-flex;
        gap: 6px;
        margin-left: auto;
        flex: 0 0 auto;
      }

      .kv-editor .kv-actions button {
        padding: 4px 8px;
        border-radius: 8px;
        font-size: 12px;
      }

      .kv-editor input[type="text"],
      .kv-editor input[type="number"],
      .kv-editor select {
        padding: 4px 6px;
        border-radius: 8px;
        font-size: 12px;
      }

      .kv-editor .kv-path {
        color: rgba(255, 255, 255, 0.42);
        margin-left: 6px;
      }

      #routingKvEditor.kv-editor .kv-val {
        white-space: normal;
        overflow: visible;
        text-overflow: unset;
      }

      #routingKvEditor.kv-editor .kv-actions .kv-path {
        display: none;
      }

      body.show-routing-paths #routingKvEditor.kv-editor .kv-actions .kv-path {
        display: inline-flex;
      }

      #routingKvEditor.kv-editor .kv-actions button.danger {
        display: none;
      }

      #routingKvEditor.kv-editor .kv-leaf:hover .kv-actions button.danger,
      #routingKvEditor.kv-editor summary:hover .kv-actions button.danger {
        display: inline-flex;
      }

      #routingKvEditor .routing-target-actions {
        margin-top: 6px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      #routingKvEditor .routing-target-row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }

      #routingKvEditor .routing-target-key {
        padding: 2px 6px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.04);
        max-width: 520px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      #routingKvEditor .routing-target-meta {
        color: rgba(255, 255, 255, 0.55);
      }

      #routingKvEditor .routing-target-row button {
        padding: 4px 8px;
        border-radius: 8px;
        font-size: 12px;
      }
      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--warn);
      }

      .dot.ok {
        background: var(--ok);
      }

      .dot.err {
        background: var(--err);
      }

      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="text"],
      input[type="password"],
      select,
      textarea {
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.25);
        color: var(--text);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
        outline: none;
      }

      textarea {
        width: 100%;
        min-height: 220px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        line-height: 1.45;
      }

      button {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
        cursor: pointer;
      }

      button.primary {
        border-color: rgba(78, 161, 255, 0.55);
        background: rgba(78, 161, 255, 0.14);
      }

      button.danger {
        border-color: rgba(255, 95, 95, 0.55);
        background: rgba(255, 95, 95, 0.14);
      }

      .tabs {
        display: flex;
        gap: 6px;
        margin: 14px 0 10px;
        flex-wrap: wrap;
      }

      .tab {
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--muted);
      }

      .tab.active {
        color: var(--text);
        border-color: rgba(78, 161, 255, 0.55);
        background: rgba(78, 161, 255, 0.12);
      }

      .grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        gap: 12px;
      }

      .grid.grid-wide-left {
        grid-template-columns: minmax(0, 1.6fr) minmax(0, 1fr);
      }

      .grid.grid-wide-right {
        grid-template-columns: minmax(0, 1fr) minmax(0, 1.6fr);
      }

      .grid.grid-clock {
        grid-template-columns: minmax(0, 2.2fr) minmax(0, 0.8fr);
      }

      .grid.grid-one {
        grid-template-columns: minmax(0, 1fr);
      }

      /* Ensure grid children can shrink without overflowing into the next column */
      .grid > .card {
        min-width: 0;
      }

      @media (max-width: 980px) {
        .grid {
          grid-template-columns: minmax(0, 1fr);
        }
      }

      .section-title {
        font-size: 13px;
        font-weight: 650;
        margin: 0 0 6px;
      }

      .section-sub {
        margin: 0 0 10px;
        font-size: 12px;
        color: var(--muted);
      }

      .table {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }

      .table th,
      .table td {
        padding: 8px 10px;
        font-size: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        vertical-align: top;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .table th {
        text-align: left;
        color: var(--muted);
        font-weight: 600;
        background: rgba(255, 255, 255, 0.03);
      }

      .table.table-runtime th:nth-child(1),
      .table.table-runtime td:nth-child(1) {
        width: 22%;
      }
      .table.table-runtime th:nth-child(2),
      .table.table-runtime td:nth-child(2) {
        width: 19%;
      }
      .table.table-runtime th:nth-child(3),
      .table.table-runtime td:nth-child(3) {
        width: 9%;
      }
      .table.table-runtime th:nth-child(4),
      .table.table-runtime td:nth-child(4) {
        width: 12%;
      }
      .table.table-runtime th:nth-child(5),
      .table.table-runtime td:nth-child(5) {
        width: 12%;
      }
      .table.table-runtime th:nth-child(6),
      .table.table-runtime td:nth-child(6) {
        width: 7%;
      }
      .table.table-runtime th:nth-child(7),
      .table.table-runtime td:nth-child(7) {
        width: 11%;
      }
      .table.table-runtime th:nth-child(8),
      .table.table-runtime td:nth-child(8) {
        width: 8%;
      }

      .table tr.group-row td {
        background: rgba(255, 255, 255, 0.02);
        color: rgba(255, 255, 255, 0.86);
        font-weight: 650;
      }

      .table tr.clock-detail-row td {
        background: rgba(255, 255, 255, 0.01);
      }

      .clock-group-toggle {
        all: unset;
        cursor: pointer;
        display: block;
        width: 100%;
        white-space: normal;
        line-height: 1.35;
      }

      .clock-group-summary {
        margin-top: 4px;
        font-size: 11px;
        color: var(--muted);
        white-space: normal;
        overflow-wrap: anywhere;
        line-height: 1.3;
      }

      .clock-detail-list {
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 4px 0;
      }

      .clock-detail-item {
        display: flex;
        align-items: center;
        gap: 8px;
        min-width: 0;
      }

      .clock-detail-item .clock-detail-content {
        min-width: 0;
        flex: 1;
        white-space: normal;
        overflow-wrap: anywhere;
        line-height: 1.3;
      }

      .table.table-clock-merged th:nth-child(1),
      .table.table-clock-merged td:nth-child(1) {
        width: 10%;
      }
      .table.table-clock-merged th:nth-child(2),
      .table.table-clock-merged td:nth-child(2) {
        width: 50%;
      }
      .table.table-clock-merged th:nth-child(3),
      .table.table-clock-merged td:nth-child(3) {
        width: 14%;
      }
      .table.table-clock-merged th:nth-child(4),
      .table.table-clock-merged td:nth-child(4) {
        width: 14%;
      }
      .table.table-clock-merged th:nth-child(5),
      .table.table-clock-merged td:nth-child(5) {
        width: 12%;
      }

      .table tr.provider-row:hover td {
        background: rgba(78, 161, 255, 0.06);
      }

      .table tr.provider-row.selected td {
        background: rgba(78, 161, 255, 0.12);
      }

      .indent {
        padding-left: 22px !important;
      }

      .table-wrap {
        width: 100%;
        max-width: 100%;
        overflow: visible;
        border-radius: 12px;
        border: 1px solid var(--border);
      }

      .table-wrap .table {
        border: 0;
        min-width: 0;
      }

      .table td.actions-cell {
        width: 220px;
        overflow: visible;
      }

      .actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .auth-actions {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .auth-action-btn {
        padding: 3px 8px;
        font-size: 11px;
        border-radius: 8px;
        white-space: nowrap;
      }

      .truncate {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        color: var(--muted);
        word-break: break-all;
      }

      .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.04);
        font-size: 11px;
        line-height: 1.4;
        white-space: nowrap;
      }

      .pill.ok {
        border-color: rgba(52, 211, 153, 0.35);
        background: rgba(52, 211, 153, 0.10);
        color: rgba(210, 255, 236, 0.92);
      }

      .pill.warn {
        border-color: rgba(255, 181, 71, 0.35);
        background: rgba(255, 181, 71, 0.10);
        color: rgba(255, 236, 210, 0.92);
      }

      .pill.bad {
        border-color: rgba(239, 68, 68, 0.35);
        background: rgba(239, 68, 68, 0.10);
        color: rgba(255, 220, 220, 0.92);
      }

      .muted {
        color: var(--muted);
      }

      .notice {
        border: 1px solid rgba(255, 181, 71, 0.35);
        background: rgba(255, 181, 71, 0.08);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.82);
      }


      .auth-selection-summary {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 6px;
      }

      .auth-mode-panels {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.16);
        margin-bottom: 10px;
      }

      .auth-mode-panel .section-sub {
        margin-bottom: 8px;
      }

      .auth-verify-url {
        margin: 8px 0;
        white-space: pre-wrap;
        word-break: break-all;
      }

      .auth-mode-tabs {
        margin: 10px 0;
        position: relative;
        z-index: 2;
      }

      .auth-mode-tabs .tab {
        min-width: 120px;
      }

      .auth-mode-panels {
        position: relative;
        z-index: 2;
      }

      .log {
        white-space: pre-wrap;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        font-size: 12px;
        line-height: 1.45;
        color: rgba(255, 255, 255, 0.84);
        background: rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 10px 12px;
      }

      @media (max-width: 640px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }
        .statusline {
          width: 100%;
          justify-content: flex-start;
        }
        .row {
          align-items: stretch;
        }
        .row > input,
        .row > select,
        .row > button {
          max-width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="card">
        <header>
          <div class="title">
            <h1>RouteCodex Daemon Admin</h1>
            <p>
              Writes to <span class="mono">~/.routecodex/config.json</span>. This UI requires an admin password:
              first visit will ask you to set one (stored at <span class="mono">~/.routecodex/login</span>), then you login with it.
            </p>
          </div>
          <div class="statusline">
            <div class="pill"><span id="statusDot" class="dot"></span><span id="statusText">connecting…</span></div>
            <div class="pill"><span class="mono" id="serverId">serverId: —</span></div>
            <div class="pill"><span class="mono" id="serverVersion">version: —</span></div>
            <div class="pill"><span class="mono" id="clockOverviewText">clock: loading…</span></div>
            <button id="restartRuntimeBtn" class="primary">Restart runtime</button>
          </div>
        </header>

        <div class="row" style="margin-bottom: 10px;">
          <label for="adminPasswordInput">Admin password</label>
          <input
            id="adminPasswordInput"
            type="password"
            placeholder="set (first time) / login"
            style="flex: 1; min-width: 260px;"
          />
          <button id="setupPasswordBtn" class="primary">Set</button>
          <button id="loginPasswordBtn" class="primary">Login</button>
          <button id="logoutPasswordBtn">Logout</button>
          <span class="mono" id="adminAuthHint"></span>
        </div>

        <details id="changePasswordDetails" style="margin: 0 0 10px; display:none;">
          <summary class="muted" style="font-size:12px; cursor:pointer; user-select:none;">Change admin password</summary>
          <div class="row" style="margin-top: 10px;">
            <label for="oldAdminPasswordInput">old</label>
            <input
              id="oldAdminPasswordInput"
              type="password"
              placeholder="old password"
              style="flex: 1; min-width: 240px;"
            />
            <label for="newAdminPasswordInput">new</label>
            <input
              id="newAdminPasswordInput"
              type="password"
              placeholder="new password (8+ chars)"
              style="flex: 1; min-width: 240px;"
            />
            <button id="changePasswordBtn" class="primary">Change</button>
          </div>
          <div class="muted" style="font-size:12px; margin-top: 6px;">
            Localhost-only. Requires current authenticated session.
          </div>
        </details>

        <div class="row" style="margin-bottom: 10px;">
          <label for="apiKeyInput">Server API key (optional, for /v1/* tests)</label>
          <input
            id="apiKeyInput"
            type="password"
            placeholder="x-api-key / Authorization: Bearer …"
            style="flex: 1; min-width: 260px;"
          />
          <button id="saveApiKeyBtn" class="primary">Save</button>
          <button id="clearApiKeyBtn">Clear</button>
          <span class="mono" id="apiKeyHint"></span>
        </div>

        <div class="tabs">
          <button class="tab" data-tab="control">Control</button>
          <button class="tab active" data-tab="providers">Provider Pool</button>
          <button class="tab" data-tab="stats">Stats</button>
          <button class="tab" data-tab="tokens">Token Stats</button>
          <button class="tab" data-tab="credentials">Auth Provider Pool</button>
          <button class="tab" data-tab="quota">Quota Pool</button>
          <button class="tab" data-tab="routing">Runtime Routing Pool</button>
          <button class="tab" data-tab="clock">Clock</button>
        </div>

        <section id="panelControl" data-panel="control" style="display:none;">
          <div class="grid grid-wide-left">
            <div class="card" style="box-shadow: none;">
              <p class="section-title">Control plane (single entry)</p>
              <p class="section-sub">
                This panel uses <span class="mono">/daemon/control/snapshot</span> and <span class="mono">/daemon/control/mutate</span>
                to manage all local servers (broadcast restart) and quota operations from one port.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="controlRefreshBtn" class="primary">Refresh</button>
                <button id="controlRestartAllBtn" class="danger">Restart all servers</button>
                <button id="controlQuotaRefreshBtn">Refresh quota</button>
                <span id="controlHint" class="muted" style="margin-left:auto; font-size:12px;"></span>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>port</th>
                      <th>version</th>
                      <th>ready</th>
                      <th>pids</th>
                    </tr>
                  </thead>
                  <tbody id="controlServersTbody"></tbody>
                </table>
              </div>
              <p class="section-title" style="margin-top: 12px;">Routing hits (llmswitch-core)</p>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>route</th>
                      <th>hits</th>
                    </tr>
                  </thead>
                  <tbody id="controlHitsTbody"></tbody>
                </table>
              </div>
              <div id="controlOpLog" class="log" style="margin-top: 10px; display:none;"></div>
            </div>

            <div class="card" style="box-shadow: none;">
              <p class="section-title">Quota actions</p>
              <p class="section-sub">
                Offline/Recover/Reset are executed by control plane (no direct writes from UI).
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <label for="controlQuotaKeyInput">providerKey</label>
                <input id="controlQuotaKeyInput" type="text" placeholder="tab.key1.gpt-5.2-codex" style="flex: 1; min-width: 320px;" />
              </div>
              <div class="row" style="margin-bottom: 10px;">
                <label for="controlQuotaModeSelect">mode</label>
                <select id="controlQuotaModeSelect" style="width: 140px;">
                  <option value="cooldown" selected>cooldown</option>
                  <option value="blacklist">blacklist</option>
                </select>
                <label for="controlQuotaDurationSelect">time</label>
                <select id="controlQuotaDurationSelect" style="width: 160px;">
                  <option value="5">5m</option>
                  <option value="15">15m</option>
                  <option value="30">30m</option>
                  <option value="60" selected>1h</option>
                  <option value="180">3h</option>
                  <option value="360">6h</option>
                  <option value="720">12h</option>
                  <option value="1440">24h</option>
                </select>
                <button id="controlQuotaOfflineBtn" class="danger">Offline</button>
                <button id="controlQuotaRecoverBtn">Recover</button>
                <button id="controlQuotaResetBtn">Reset</button>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerKey</th>
                      <th>inPool</th>
                      <th>reason</th>
                      <th>cooldownUntil</th>
                      <th>blacklistUntil</th>
                    </tr>
                  </thead>
                  <tbody id="controlQuotaProvidersTbody"></tbody>
                </table>
              </div>

              <p class="section-title" style="margin-top: 14px;">ServerTool runtime</p>
              <p class="section-sub">
                Toggle servertool orchestration on/off instantly for this server process.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <span id="controlServerToolStatus" class="pill">state: —</span>
                <span id="controlServerToolUpdatedAt" class="mono muted">updated: —</span>
                <button id="controlServerToolToggleBtn" class="primary">Toggle</button>
              </div>
              <div class="notice mono" id="controlServerToolCountsBox" style="white-space: pre-wrap; margin-bottom: 10px;">
                executions: —
                success: —
                failure: —
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>tool</th>
                      <th>executions</th>
                      <th>success</th>
                      <th>failure</th>
                      <th>details</th>
                    </tr>
                  </thead>
                  <tbody id="controlServerToolToolsTbody"></tbody>
                </table>
              </div>
            </div>
          </div>
        </section>

        <section id="panelClock" data-panel="clock" style="display:none;">
          <div class="grid grid-clock">
            <div class="card" style="box-shadow: none;">
              <p class="section-title">Clock tasks (merged)</p>
              <p class="section-sub">Merged by content + recurrence + tool to reduce repeated rows. Expand a row to inspect per-time details.</p>
              <div class="row" style="margin-bottom: 10px;">
                <label for="clockSessionFilterInput">session filter</label>
                <input id="clockSessionFilterInput" type="text" placeholder="conversation session id (optional)" style="min-width: 320px; flex: 1;" />
                <button id="refreshClockBtn" class="primary">Refresh</button>
                <span id="clockHint" class="muted" style="margin-left:auto; font-size:12px;"></span>
              </div>
              <div id="clockSummaryPills" class="row" style="margin-bottom: 10px;"></div>

              <p class="section-title" style="margin-top: 8px;">Merged list</p>
              <div class="table-wrap">
                <table class="table table-clock-merged">
                  <thead>
                    <tr>
                      <th>status</th>
                      <th>task (foldable)</th>
                      <th>next due</th>
                      <th>time plan</th>
                      <th>scope</th>
                    </tr>
                  </thead>
                  <tbody id="clockMergedTbody"></tbody>
                </table>
              </div>
            </div>

            <div class="card" style="box-shadow: none;">
              <p class="section-title">Clock daemon bindings</p>
              <p class="section-sub">tmux daemon registry and heartbeat state used by clock injection.</p>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>daemonId</th>
                      <th>tmuxSession</th>
                      <th>boundConversations</th>
                      <th>heartbeat</th>
                      <th>lastInject</th>
                      <th>status</th>
                      <th>lastError</th>
                    </tr>
                  </thead>
                  <tbody id="clockDaemonsTbody"></tbody>
                </table>
              </div>
            </div>
          </div>
        </section>

        <section id="panelProviders" data-panel="providers">
          <div class="grid grid-wide-left">
            <div class="card" style="box-shadow: none;">
              <p class="section-title">Providers in <span class="mono">virtualrouter.providers</span></p>
              <p class="section-sub">
                API keys are stored as authfiles and referenced with <span class="mono">authfile-…</span>. The UI never reads or returns secrets.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshProvidersBtn" class="primary">Refresh</button>
                <button id="newProviderBtn">New provider…</button>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>id</th>
                      <th>type</th>
                      <th>enabled</th>
                      <th>baseURL</th>
                      <th>models</th>
                      <th>compat</th>
                      <th>auth</th>
                      <th></th>
                    </tr>
                  </thead>
                  <tbody id="providersTbody"></tbody>
                </table>
              </div>
            </div>

            <div class="card" style="box-shadow: none;">
              <p class="section-title" id="providerEditorTitle">Provider editor</p>
              <p class="section-sub">
                Edit providers as key/value entries to avoid JSON syntax errors. Save writes to disk and creates a backup.
              </p>

              <div class="notice" style="margin-bottom: 10px;">
                Admin API calls use the password login above (cookie session). The optional server API key is only needed for testing proxy endpoints like <span class="mono">/v1/responses</span>.
              </div>

              <div class="row" style="margin-bottom: 10px;">
                <label for="providerIdInput">provider id</label>
                <input id="providerIdInput" type="text" placeholder="e.g. tab, glm, qwen" style="width: 240px;" />
                <label for="providerPreset">preset</label>
                <select id="providerPreset">
                  <option value="responses">responses (OpenAI /v1/responses)</option>
                  <option value="openai">openai (OpenAI /v1/chat/completions)</option>
                  <option value="openai-standard">openai-standard</option>
                  <option value="iflow">iflow (cookieFile)</option>
                  <option value="custom" selected>custom (start empty)</option>
                </select>
              </div>

              <div class="row" style="margin-bottom: 10px;">
                <label for="authMode">auth</label>
                <select id="authMode">
                  <option value="apikey">apikey (store as authfile)</option>
                  <option value="oauth">oauth (alias-only + authorize in Auth tab)</option>
                  <option value="cookie">cookieFile</option>
                  <option value="none">none</option>
                </select>
              </div>

              <div id="authApikeyBox" class="card" style="box-shadow:none; padding: 10px; margin-bottom: 10px;">
                <p class="section-title" style="margin-bottom: 8px;">API key</p>
                <div class="row" style="margin-bottom: 8px;">
                  <label for="apikeyAliasInput">alias</label>
                  <input id="apikeyAliasInput" type="text" placeholder="default" style="width: 220px;" />
                  <label for="apikeyValueInput">apiKey</label>
                  <input
                    id="apikeyValueInput"
                    type="password"
                    placeholder="will be written to ~/.routecodex/auth/*.key"
                    style="flex: 1; min-width: 260px;"
                  />
                </div>
                <div class="row">
                  <span class="mono" id="apikeySecretRefOut"></span>
                  <button id="createApiKeyCredentialBtn">Create authfile</button>
                </div>
              </div>

              <div id="authOauthBox" class="card" style="box-shadow:none; padding: 10px; margin-bottom: 10px; display:none;">
                <p class="section-title" style="margin-bottom: 8px;">OAuth</p>
                <p class="section-sub" style="margin-bottom: 8px;">
                  Use Auth tab to authorize. Here we only reference <span class="mono">tokenFile</span> as an alias.
                </p>
                <div class="row">
                  <label for="oauthTypeInput">auth.type</label>
                  <input
                    id="oauthTypeInput"
                    type="text"
                    placeholder="qwen-oauth / iflow-oauth / gemini-cli-oauth / antigravity-oauth"
                    style="flex: 1; min-width: 260px;"
                  />
                  <label for="oauthAliasInput">tokenFile alias</label>
                  <input id="oauthAliasInput" type="text" placeholder="default" style="width: 240px;" />
                </div>
              </div>

              <div id="authCookieBox" class="card" style="box-shadow:none; padding: 10px; margin-bottom: 10px; display:none;">
                <p class="section-title" style="margin-bottom: 8px;">Cookie file</p>
                <div class="row">
                  <label for="cookieFileInput">cookieFile</label>
                  <input
                    id="cookieFileInput"
                    type="text"
                    placeholder="~/.routecodex/auth/iflow-work.cookie"
                    style="flex: 1; min-width: 280px;"
                  />
                </div>
              </div>

              <p class="section-title" style="margin-top: 10px;">Provider config</p>
              <p class="section-sub">Tree editor. Use “Apply preset” to populate common templates.</p>
              <div class="kv-tools">
                <button id="providerEditorExpandBtn">Expand all</button>
                <button id="providerEditorCollapseBtn">Collapse all</button>
                <span class="mono" id="providerEditorDirtyHint"></span>
              </div>
              <div id="providerKvEditor" class="kv kv-editor"></div>

              <div class="row" style="margin-top: 10px;">
                <button id="loadProviderBtn">Load</button>
                <button id="applyPresetBtn">Apply preset</button>
                <button id="saveProviderBtn" class="primary">Save</button>
                <button id="deleteProviderBtn" class="danger">Delete</button>
              </div>

              <div id="providerOpLog" class="log" style="margin-top: 10px; display:none;"></div>
            </div>
          </div>
        </section>

        <section id="panelStats" data-panel="stats" style="display:none;">
          <div class="grid">
            <div class="card" style="box-shadow:none;">
              <p class="section-title">Stats (session)</p>
              <p class="section-sub">
                Real-time request/error counters aggregated from in-memory buckets (counts provider attempts, including failover retries). Resets on server restart.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshStatsBtn" class="primary">Refresh</button>
                <label class="muted" style="display:inline-flex; align-items:center; gap:8px;">
                  <input id="statsAutoRefresh" type="checkbox" checked />
                  auto refresh (2s)
                </label>
                <span class="mono muted" id="statsLastUpdated"></span>
              </div>
              <div class="notice mono" id="statsSessionTotalsBox" style="white-space: pre-wrap;"></div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerId</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsSessionProvidersTbody"></tbody>
                </table>
              </div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerRuntime</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsSessionRuntimesTbody"></tbody>
                </table>
              </div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>model</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsSessionModelsTbody"></tbody>
                </table>
              </div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerKey</th>
                      <th>model</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsSessionErrorsTbody"></tbody>
                </table>
              </div>
            </div>

            <div class="card" style="box-shadow:none;">
              <p class="section-title">Stats (historical)</p>
              <p class="section-sub">
                Aggregated from <span class="mono">~/.routecodex/logs/provider-stats.jsonl</span> (best-effort).
              </p>
              <div class="notice mono" id="statsHistoricalTotalsBox" style="white-space: pre-wrap;"></div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerId</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsHistoricalProvidersTbody"></tbody>
                </table>
              </div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerRuntime</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsHistoricalRuntimesTbody"></tbody>
                </table>
              </div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>model</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsHistoricalModelsTbody"></tbody>
                </table>
              </div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerKey</th>
                      <th>model</th>
                      <th>req</th>
                      <th>err</th>
                    </tr>
                  </thead>
                  <tbody id="statsHistoricalErrorsTbody"></tbody>
                </table>
              </div>
            </div>
          </div>
        </section>

        <section id="panelTokens" data-panel="tokens" style="display:none;">
          <div class="grid">
            <div class="card" style="box-shadow:none;">
              <p class="section-title">Token usage (session + historical)</p>
              <p class="section-sub">
                Session stats reset on server restart. Historical totals are aggregated from
                <span class="mono">~/.routecodex/logs/provider-stats.jsonl</span> (best-effort).
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshTokensBtn" class="primary">Refresh</button>
              </div>
              <div class="notice mono" id="tokenTotalsBox" style="white-space: pre-wrap;"></div>
              <div class="table-wrap" style="margin-top: 10px;">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerKey</th>
                      <th>model</th>
                      <th>session req/err</th>
                      <th>session tokens in/out/total</th>
                      <th>historical req/err</th>
                      <th>historical tokens in/out/total</th>
                    </tr>
                  </thead>
                  <tbody id="tokensTbody"></tbody>
                </table>
              </div>
            </div>
          </div>
        </section>

        <section id="panelCredentials" data-panel="credentials" style="display:none;">
          <div class="grid grid-wide-right">
            <div class="card" style="box-shadow:none;">
              <p class="section-title">Auth Inventory</p>
              <p class="section-sub">
                Token files + API key authfiles in <span class="mono">~/.routecodex/auth</span>.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshCredentialsBtn" class="primary">Refresh</button>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>kind</th>
                      <th>provider</th>
                      <th>alias</th>
                      <th>status</th>
                      <th>expires</th>
                      <th>secretRef</th>
                      <th>action</th>
                    </tr>
                  </thead>
                  <tbody id="credentialsTbody"></tbody>
                </table>
              </div>
            </div>

            <div class="card" style="box-shadow:none;">
              <p class="section-title">Auth Workbench</p>
              <p class="section-sub">
                Manual and Auto flows are isolated. Use Manual for explicit user-driven login; use Auto only for provider auto-mode replay.
              </p>

              <div class="row" style="margin-bottom: 10px;">
                <label for="oauthBrowserSelect">oauthBrowser</label>
                <select id="oauthBrowserSelect">
                  <option value="default">default</option>
                  <option value="camoufox">camoufox</option>
                </select>
                <button id="saveOauthBrowserBtn" class="primary">Save</button>
              </div>

              <p class="section-title" style="margin-top: 10px;">Auth Context</p>
              <div class="row" style="margin-bottom: 8px;">
                <label for="oauthProviderSelect">provider</label>
                <select id="oauthProviderSelect">
                  <option value="qwen">qwen</option>
                  <option value="iflow">iflow</option>
                  <option value="gemini-cli">gemini-cli</option>
                  <option value="antigravity">antigravity</option>
                </select>
                <label for="oauthAuthAliasInput">alias</label>
                <input id="oauthAuthAliasInput" type="text" placeholder="default" style="width: 240px;" />
              </div>
              <div class="auth-selection-summary" style="margin-bottom: 10px;">
                <span id="oauthSelectionStatusPill" class="pill">status: —</span>
                <span id="oauthSelectionExpiryPill" class="pill">expires: —</span>
                <span id="oauthSelectionIssuePill" class="pill">issue: —</span>
              </div>

              <div class="tabs auth-mode-tabs">
                <button id="oauthModeManualBtn" class="tab active" type="button">Manual Auth</button>
                <button id="oauthModeAutoBtn" class="tab" type="button">Auto Auth</button>
              </div>

              <div class="auth-mode-panels">
                <div id="oauthManualPanel" class="auth-mode-panel">
                  <p class="section-sub">Pure manual mode (no auto selector / no auto confirm injection).</p>
                  <div class="row" style="margin-bottom: 6px;">
                    <label><input id="oauthManualOpenBrowser" type="checkbox" checked /> open browser</label>
                    <label><input id="oauthManualForceReauth" type="checkbox" checked /> force reauthorize</label>
                    <label><input id="oauthManualHeadful" type="checkbox" checked /> headed window</label>
                    <button id="oauthAuthorizeManualBtn" class="primary" type="button">Start Manual Auth</button>
                  </div>
                </div>
                <div id="oauthAutoPanel" class="auth-mode-panel" style="display:none;">
                  <p class="section-sub">Auto mode (provider-specific Camoufox auto-mode, fallback handled by runtime).</p>
                  <div class="row" style="margin-bottom: 6px;">
                    <label><input id="oauthAutoOpenBrowser" type="checkbox" checked /> open browser</label>
                    <label><input id="oauthAutoForceReauth" type="checkbox" checked /> force reauthorize</label>
                    <label><input id="oauthAutoHeadful" type="checkbox" /> debug headful</label>
                    <button id="oauthAuthorizeAutoBtn" class="primary" type="button">Run Auto Auth</button>
                  </div>
                </div>
              </div>

              <div id="oauthAuthIssueHint" class="notice" style="display:none; margin-bottom: 10px; white-space: pre-wrap;"></div>

              <div id="oauthVerifyCenter" class="notice" style="display:none; margin-bottom: 10px;">
                <p class="section-title" style="margin-bottom: 4px;">Verify Center</p>
                <p class="section-sub" style="margin-bottom: 6px;">If upstream requires account verification, complete it here before re-authorizing.</p>
                <div id="oauthVerifyUrl" class="mono auth-verify-url">—</div>
                <div class="row">
                  <button id="oauthVerifyOpenBtn" type="button">Open Verify in Camoufox</button>
                  <button id="oauthVerifyCopyBtn" type="button">Copy Verify URL</button>
                  <button id="oauthVerifyRecheckBtn" type="button">Recheck Status</button>
                </div>
              </div>

              <p class="section-title" style="margin-top: 10px;">Run Console</p>
              <div id="credentialOpLog" class="log" style="display:none;"></div>
            </div>
          </div>
        </section>

        <section id="panelQuota" data-panel="quota" style="display:none;">
          <div class="grid">
            <div class="card" style="box-shadow:none;">
              <p class="section-title">Quota (daemon)</p>
              <p class="section-sub">
                VirtualRouter consumes this via <span class="mono">quotaView</span>. When
                <span class="mono">inPool=false</span>, the provider is treated as removed from the route pool.
	              </p>
		              <div class="row" style="margin-bottom: 10px;">
		                <label for="quotaFilterInput">filter</label>
		                <input id="quotaFilterInput" type="text" placeholder="providerKey contains…" style="width: 320px;" />
		                <label><input id="quotaHideOkToggle" type="checkbox" /> hide ok</label>
		                <label><input id="quotaOnlyRoutedTargetsToggle" type="checkbox" checked disabled /> routed models only</label>
                    <button id="quotaSelectVisibleBtn">Select visible</button>
                    <button id="quotaClearSelectionBtn">Clear selection</button>
                    <label><input id="quotaAutoRefreshToggle" type="checkbox" checked /> auto refresh</label>
                    <span id="quotaSelectionHint" class="muted" style="font-size:12px;">selected 0</span>
		                <span class="muted" style="font-size:12px;">Tip: click a row to fill the offline box.</span>
		              </div>
		              <div class="row" style="margin-bottom: 10px;">
		                <label for="quotaKeyInput">providerKey</label>
		                <input id="quotaKeyInput" type="text" placeholder="tab.key1.gpt-5.2-codex" style="width: 420px;" />
	                <label for="quotaModeSelect">offline mode</label>
	                <select id="quotaModeSelect" style="width: 140px;">
	                  <option value="cooldown">cooldown</option>
	                  <option value="blacklist">blacklist</option>
	                </select>
	                <label for="quotaDurationSelect">offline time</label>
	                <select id="quotaDurationSelect" style="width: 160px;">
	                  <option value="5">5m</option>
	                  <option value="15">15m</option>
	                  <option value="30">30m</option>
	                  <option value="60" selected>1h</option>
	                  <option value="180">3h</option>
	                  <option value="360">6h</option>
	                  <option value="720">12h</option>
	                  <option value="1440">24h</option>
	                </select>
	                <button id="quotaApplyDisableBtn" class="danger">Offline</button>
	                <button id="quotaApplyRecoverBtn">Recover</button>
	                <button id="quotaApplyResetBtn">Reset</button>
		              </div>
                <div class="muted" style="font-size:12px; margin: -6px 0 10px;">
                  Offline removes the provider from the route pool for the selected minutes. Recover brings it back online immediately.
                  If selection is non-empty, actions apply to selected providerKeys.
                </div>
		              <div class="row" style="margin-bottom: 10px;">
		                <button id="refreshQuotaBtn" class="primary">Refresh provider pool</button>
		                <button id="refreshQuotaSnapshotBtn" class="primary">Refresh antigravity snapshot</button>
		                <button id="resetQuotaBtn" class="danger">Reset provider-quota module</button>
              </div>
              <div class="table-wrap">
	                <table class="table">
	                  <thead>
	                    <tr>
	                      <th style="width: 34px;">
                        <input id="quotaSelectAllVisibleToggle" type="checkbox" title="Select all visible" />
                      </th>
	                      <th>key</th>
	                      <th>model</th>
	                      <th>inPool</th>
	                      <th>reason</th>
	                      <th>until</th>
                      <th>errCount</th>
                      <th></th>
                    </tr>
                  </thead>
                  <tbody id="quotaTbody"></tbody>
                </table>
              </div>
	              <div id="quotaOpLog" class="log" style="margin-top: 10px; display:none;"></div>
	            </div>

	            <div class="card" style="box-shadow:none;">
	              <p class="section-title">Antigravity quota snapshot</p>
	              <p class="section-sub">
	                Snapshot fetched by <span class="mono">QuotaManagerModule</span> (antigravity quota API). Used to gate antigravity providers entering the route pool.
	              </p>
	              <div class="row" style="margin-bottom: 10px;">
	                <label><input id="quotaSnapshotOnlyRoutedToggle" type="checkbox" checked /> only routed models</label>
	                <span class="muted" style="font-size:12px;">(filters by current provider pool keys)</span>
	              </div>
	              <div class="table-wrap">
	                <table class="table">
	                  <thead>
	                    <tr>
	                      <th>alias</th>
	                      <th>model</th>
	                      <th>remaining</th>
	                      <th>resetAt</th>
	                      <th>fetchedAt</th>
	                    </tr>
	                  </thead>
	                  <tbody id="quotaSnapshotTbody"></tbody>
	                </table>
	              </div>
	              <div id="quotaSnapshotLog" class="log" style="margin-top: 10px; display:none;"></div>
	            </div>
	
	            <div class="card" style="box-shadow:none;">
	              <p class="section-title">Notes</p>
	              <div class="notice">
                <div style="margin-bottom: 6px;">
                  Use this view to confirm 429/backoff/blacklist decisions and whether a provider is currently eligible.
	                </div>
	                <div>
	                  If a provider looks stuck, try <span class="mono">Reset provider-quota module</span>, then <span class="mono">Restart runtime</span>.
	                </div>
	              </div>
	            </div>
          </div>
        </section>

	        <section id="panelRouting" data-panel="routing" style="display:none;">
	          <div class="grid grid-one">
	            <div class="card" style="box-shadow:none;">
	              <p class="section-title">Routing editor</p>
	              <p class="section-sub">
	                Edits routing in a selected config file (auto-detects <span class="mono">virtualrouter.routing</span> or <span class="mono">routing</span>).
	              </p>
	              <div class="row" style="margin-bottom: 10px;">
	                <label for="routingSourceSelect">source</label>
	                <select id="routingSourceSelect" style="width: 420px;"></select>
	                <button id="refreshRoutingSourcesBtn">Refresh sources</button>
	              </div>
	              <div class="row" style="margin-bottom: 10px;">
	                <label for="routingQuotaModeSelect">mode</label>
	                <select id="routingQuotaModeSelect" style="width: 160px;">
	                  <option value="cooldown" selected>cooldown</option>
	                  <option value="blacklist">blacklist</option>
	                </select>
	                <label for="routingQuotaDurationSelect">offline time</label>
	                <select id="routingQuotaDurationSelect" style="width: 160px;">
	                  <option value="5">5m</option>
	                  <option value="15">15m</option>
	                  <option value="30">30m</option>
	                  <option value="60" selected>1h</option>
	                  <option value="180">3h</option>
	                  <option value="360">6h</option>
	                  <option value="720">12h</option>
	                  <option value="1440">24h</option>
	                </select>
	              </div>
	              <div class="row" style="margin-bottom: 10px;">
	                <button id="loadRoutingBtn" class="primary">Load</button>
	                <button id="saveRoutingBtn" class="primary">Save</button>
                  <button id="refreshRoutingPoolBtn">Refresh pool status</button>
	                <button id="routingRegExpandBtn">Expand all</button>
	                <button id="routingRegCollapseBtn">Collapse all</button>
                  <label style="margin-left:auto;"><input id="routingShowPathsToggle" type="checkbox" /> show debug paths</label>
	              </div>
	              <div id="routingOpLog" class="log" style="margin-top: 10px; display:none;"></div>
	              <div class="muted" style="font-size:12px; margin: -4px 0 10px;">
	                Tip: edit routing here (CRUD). For tool targets, use the inline <span class="mono">Offline/Recover</span> controls to manage runtime provider keys.
	              </div>
	              <div id="routingKvEditor" class="kv kv-editor"></div>
	            </div>
          </div>
        </section>
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>

    <script>
      const $ = (id) => document.getElementById(id);
			      const UI = {
              selectedProviderId: "",
              lastUnauthorizedToastAt: 0,
              adminAuth: null,
              controlSnapshot: null,
              controlSnapshotUpdatedAt: 0,
              clockSnapshot: null,
              clockSnapshotUpdatedAt: 0,
              clockExpandedGroups: {},
              quotaProviders: [],
              quotaProvidersUpdatedAt: 0,
              quotaProviderMap: null,
              quotaSelection: new Set(),
              quotaRenderedVisibleKeys: [],
              quotaRenderedGroups: new Map(),
              routingTargets: null,
              routingTargetsUpdatedAt: 0,
              routingSources: [],
              routingSourcesUpdatedAt: 0,
              routingLocation: "virtualrouter.routing",
              credentials: [],
              oauthMode: "manual"
            };
      let toastTimer = null;

      function toast(msg, kind = "err") {
        const el = $("toast");
        if (!el) return;
        el.classList.remove("ok", "err", "show");
        el.classList.add(kind === "ok" ? "ok" : "err");
        el.textContent = String(msg || "");
        el.classList.add("show");
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          try { el.classList.remove("show"); } catch {}
        }, 4200);
      }

      function onClick(id, handler) {
        const el = $(id);
        if (!el) {
          console.warn(`[daemon-admin-ui] missing #${id}`);
          return false;
        }
        el.addEventListener("click", handler);
        return true;
      }

      function notifyUnauthorizedOnce(context) {
        const now = Date.now();
        if (now - UI.lastUnauthorizedToastAt < 1800) return;
        UI.lastUnauthorizedToastAt = now;
        const label = context ? ` (${context})` : "";
        toast(`Unauthorized${label}. Login required.`);
        try { void refreshAdminAuthStatus(); } catch {}
      }

      function setLog(id, value) {
        const el = $(id);
        if (!el) return;
        el.style.display = value ? "block" : "none";
        const raw = value || "";
        const max = 12000;
        const out = raw.length > max ? raw.slice(0, max) + "\n...(truncated)" : raw;
        el.textContent = out;
      }

      function appendLog(id, line) {
        const el = $(id);
        if (!el) return;
        const prev = textOf(el.textContent || "").trim();
        const nextLine = textOf(line || "").trim();
        if (!nextLine) return;
        setLog(id, prev ? (prev + "\n" + nextLine) : nextLine);
      }

      function getApiKey() {
        try {
          return sessionStorage.getItem("routecodex:apikey") || "";
        } catch {
          return "";
        }
      }

      function setApiKey(value) {
        try {
          if (!value) sessionStorage.removeItem("routecodex:apikey");
          else sessionStorage.setItem("routecodex:apikey", value);
        } catch {}
      }

      async function apiFetch(path, opts = {}) {
        const headers = new Headers(opts.headers || {});
        if (!headers.has("content-type") && opts.body) headers.set("content-type", "application/json");
        const res = await fetch(path, { ...opts, headers, credentials: "same-origin" });
        const text = await res.text();
        let json = null;
        try {
          json = text ? JSON.parse(text) : null;
        } catch {
          json = null;
        }
        if (!res.ok) {
          const msg =
            (json && json.error && (json.error.message || json.error.code)) ||
            `HTTP ${res.status} ${res.statusText}`;
          const err = new Error(msg);
          err.status = res.status;
          err.path = path;
          err.payload = json;
          throw err;
        }
        return json;
      }

      function selectTab(name) {
        document.querySelectorAll(".tab[data-tab]").forEach((btn) => {
          btn.classList.toggle("active", btn.getAttribute("data-tab") === name);
        });
        const panels = [
          { name: "control", el: $("panelControl") },
          { name: "providers", el: $("panelProviders") },
          { name: "stats", el: $("panelStats") },
          { name: "tokens", el: $("panelTokens") },
          { name: "credentials", el: $("panelCredentials") },
          { name: "quota", el: $("panelQuota") },
          { name: "routing", el: $("panelRouting") },
          { name: "clock", el: $("panelClock") }
        ];
        for (const p of panels) p.el.style.display = p.name === name ? "block" : "none";

        // Light auto-refresh on tab switch to avoid showing stale "Unauthorized" after login.
        void maybeRefreshTab(name);
        syncStatsAutoRefresh();
      }

      function getActiveTab() {
        const active = document.querySelector(".tab[data-tab].active");
        const name = active ? active.getAttribute("data-tab") : null;
        return name || "providers";
      }

      const tabLastRefreshedAt = {
        control: 0,
        providers: 0,
        stats: 0,
        tokens: 0,
        credentials: 0,
        quota: 0,
        routing: 0,
        clock: 0
      };

      async function maybeRefreshTab(name) {
        const key = name in tabLastRefreshedAt ? name : "providers";
        const now = Date.now();
        if (now - tabLastRefreshedAt[key] < 1500) {
          return;
        }
        tabLastRefreshedAt[key] = now;
        try {
          if (key === "providers") await refreshProviders();
          else if (key === "control") await refreshControl();
          else if (key === "stats") await refreshStats();
          else if (key === "tokens") await refreshTokens();
          else if (key === "credentials") await refreshCredentials();
	          else if (key === "quota") {
	            await refreshQuota();
	            await refreshQuotaSnapshot();
	          }
          else if (key === "routing") {
            await refreshRuntimes();
            await refreshRoutingSources();
          }
          else if (key === "clock") {
            await refreshClockTab();
          }
        } catch {
          // ignore refresh failures on tab switch
        }
      }

      let statsAutoRefreshTimer = null;
      function syncStatsAutoRefresh() {
        if (statsAutoRefreshTimer) {
          try { clearInterval(statsAutoRefreshTimer); } catch {}
          statsAutoRefreshTimer = null;
        }
        const active = getActiveTab();
        if (active !== "stats") {
          return;
        }
        const checkbox = $("statsAutoRefresh");
        const enabled = checkbox && checkbox.checked;
        if (!enabled) {
          return;
        }
        if (UI && UI.adminAuth && UI.adminAuth.authenticated === false) {
          return;
        }
        statsAutoRefreshTimer = setInterval(() => {
          if (getActiveTab() !== "stats") return;
          const checkboxNow = $("statsAutoRefresh");
          if (!checkboxNow || !checkboxNow.checked) return;
          void refreshStats();
        }, 2000);
      }

      function textOf(value) {
        if (value === null || value === undefined) return "";
        return String(value);
      }

      function createCell(tag, text, className, opts = {}) {
        const el = document.createElement(tag);
        if (className) el.className = className;
        const s = textOf(text);
        el.textContent = s;
        if (opts.title && s) el.title = s;
        return el;
      }

      function createErrorRow(colSpan, message) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = colSpan;
        td.className = "mono";
        td.textContent = `Failed to load: ${textOf(message)}`;
        tr.appendChild(td);
        return tr;
      }

      function createInfoRow(colSpan, message) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = colSpan;
        td.className = "mono muted";
        td.textContent = textOf(message);
        tr.appendChild(td);
        return tr;
      }

      function setSelectedProviderId(id) {
        UI.selectedProviderId = textOf(id || "");
        const tbody = $("providersTbody");
        if (!tbody) return;
        tbody.querySelectorAll("tr.provider-row").forEach((tr) => {
          const pid = tr.getAttribute("data-provider-id") || "";
          tr.classList.toggle("selected", pid && pid === UI.selectedProviderId);
        });
      }

      function kvTypeMeta(value) {
        if (value === null) return "null";
        if (value === undefined) return "undefined";
        if (Array.isArray(value)) return `array(${value.length})`;
        const t = typeof value;
        if (t === "string") return `string(${value.length})`;
        if (t === "number") return "number";
        if (t === "boolean") return "boolean";
        if (t === "bigint") return "bigint";
        if (t === "function") return "function";
        if (t === "symbol") return "symbol";
        if (t === "object") {
          try {
            const keys = Object.keys(value);
            return `object(${keys.length})`;
          } catch {
            return "object";
          }
        }
        return t;
      }

      const providerEditorState = {
        value: {},
        dirty: false
      };

      function providerEditorClone(value) {
        try {
          return value == null ? value : JSON.parse(JSON.stringify(value));
        } catch {
          return value;
        }
      }

      function providerEditorSetDirty(dirty) {
        providerEditorState.dirty = Boolean(dirty);
        const hint = $("providerEditorDirtyHint");
        if (hint) hint.textContent = providerEditorState.dirty ? "unsaved changes" : "";
      }

      function providerEditorSetValue(value) {
        providerEditorState.value = providerEditorClone(value) || {};
        providerEditorSetDirty(false);
        providerEditorRender();
      }

      function providerEditorGetValue() {
        return providerEditorClone(providerEditorState.value) || {};
      }

      function providerEditorPathToString(path) {
        if (!path || !path.length) return "";
        return path.map((p) => String(p)).join(".");
      }

      function providerEditorGetByPath(root, path) {
        let cur = root;
        for (const part of path || []) {
          if (cur == null) return undefined;
          cur = cur[part];
        }
        return cur;
      }

      function providerEditorSetByPath(root, path, nextValue) {
        if (!root || typeof root !== "object") return;
        if (!path || !path.length) return;
        const last = path[path.length - 1];
        let cur = root;
        for (let i = 0; i < path.length - 1; i += 1) {
          const part = path[i];
          const existing = cur[part];
          if (existing == null || typeof existing !== "object") cur[part] = {};
          cur = cur[part];
        }
        cur[last] = nextValue;
      }

      function providerEditorDeleteByPath(root, path) {
        if (!root || typeof root !== "object") return;
        if (!path || !path.length) return;
        const last = path[path.length - 1];
        let cur = root;
        for (let i = 0; i < path.length - 1; i += 1) {
          const part = path[i];
          if (cur == null) return;
          cur = cur[part];
        }
        if (Array.isArray(cur)) {
          const idx = Number(last);
          if (Number.isFinite(idx) && idx >= 0 && idx < cur.length) cur.splice(idx, 1);
          return;
        }
        try { delete cur[last]; } catch {}
      }

      function providerEditorKind(value) {
        if (value === null) return "null";
        if (Array.isArray(value)) return "array";
        const t = typeof value;
        if (t === "string") return "string";
        if (t === "number") return "number";
        if (t === "boolean") return "boolean";
        if (t === "object") return "object";
        return "string";
      }

      function providerEditorCoerce(kind, raw) {
        if (kind === "null") return null;
        if (kind === "boolean") return raw === true || raw === "true";
        if (kind === "number") {
          const n = typeof raw === "number" ? raw : Number.parseFloat(String(raw));
          return Number.isFinite(n) ? n : 0;
        }
        if (kind === "array") return [];
        if (kind === "object") return {};
        return String(raw ?? "");
      }

      function providerEditorRender() {
        const container = $("providerKvEditor");
        if (!container) return;
        try {
          container.replaceChildren();
        } catch {
          try { container.innerHTML = ""; } catch {}
        }
        try {
          container.appendChild(providerEditorRenderNode("provider", providerEditorState.value || {}, [], 0, true));
        } catch (e) {
          const msg = e && e.message ? e.message : String(e);
          try { container.textContent = `Render failed: ${msg}`; } catch {}
        }
      }

      function providerEditorRenderNode(label, value, path, depth, isRoot = false) {
        const isObj = value !== null && typeof value === "object";
        const isArr = Array.isArray(value);
        const kind = providerEditorKind(value);

        if (!isObj) {
          const row = document.createElement("div");
          row.className = "kv-leaf";

          const keyEl = document.createElement("div");
          keyEl.className = "kv-key";
          keyEl.textContent = label;

          const typeSel = document.createElement("select");
          typeSel.className = "kv-type";
          typeSel.innerHTML = [
            "<option value=\"string\">string</option>",
            "<option value=\"number\">number</option>",
            "<option value=\"boolean\">boolean</option>",
            "<option value=\"null\">null</option>",
            "<option value=\"object\">object</option>",
            "<option value=\"array\">array</option>"
          ].join("");
          typeSel.value = kind;
          typeSel.addEventListener("click", (e) => e.stopPropagation());
          typeSel.addEventListener("change", () => {
            const root = providerEditorState.value || {};
            providerEditorSetByPath(root, path, providerEditorCoerce(typeSel.value, ""));
            providerEditorSetDirty(true);
            providerEditorRender();
          });

          const valWrap = document.createElement("div");
          valWrap.className = "kv-val";

          if (kind === "boolean") {
            const sel = document.createElement("select");
            sel.innerHTML = `<option value="true">true</option><option value="false">false</option>`;
            sel.value = value ? "true" : "false";
            sel.addEventListener("click", (e) => e.stopPropagation());
            sel.addEventListener("change", () => {
              const root = providerEditorState.value || {};
              providerEditorSetByPath(root, path, sel.value === "true");
              providerEditorSetDirty(true);
              providerEditorRender();
            });
            valWrap.appendChild(sel);
          } else if (kind === "number") {
            const inp = document.createElement("input");
            inp.type = "number";
            inp.value = String(value);
            inp.addEventListener("click", (e) => e.stopPropagation());
            inp.addEventListener("change", () => {
              const root = providerEditorState.value || {};
              const n = Number.parseFloat(inp.value);
              providerEditorSetByPath(root, path, Number.isFinite(n) ? n : 0);
              providerEditorSetDirty(true);
              providerEditorRender();
            });
            valWrap.appendChild(inp);
          } else if (kind === "null") {
            const span = document.createElement("span");
            span.className = "mono";
            span.textContent = "null";
            valWrap.appendChild(span);
          } else {
            const inp = document.createElement("input");
            inp.type = "text";
            inp.value = value == null ? "" : String(value);
            inp.addEventListener("click", (e) => e.stopPropagation());
            inp.addEventListener("change", () => {
              const root = providerEditorState.value || {};
              providerEditorSetByPath(root, path, String(inp.value));
              providerEditorSetDirty(true);
              providerEditorRender();
            });
            valWrap.appendChild(inp);
          }

          const actions = document.createElement("div");
          actions.className = "kv-actions";
          if (!isRoot) {
            const del = document.createElement("button");
            del.textContent = "Del";
            del.className = "danger";
            del.addEventListener("click", (e) => {
              e.preventDefault();
              e.stopPropagation();
              const root = providerEditorState.value || {};
              providerEditorDeleteByPath(root, path);
              providerEditorSetDirty(true);
              providerEditorRender();
            });
            actions.appendChild(del);
          }
          const pathEl = document.createElement("span");
          pathEl.className = "kv-path mono";
          pathEl.textContent = providerEditorPathToString(path);
          actions.appendChild(pathEl);

          row.appendChild(keyEl);
          row.appendChild(typeSel);
          row.appendChild(valWrap);
          row.appendChild(actions);
          return row;
        }

        const details = document.createElement("details");
        details.open = isRoot || depth < 1;

        const summary = document.createElement("summary");

        const keyEl = document.createElement("div");
        keyEl.className = "kv-key";
        keyEl.textContent = label;

        const metaEl = document.createElement("div");
        metaEl.className = "kv-meta";
        metaEl.textContent = kvTypeMeta(value);

        const actions = document.createElement("div");
        actions.className = "kv-actions";

        if (isArr) {
          const add = document.createElement("button");
          add.textContent = "+Item";
          add.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const t = (prompt("Item type: string/number/boolean/null/object/array", "string") || "string").trim().toLowerCase();
            const k = ["string","number","boolean","null","object","array"].includes(t) ? t : "string";
            let init = "";
            if (k === "boolean") init = prompt("Value: true/false", "false") || "false";
            else if (k === "number") init = prompt("Value (number)", "0") || "0";
            else if (k === "string") init = prompt("Value (string)", "") || "";
            const v = providerEditorCoerce(k, k === "boolean" ? init === "true" : init);
            const root = providerEditorState.value || {};
            const arr = providerEditorGetByPath(root, path);
            if (Array.isArray(arr)) {
              arr.push(v);
              providerEditorSetDirty(true);
              providerEditorRender();
            }
          });
          actions.appendChild(add);
        } else {
          const add = document.createElement("button");
          add.textContent = "+Key";
          add.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const name = (prompt("Key name", "") || "").trim();
            if (!name) return;
            const t = (prompt("Value type: string/number/boolean/null/object/array", "string") || "string").trim().toLowerCase();
            const k = ["string","number","boolean","null","object","array"].includes(t) ? t : "string";
            let init = "";
            if (k === "boolean") init = prompt("Value: true/false", "false") || "false";
            else if (k === "number") init = prompt("Value (number)", "0") || "0";
            else if (k === "string") init = prompt("Value (string)", "") || "";
            const v = providerEditorCoerce(k, k === "boolean" ? init === "true" : init);
            const root = providerEditorState.value || {};
            const obj = providerEditorGetByPath(root, path);
            if (obj && typeof obj === "object" && !Array.isArray(obj)) {
              obj[name] = v;
              providerEditorSetDirty(true);
              providerEditorRender();
            }
          });
          actions.appendChild(add);
        }

        if (!isRoot) {
          const del = document.createElement("button");
          del.textContent = "Del";
          del.className = "danger";
          del.addEventListener("click", (e) => {
            e.preventDefault();
            e.stopPropagation();
            const root = providerEditorState.value || {};
            providerEditorDeleteByPath(root, path);
            providerEditorSetDirty(true);
            providerEditorRender();
          });
          actions.appendChild(del);
        }

        const pathEl = document.createElement("span");
        pathEl.className = "kv-path mono";
        pathEl.textContent = providerEditorPathToString(path);
        actions.appendChild(pathEl);

        summary.appendChild(keyEl);
        summary.appendChild(metaEl);
        summary.appendChild(actions);
        details.appendChild(summary);

        if (isArr) {
          for (let i = 0; i < value.length; i += 1) {
            details.appendChild(providerEditorRenderNode(String(i), value[i], path.concat([i]), depth + 1));
          }
          return details;
        }

        let keys = [];
        try {
          keys = Object.keys(value);
          keys.sort((a, b) => a.localeCompare(b));
        } catch {
          keys = [];
        }
        for (const childKey of keys) {
          details.appendChild(providerEditorRenderNode(childKey, value[childKey], path.concat([childKey]), depth + 1));
        }

        return details;
      }

      function providerEditorSetAuthApiKey(secretRef) {
        const ref = textOf(secretRef).trim();
        if (!ref) return;
        const root = providerEditorState.value || {};
        if (!root.auth || typeof root.auth !== "object" || Array.isArray(root.auth)) root.auth = {};
        root.auth.type = "apikey";
        root.auth.apiKey = ref;
        providerEditorSetDirty(true);
        providerEditorRender();
      }

      function kvPreview(value) {
        if (value === null || value === undefined) return String(value);
        const t = typeof value;
        if (t === "string") {
          const max = 140;
          const s = value.length > max ? value.slice(0, max) + "…" : value;
          return JSON.stringify(s);
        }
        if (t === "number" || t === "boolean" || t === "bigint") return String(value);
        if (Array.isArray(value)) return "";
        if (t === "object") return "";
        return String(value);
      }

      function renderRegistry(container, value, opts = {}) {
        if (!container) return;
        container.replaceChildren();
        const rootLabel = (opts.rootLabel || "root").trim() || "root";
        try {
          container.appendChild(renderRegistryNode(rootLabel, value, 0, true));
        } catch (e) {
          const box = document.createElement("div");
          box.className = "mono";
          box.textContent = `Render failed: ${e && e.message ? e.message : String(e)}`;
          container.appendChild(box);
        }
      }

      function renderRegistryNode(key, value, depth, isRoot = false) {
        const isObj = value !== null && typeof value === "object";
        const isArr = Array.isArray(value);

        if (!isObj) {
          const row = document.createElement("div");
          row.className = "kv-leaf";
          const k = document.createElement("div");
          k.className = "kv-key";
          k.textContent = key;
          const v = document.createElement("div");
          v.className = "kv-val";
          v.textContent = kvPreview(value);
          row.appendChild(k);
          row.appendChild(v);
          return row;
        }

        const details = document.createElement("details");
        details.open = isRoot || depth < 1;

        const summary = document.createElement("summary");
        const k = document.createElement("div");
        k.className = "kv-key";
        k.textContent = key;
        const m = document.createElement("div");
        m.className = "kv-meta";
        const meta = kvTypeMeta(value);
        const preview = kvPreview(value);
        m.textContent = preview ? `${meta}  ${preview}` : meta;
        summary.appendChild(k);
        summary.appendChild(m);
        details.appendChild(summary);

        if (isArr) {
          for (let i = 0; i < value.length; i += 1) {
            details.appendChild(renderRegistryNode(String(i), value[i], depth + 1));
          }
          return details;
        }

        let keys = [];
        try {
          keys = Object.keys(value);
          keys.sort((a, b) => a.localeCompare(b));
        } catch {
          keys = [];
        }
        for (const childKey of keys) {
          let childValue;
          try {
            childValue = value[childKey];
          } catch (e) {
            childValue = `[[unreadable: ${e && e.message ? e.message : String(e)}]]`;
          }
          details.appendChild(renderRegistryNode(childKey, childValue, depth + 1));
        }
        return details;
      }

      function setAllDetailsOpen(container, open, keepRootOpen = true) {
        if (!container) return;
        const nodes = Array.from(container.querySelectorAll("details"));
        nodes.forEach((d, idx) => {
          d.open = open || (keepRootOpen && idx === 0);
        });
      }

      function presetFor(type) {
        if (type === "responses") {
          return {
            enabled: true,
            type: "responses",
            baseURL: "https://api.openai.com/v1",
            auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
            responses: { process: "chat", streaming: "always" },
            config: { responses: { process: "chat", streaming: "always" } },
            models: {}
          };
        }
        if (type === "openai") {
          return {
            enabled: true,
            type: "openai",
            baseURL: "https://api.openai.com/v1",
            auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
            models: {}
          };
        }
        if (type === "openai-standard") {
          return {
            enabled: true,
            type: "openai-standard",
            baseURL: "https://api.openai.com/v1",
            auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
            models: {}
          };
        }
        if (type === "iflow") {
          return {
            enabled: true,
            type: "iflow",
            baseURL: "https://apis.iflow.cn/v1",
            compatibilityProfile: "chat:iflow",
            auth: { type: "iflow-cookie", cookieFile: "~/.routecodex/auth/iflow-work.cookie" },
            models: {}
          };
        }
        return {
          enabled: true,
          type: "responses",
          baseURL: "",
          auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
          models: {}
        };
      }

      async function refreshClockOverview() {
        const overviewEl = $("clockOverviewText");
        if (!overviewEl) return;
        try {
          const res = await fetch("/daemon/clock/tasks");
          if (!res || !res.ok) throw new Error(res ? String(res.status) : "request_failed");
          const data = await res.json().catch(() => ({}));
          const sessions = data && Array.isArray(data.sessions) ? data.sessions : [];
          const records = data && Array.isArray(data.records) ? data.records : [];
          const now = Date.now();
          let taskCount = 0;
          let dueCount = 0;
          for (const session of sessions) {
            const tasks = session && Array.isArray(session.tasks) ? session.tasks : [];
            taskCount += tasks.length;
            for (const task of tasks) {
              let dueAtMs = Number(task && task.dueAtMs);
              if (!Number.isFinite(dueAtMs) && task && typeof task.dueAt === "string") {
                const parsed = Date.parse(task.dueAt);
                dueAtMs = Number.isFinite(parsed) ? parsed : NaN;
              }
              if (Number.isFinite(dueAtMs) && dueAtMs <= now) {
                dueCount += 1;
              }
            }
          }
          const onlineCount = records.filter((record) => {
            const hb = Number(record && record.lastHeartbeatAtMs);
            return Number.isFinite(hb) && now - hb <= 45_000;
          }).length;
          overviewEl.textContent = "clock: tasks " + taskCount + " · due " + dueCount + " · daemon " + onlineCount + "/" + records.length;
        } catch {
          overviewEl.textContent = "clock: unavailable";
        }
      }

      function clockParseDueAtMs(task) {
        const rawMs = Number(task && task.dueAtMs);
        if (Number.isFinite(rawMs)) return Math.floor(rawMs);
        const rawIso = task && typeof task.dueAt === "string" ? task.dueAt.trim() : "";
        if (!rawIso) return NaN;
        const parsed = Date.parse(rawIso);
        return Number.isFinite(parsed) ? Math.floor(parsed) : NaN;
      }

      function clockTaskStatusKind(task, now) {
        const dueAtMs = clockParseDueAtMs(task);
        if (!Number.isFinite(dueAtMs)) return "warn";
        const delta = dueAtMs - now;
        if (delta < -60_000) return "bad";
        if (delta <= 0) return "warn";
        return "ok";
      }

      function clockTaskStatusText(task, now) {
        const dueAtMs = clockParseDueAtMs(task);
        if (!Number.isFinite(dueAtMs)) return "invalid";
        const delta = dueAtMs - now;
        if (delta < -60_000) return "overdue";
        if (delta <= 0) return "due";
        if (delta <= 60_000) return "soon";
        return "scheduled";
      }

      function clockRecurrenceText(task) {
        const rec = task && task.recurrence && typeof task.recurrence === "object" ? task.recurrence : null;
        if (!rec) return "one-shot";
        const kind = textOf(rec.kind || "").trim() || "recurring";
        const maxRuns = Number(rec.maxRuns);
        const count = Number(task && task.deliveryCount);
        let base = kind;
        if (kind === "interval") {
          const everyMinutes = Number(rec.everyMinutes);
          if (Number.isFinite(everyMinutes) && everyMinutes > 0) {
            base += "/" + Math.floor(everyMinutes) + "m";
          }
        }
        if (Number.isFinite(maxRuns) && maxRuns > 0) {
          const safeCount = Number.isFinite(count) && count > 0 ? Math.floor(count) : 0;
          base += " " + safeCount + "/" + Math.floor(maxRuns);
        }
        return base;
      }

      function clockNormalizeContent(value) {
        return textOf(value).trim().replace(/\s+/g, " ");
      }

      function clockShortLabel(value, head = 8, tail = 4) {
        const raw = textOf(value).trim();
        if (!raw) return "—";
        const maxLen = Math.max(6, head + tail + 1);
        if (raw.length <= maxLen) return raw;
        return raw.slice(0, head) + "…" + raw.slice(-tail);
      }

      function clockSessionPreview(sessionIds, limit = 3) {
        const ids = Array.isArray(sessionIds) ? sessionIds.filter(Boolean) : [];
        if (!ids.length) return "—";
        const shown = ids.slice(0, limit).map((id) => clockShortLabel(id, 6, 3));
        if (ids.length > limit) {
          shown.push("+" + String(ids.length - limit));
        }
        return shown.join(", ");
      }

      function clockFormatCompactTs(ms) {
        if (!Number.isFinite(ms) || ms <= 0) return "—";
        const d = new Date(ms);
        if (Number.isNaN(d.getTime())) return "—";
        const pad = (n) => String(n).padStart(2, "0");
        return pad(d.getMonth() + 1) + "-" + pad(d.getDate()) + " " + pad(d.getHours()) + ":" + pad(d.getMinutes());
      }

      function clockReadableTmuxSessionId(value) {
        const raw = textOf(value).trim();
        if (!raw) return "—";
        const managed = /^rcc_([a-zA-Z0-9_-]+)_(\d{13})_([a-f0-9]{4,})$/i.exec(raw);
        if (!managed) return clockShortLabel(raw, 10, 6);
        const role = textOf(managed[1]).replace(/_/g, "-");
        const startedAt = Number(managed[2]);
        const startedText = clockFormatCompactTs(startedAt);
        const suffix = textOf(managed[3]).slice(0, 4);
        return role + "@" + startedText + "#" + suffix;
      }

      function clockTmuxPreview(values, limit = 2) {
        const list = Array.isArray(values) ? values.filter((v) => textOf(v).trim() && textOf(v).trim() !== "—") : [];
        if (!list.length) return "—";
        const uniq = Array.from(new Set(list));
        const shown = uniq.slice(0, limit);
        if (uniq.length > limit) {
          shown.push("+" + String(uniq.length - limit));
        }
        return shown.join(", ");
      }

      function clockRecurrenceShort(task) {
        const rec = task && task.recurrence && typeof task.recurrence === "object" ? task.recurrence : null;
        if (!rec) return "1x";
        const kind = textOf(rec.kind || "").trim().toLowerCase();
        const maxRuns = Number(rec.maxRuns);
        let prefix = "R";
        if (kind === "daily") prefix = "D";
        else if (kind === "weekly") prefix = "W";
        else if (kind === "interval") {
          const everyMinutes = Number(rec.everyMinutes);
          prefix = Number.isFinite(everyMinutes) && everyMinutes > 0 ? "I" + String(Math.floor(everyMinutes)) + "m" : "I";
        }
        if (Number.isFinite(maxRuns) && maxRuns > 0) {
          return prefix + "/" + String(Math.floor(maxRuns));
        }
        return prefix;
      }

      function clockBuildGroupKey(task) {
        const content = clockNormalizeContent(task && task.task);
        const tool = textOf(task && task.tool).trim();
        return [content || "(empty)", tool || "tool:none"].join("||");
      }

      function renderClockTabFromSnapshot() {
        const snap = UI.clockSnapshot && typeof UI.clockSnapshot === "object" ? UI.clockSnapshot : {};
        const sessions = Array.isArray(snap.sessions) ? snap.sessions : [];
        const records = Array.isArray(snap.records) ? snap.records : [];

        const mergedBody = $("clockMergedTbody");
        const daemonBody = $("clockDaemonsTbody");
        const summaryBox = $("clockSummaryPills");
        const hint = $("clockHint");

        if (mergedBody) mergedBody.replaceChildren();
        if (daemonBody) daemonBody.replaceChildren();
        if (summaryBox) summaryBox.replaceChildren();

        const now = Date.now();
        const groups = new Map();
        const rows = [];
        const conversationToTmuxSession = new Map();
        for (const record of records) {
          const tmuxSession = textOf((record && record.tmuxSessionId) || (record && record.sessionId)).trim();
          if (!tmuxSession) continue;
          const conversationIds = Array.isArray(record && record.conversationSessionIds) ? record.conversationSessionIds : [];
          for (const cid of conversationIds) {
            const key = textOf(cid).trim();
            if (!key || conversationToTmuxSession.has(key)) continue;
            conversationToTmuxSession.set(key, tmuxSession);
          }
        }
        for (const session of sessions) {
          const sessionId = textOf(session && session.sessionId).trim();
          const mappedTmuxSessionId = textOf(conversationToTmuxSession.get(sessionId)).trim();
          const mappedTmuxShort = clockReadableTmuxSessionId(mappedTmuxSessionId);
          const tasks = session && Array.isArray(session.tasks) ? session.tasks : [];
          for (const task of tasks) {
            const key = clockBuildGroupKey(task);
            const dueMs = clockParseDueAtMs(task);
            const status = clockTaskStatusText(task, now);
            const statusKind = clockTaskStatusKind(task, now);
            const taskId = textOf(task && task.taskId).trim();
            const recurrence = clockRecurrenceText(task);
            const tool = textOf(task && task.tool).trim() || "—";
            const deliveryCount = Number(task && task.deliveryCount);
            const row = {
              groupKey: key,
              sessionId,
              sessionShort: clockShortLabel(sessionId, 6, 3),
              tmuxSessionId: mappedTmuxSessionId,
              tmuxShort: mappedTmuxShort,
              taskId,
              taskShort: clockShortLabel(taskId, 6, 4),
              content: textOf(task && task.task).trim(),
              dueMs,
              dueAt: Number.isFinite(dueMs) ? formatEpochWithDelta(dueMs) : "—",
              dueCompact: Number.isFinite(dueMs) ? formatEpochMs(dueMs) : "—",
              status,
              statusKind,
              recurrence,
              recurrenceShort: clockRecurrenceShort(task),
              deliveryCount,
              tool,
              toolShort: clockShortLabel(tool, 8, 3)
            };
            row.metaShort = row.toolShort + " · " + row.recurrenceShort + (Number.isFinite(row.deliveryCount) ? " · #" + String(Math.max(0, Math.floor(row.deliveryCount))) : "");
            rows.push(row);

            if (!groups.has(key)) {
              groups.set(key, {
                groupKey: key,
                content: row.content || "(empty)",
                sessionIds: new Set(),
                tmuxDisplays: new Set(),
                taskCount: 0,
                dueMin: Number.isFinite(dueMs) ? dueMs : NaN,
                dueMax: Number.isFinite(dueMs) ? dueMs : NaN,
                dueCount: 0,
                overdueCount: 0,
                statusKind: row.statusKind,
                toolSet: new Set(),
                recurrenceSet: new Set(),
                rows: []
              });
            }
            const group = groups.get(key);
            group.sessionIds.add(sessionId || "—");
            if (row.tmuxShort && row.tmuxShort !== "—") {
              group.tmuxDisplays.add(row.tmuxShort);
            }
            group.toolSet.add(row.toolShort);
            group.recurrenceSet.add(row.recurrenceShort);
            group.taskCount += 1;
            group.rows.push(row);
            if (row.status === "due") group.dueCount += 1;
            if (row.status === "overdue") group.overdueCount += 1;
            if (Number.isFinite(dueMs)) {
              if (!Number.isFinite(group.dueMin) || dueMs < group.dueMin) group.dueMin = dueMs;
              if (!Number.isFinite(group.dueMax) || dueMs > group.dueMax) group.dueMax = dueMs;
            }
            if (row.statusKind === "bad") group.statusKind = "bad";
            else if (row.statusKind === "warn" && group.statusKind !== "bad") group.statusKind = "warn";
          }
        }

        const merged = Array.from(groups.values());
        merged.sort((a, b) => {
          const aDue = Number.isFinite(a.dueMin) ? a.dueMin : Number.POSITIVE_INFINITY;
          const bDue = Number.isFinite(b.dueMin) ? b.dueMin : Number.POSITIVE_INFINITY;
          if (aDue !== bDue) return aDue - bDue;
          return b.taskCount - a.taskCount;
        });

        rows.sort((a, b) => {
          const aDue = Number.isFinite(a.dueMs) ? a.dueMs : Number.POSITIVE_INFINITY;
          const bDue = Number.isFinite(b.dueMs) ? b.dueMs : Number.POSITIVE_INFINITY;
          if (aDue !== bDue) return aDue - bDue;
          return a.sessionId.localeCompare(b.sessionId);
        });

        if (!UI.clockExpandedGroups || typeof UI.clockExpandedGroups !== "object") {
          UI.clockExpandedGroups = {};
        }

        if (summaryBox) {
          const dueNow = rows.filter((r) => r.status === "due").length;
          const overdue = rows.filter((r) => r.status === "overdue").length;
          const recurring = rows.filter((r) => r.recurrence !== "one-shot").length;
          const onlineDaemon = records.filter((record) => {
            const hb = Number(record && record.lastHeartbeatAtMs);
            return Number.isFinite(hb) && now - hb <= 45_000;
          }).length;
          const pills = [
            ["sessions", sessions.length, ""],
            ["tasks", rows.length, ""],
            ["merged", merged.length, ""],
            ["due", dueNow, dueNow ? "warn" : "ok"],
            ["overdue", overdue, overdue ? "bad" : "ok"],
            ["recurring", recurring, ""],
            ["daemon", onlineDaemon + "/" + records.length, onlineDaemon ? "ok" : "warn"]
          ];
          for (const [label, value, kind] of pills) {
            summaryBox.appendChild(pill(label + ": " + value, kind));
          }
        }

        if (mergedBody) {
          if (!merged.length) {
            mergedBody.appendChild(createInfoRow(5, "No clock tasks."));
          } else {
            for (const item of merged) {
              const isExpanded = !!UI.clockExpandedGroups[item.groupKey];
              const tr = document.createElement("tr");
              tr.className = "group-row";
              const statusText = item.overdueCount > 0
                ? "overdue " + item.overdueCount
                : item.dueCount > 0
                  ? "due " + item.dueCount
                  : "scheduled";
              const statusTd = document.createElement("td");
              statusTd.appendChild(pill(statusText, item.statusKind));
              tr.appendChild(statusTd);

              const taskTd = document.createElement("td");
              const toggleBtn = document.createElement("button");
              toggleBtn.type = "button";
              toggleBtn.className = "clock-group-toggle mono";
              toggleBtn.textContent = (isExpanded ? "▾ " : "▸ ") + (item.content || "(empty)");
              toggleBtn.title = isExpanded ? "collapse" : "expand";
              toggleBtn.addEventListener("click", () => {
                UI.clockExpandedGroups[item.groupKey] = !UI.clockExpandedGroups[item.groupKey];
                renderClockTabFromSnapshot();
              });
              taskTd.appendChild(toggleBtn);
              const groupSummary = document.createElement("div");
              groupSummary.className = "clock-group-summary mono";
              const toolPart = Array.from(item.toolSet).slice(0, 2).join(", ") || "—";
              const recPart = Array.from(item.recurrenceSet).slice(0, 2).join(", ") || "1x";
              groupSummary.textContent = "tool " + toolPart + " · rec " + recPart;
              groupSummary.title = groupSummary.textContent;
              taskTd.appendChild(groupSummary);
              tr.appendChild(taskTd);

              const nextDueText = Number.isFinite(item.dueMin) ? formatEpochWithDelta(item.dueMin) : "—";
              tr.appendChild(createCell("td", nextDueText, "mono truncate", { title: true }));

              const sortedDueRows = item.rows
                .filter((r) => Number.isFinite(r.dueMs))
                .sort((a, b) => a.dueMs - b.dueMs);
              let planText = "—";
              if (sortedDueRows.length) {
                planText = sortedDueRows.slice(0, 3).map((r) => r.dueCompact).join(" | ");
                if (sortedDueRows.length > 3) {
                  planText += " +" + String(sortedDueRows.length - 3);
                }
              }
              tr.appendChild(createCell("td", planText, "mono truncate", { title: true }));

              const sessionList = Array.from(item.sessionIds);
              const tmuxPreview = clockTmuxPreview(Array.from(item.tmuxDisplays));
              const scopeText = String(item.taskCount) + " task" + (item.taskCount > 1 ? "s" : "") + " · " + String(sessionList.length) + " session" + (sessionList.length > 1 ? "s" : "") + " · tmux " + tmuxPreview;
              tr.appendChild(createCell("td", scopeText, "mono truncate", { title: true }));
              mergedBody.appendChild(tr);

              const detailTr = document.createElement("tr");
              detailTr.className = "clock-detail-row";
              if (!isExpanded) detailTr.style.display = "none";
              const detailTd = document.createElement("td");
              detailTd.colSpan = 5;
              if (isExpanded) {
                const detailList = document.createElement("div");
                detailList.className = "clock-detail-list";
                const detailRows = item.rows.slice().sort((a, b) => {
                  const aDue = Number.isFinite(a.dueMs) ? a.dueMs : Number.POSITIVE_INFINITY;
                  const bDue = Number.isFinite(b.dueMs) ? b.dueMs : Number.POSITIVE_INFINITY;
                  if (aDue !== bDue) return aDue - bDue;
                  return a.sessionId.localeCompare(b.sessionId);
                });
                for (const detail of detailRows.slice(0, 40)) {
                  const line = document.createElement("div");
                  line.className = "clock-detail-item mono";

                  const timeSpan = document.createElement("span");
                  timeSpan.textContent = detail.dueCompact;
                  timeSpan.title = detail.dueAt;
                  line.appendChild(timeSpan);

                  line.appendChild(pill(detail.status, detail.statusKind));

                  const idSpan = document.createElement("span");
                  const tmuxPrefix = detail.tmuxShort && detail.tmuxShort !== "—" ? "tmux " + detail.tmuxShort + " · " : "";
                  idSpan.textContent = tmuxPrefix + "sid " + detail.sessionShort + " · id " + detail.taskShort + " · " + detail.metaShort;
                  idSpan.title = "tmux " + (detail.tmuxSessionId || "—") + " | session " + detail.sessionId + " | task " + detail.taskId + " | " + detail.tool + " | " + detail.recurrence;
                  line.appendChild(idSpan);

                  const contentSpan = document.createElement("span");
                  contentSpan.className = "clock-detail-content";
                  contentSpan.textContent = detail.content || "(empty)";
                  contentSpan.title = detail.content || "(empty)";
                  line.appendChild(contentSpan);

                  detailList.appendChild(line);
                }
                if (detailRows.length > 40) {
                  const more = document.createElement("div");
                  more.className = "mono muted";
                  more.textContent = "… " + String(detailRows.length - 40) + " more";
                  detailList.appendChild(more);
                }
                detailTd.appendChild(detailList);
              }
              detailTr.appendChild(detailTd);
              mergedBody.appendChild(detailTr);
            }
          }
        }

        if (daemonBody) {
          if (!records.length) {
            daemonBody.appendChild(createInfoRow(7, "No clock daemon bindings."));
          } else {
            for (const rec of records) {
              const tr = document.createElement("tr");
              const daemonId = textOf(rec && rec.daemonId).trim() || "—";
              const tmuxSession = textOf((rec && rec.tmuxSessionId) || (rec && rec.sessionId)).trim() || "—";
              const conversations = Array.isArray(rec && rec.conversationSessionIds) ? rec.conversationSessionIds : [];
              const hb = Number(rec && rec.lastHeartbeatAtMs);
              const inject = Number(rec && rec.lastInjectAtMs);
              const errText = textOf(rec && rec.lastError).trim();
              const isOnline = Number.isFinite(hb) && now - hb <= 45_000;
              const statusKind = errText ? "bad" : isOnline ? "ok" : "warn";
              const statusText = errText ? "error" : isOnline ? "online" : "stale";

              tr.appendChild(createCell("td", daemonId, "mono truncate", { title: true }));
              const tmuxReadable = clockReadableTmuxSessionId(tmuxSession);
              const tmuxCell = createCell("td", tmuxReadable, "mono truncate", { title: true });
              tmuxCell.title = tmuxSession || tmuxReadable;
              tr.appendChild(tmuxCell);
              tr.appendChild(createCell("td", String(conversations.length), "mono"));
              tr.appendChild(createCell("td", Number.isFinite(hb) ? formatEpochWithDelta(hb) : "—", "mono truncate", { title: true }));
              tr.appendChild(createCell("td", Number.isFinite(inject) ? formatEpochWithDelta(inject) : "—", "mono truncate", { title: true }));
              const statusTd = document.createElement("td");
              statusTd.appendChild(pill(statusText, statusKind));
              tr.appendChild(statusTd);
              tr.appendChild(createCell("td", errText || "—", "mono truncate", { title: true }));
              daemonBody.appendChild(tr);
            }
          }
        }

        if (hint) {
          hint.textContent = "groups " + merged.length + " · tasks " + rows.length + " · updated: " + formatTs(UI.clockSnapshotUpdatedAt);
        }
      }

      async function refreshClockTab() {
        try {
          const filter = textOf($("clockSessionFilterInput") && $("clockSessionFilterInput").value).trim();
          const path = filter
            ? "/daemon/clock/tasks?sessionId=" + encodeURIComponent(filter)
            : "/daemon/clock/tasks";
          const data = await apiFetch(path);
          UI.clockSnapshot = data && typeof data === "object" ? data : {};
          UI.clockSnapshotUpdatedAt = Date.now();
          renderClockTabFromSnapshot();
        } catch (e) {
          const mergedBody = $("clockMergedTbody");
          const daemonBody = $("clockDaemonsTbody");
          if (mergedBody) {
            mergedBody.replaceChildren();
            mergedBody.appendChild(createErrorRow(5, e && e.message ? e.message : String(e)));
          }
          if (daemonBody) {
            daemonBody.replaceChildren();
            daemonBody.appendChild(createInfoRow(7, "No daemon bindings."));
          }
          const hint = $("clockHint");
          if (hint) hint.textContent = "clock snapshot failed";
          if (e && e.status === 401) notifyUnauthorizedOnce("clock");
        }
      }

      async function refreshStatus() {
        // /health is public; use it to always show version even before admin login.
        try {
          const res = await fetch("/health");
          const data = res && res.ok ? await res.json().catch(() => null) : null;
          $("serverVersion").textContent = `version: ${data && data.version ? data.version : "—"}`;
        } catch {
          $("serverVersion").textContent = "version: —";
        }
        try {
          const data = await apiFetch("/daemon/status");
          $("serverId").textContent = `serverId: ${data.serverId || "—"}`;
          $("statusText").textContent = "connected";
          $("statusDot").classList.add("ok");
          $("statusDot").classList.remove("err");
        } catch (e) {
          $("statusText").textContent = e && e.status === 401 ? "401 (set API key above)" : "disconnected";
          $("statusDot").classList.remove("ok");
          $("statusDot").classList.add("err");
          $("serverId").textContent = "serverId: —";
        }
        await refreshClockOverview();
      }

      function formatTs(ms) {
        if (ms === null || ms === undefined) return "—";
        const n = Number(ms);
        if (!Number.isFinite(n) || n <= 0) return "—";
        try {
          return new Date(n).toLocaleString();
        } catch {
          return String(n);
        }
      }

      function renderControlSnapshot() {
        const snap = UI.controlSnapshot;
        const serversBody = $("controlServersTbody");
        const hitsBody = $("controlHitsTbody");
        const quotaBody = $("controlQuotaProvidersTbody");
        const serverToolBody = $("controlServerToolToolsTbody");
        const serverToolStatus = $("controlServerToolStatus");
        const serverToolUpdatedAt = $("controlServerToolUpdatedAt");
        const serverToolCountsBox = $("controlServerToolCountsBox");
        const serverToolToggleBtn = $("controlServerToolToggleBtn");
        if (serversBody) serversBody.replaceChildren();
        if (hitsBody) hitsBody.replaceChildren();
        if (quotaBody) quotaBody.replaceChildren();
        if (serverToolBody) serverToolBody.replaceChildren();
        if (!snap || typeof snap !== "object") {
          if (serversBody) serversBody.appendChild(createErrorRow(4, "No snapshot"));
          if (hitsBody) hitsBody.appendChild(createErrorRow(2, "No snapshot"));
          if (quotaBody) quotaBody.appendChild(createErrorRow(5, "No snapshot"));
          if (serverToolBody) serverToolBody.appendChild(createErrorRow(5, "No snapshot"));
          if (serverToolStatus) serverToolStatus.textContent = "state: —";
          if (serverToolUpdatedAt) serverToolUpdatedAt.textContent = "updated: —";
          if (serverToolCountsBox) serverToolCountsBox.textContent = "executions: —\nsuccess: —\nfailure: —";
          if (serverToolToggleBtn) serverToolToggleBtn.textContent = "Toggle";
          return;
        }
        const servers = Array.isArray(snap.servers) ? snap.servers : [];
        if (!servers.length) {
          if (serversBody) serversBody.appendChild(createErrorRow(4, "No local servers discovered"));
        } else if (serversBody) {
          for (const s of servers) {
            const tr = document.createElement("tr");
            tr.appendChild(createCell("td", String(s.port ?? "—"), "mono"));
            tr.appendChild(createCell("td", textOf(s.version || "—"), "mono"));
            tr.appendChild(createCell("td", s.ready === true ? "true" : s.ready === false ? "false" : "—", ""));
            tr.appendChild(createCell("td", Array.isArray(s.pids) ? s.pids.join(" ") : "", "mono"));
            serversBody.appendChild(tr);
          }
        }

        try {
          const llms = snap.llmsStats && typeof snap.llmsStats === "object" ? snap.llmsStats : null;
          const routeHits =
            llms && llms.router && llms.router.global && llms.router.global.routeHitCount
              ? llms.router.global.routeHitCount
              : null;
          const entries = routeHits && typeof routeHits === "object" ? Object.entries(routeHits) : [];
          entries.sort((a, b) => Number(b[1] || 0) - Number(a[1] || 0));
          const top = entries.slice(0, 20);
          if (!top.length) {
            if (hitsBody) hitsBody.appendChild(createErrorRow(2, "No routing hits recorded yet"));
          } else if (hitsBody) {
            for (const [route, count] of top) {
              const tr = document.createElement("tr");
              tr.appendChild(createCell("td", String(route || "—"), "mono"));
              tr.appendChild(createCell("td", String(count ?? 0), "mono"));
              hitsBody.appendChild(tr);
            }
          }
        } catch {
          if (hitsBody) hitsBody.appendChild(createErrorRow(2, "Failed to read routing hits"));
        }

        const quota = snap.quota && typeof snap.quota === "object" ? snap.quota : null;
        const providers = quota && Array.isArray(quota.providers) ? quota.providers : [];
        const list = providers
          .map((p) => ({
            providerKey: textOf(p.providerKey),
            inPool: Boolean(p.inPool),
            reason: textOf(p.reason),
            cooldownUntil: p.cooldownUntil ?? null,
            blacklistUntil: p.blacklistUntil ?? null
          }))
          .filter((p) => p.providerKey);
        list.sort((a, b) => a.providerKey.localeCompare(b.providerKey));
        const max = 60;
        const visible = list.slice(0, max);
        if (!visible.length) {
          if (quotaBody) quotaBody.appendChild(createErrorRow(5, "No quota providers"));
        } else if (quotaBody) {
          for (const p of visible) {
            const tr = document.createElement("tr");
            tr.appendChild(createCell("td", p.providerKey, "mono truncate", { title: true }));
            tr.appendChild(createCell("td", p.inPool ? "true" : "false", p.inPool ? "" : "danger"));
            tr.appendChild(createCell("td", p.reason || "—", "mono truncate", { title: true }));
            tr.appendChild(createCell("td", formatTs(p.cooldownUntil), "mono"));
            tr.appendChild(createCell("td", formatTs(p.blacklistUntil), "mono"));
            quotaBody.appendChild(tr);
          }
          if (list.length > max) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 5;
            td.className = "muted";
            td.textContent = `… ${list.length - max} more hidden`;
            tr.appendChild(td);
            quotaBody.appendChild(tr);
          }
        }

        try {
          const serverTool = snap.serverTool && typeof snap.serverTool === "object" ? snap.serverTool : null;
          const state = serverTool && serverTool.state && typeof serverTool.state === "object" ? serverTool.state : null;
          const stats = serverTool && serverTool.stats && typeof serverTool.stats === "object" ? serverTool.stats : null;
          const enabled = state && state.enabled === true;
          if (serverToolStatus) {
            serverToolStatus.textContent = enabled ? "state: enabled" : "state: disabled";
            serverToolStatus.className = enabled ? "pill ok" : "pill bad";
          }
          if (serverToolUpdatedAt) {
            const updatedBy = state && state.updatedBy ? String(state.updatedBy) : "—";
            const updatedAt = state && state.updatedAtMs ? formatTs(state.updatedAtMs) : "—";
            serverToolUpdatedAt.textContent = `updated: ${updatedAt} by ${updatedBy}`;
          }
          if (serverToolToggleBtn) {
            serverToolToggleBtn.textContent = enabled ? "Disable now" : "Enable now";
            serverToolToggleBtn.className = enabled ? "danger" : "primary";
          }

          const executions = stats && Number.isFinite(Number(stats.executions)) ? Number(stats.executions) : 0;
          const successCount = stats && Number.isFinite(Number(stats.success)) ? Number(stats.success) : 0;
          const failureCount = stats && Number.isFinite(Number(stats.failure)) ? Number(stats.failure) : 0;
          const scannedLines = stats && Number.isFinite(Number(stats.scannedLines)) ? Number(stats.scannedLines) : 0;
          if (serverToolCountsBox) {
            serverToolCountsBox.textContent =
              `executions: ${formatInt(executions)}\n` +
              `success: ${formatInt(successCount)}\n` +
              `failure: ${formatInt(failureCount)}\n` +
              `log lines scanned: ${formatInt(scannedLines)}`;
          }

          const byTool = stats && Array.isArray(stats.byTool) ? stats.byTool : [];
          const recent = stats && Array.isArray(stats.recent) ? stats.recent : [];
          const recentByTool = new Map();
          for (const ev of recent) {
            const tool = textOf(ev && ev.tool ? ev.tool : "unknown");
            if (!recentByTool.has(tool)) recentByTool.set(tool, []);
            recentByTool.get(tool).push(ev);
          }

          if (!byTool.length) {
            if (serverToolBody) serverToolBody.appendChild(createErrorRow(5, "No servertool execution records"));
          } else if (serverToolBody) {
            for (const row of byTool.slice(0, 30)) {
              const tool = textOf(row.tool);
              const tr = document.createElement("tr");
              tr.appendChild(createCell("td", tool || "—", "mono"));
              tr.appendChild(createCell("td", formatInt(Number(row.executions || 0)), "mono"));
              tr.appendChild(createCell("td", formatInt(Number(row.success || 0)), "mono"));
              tr.appendChild(createCell("td", formatInt(Number(row.failure || 0)), "mono"));

              const detailsTd = document.createElement("td");
              const detailList = Array.isArray(recentByTool.get(tool)) ? recentByTool.get(tool).slice(0, 8) : [];
              if (!detailList.length) {
                detailsTd.textContent = "—";
              } else {
                const details = document.createElement("details");
                const summary = document.createElement("summary");
                summary.textContent = `${detailList.length} recent`;
                details.appendChild(summary);
                const pre = document.createElement("pre");
                pre.className = "mono";
                pre.style.margin = "8px 0 0";
                pre.style.whiteSpace = "pre-wrap";
                pre.style.wordBreak = "break-word";
                pre.textContent = detailList
                  .map((ev) => {
                    const ts = textOf(ev.ts || "—");
                    const stage = textOf(ev.stage || "—");
                    const result = textOf(ev.result || "—");
                    const req = textOf(ev.requestId || "—");
                    const msg = textOf(ev.message || "");
                    return `${ts} | ${req} | ${stage}/${result}${msg ? ` | ${msg}` : ""}`;
                  })
                  .join("\n");
                details.appendChild(pre);
                detailsTd.appendChild(details);
              }
              tr.appendChild(detailsTd);
              serverToolBody.appendChild(tr);
            }
            if (byTool.length > 30) {
              const tr = document.createElement("tr");
              const td = document.createElement("td");
              td.colSpan = 5;
              td.className = "muted";
              td.textContent = `… ${byTool.length - 30} more hidden`;
              tr.appendChild(td);
              serverToolBody.appendChild(tr);
            }
          }
        } catch {
          if (serverToolBody) serverToolBody.appendChild(createErrorRow(5, "Failed to parse servertool stats"));
        }

        const hint = $("controlHint");
        if (hint) {
          const st = snap.serverTool && snap.serverTool.stats && typeof snap.serverTool.stats === "object"
            ? snap.serverTool.stats
            : null;
          const stCount = st && Number.isFinite(Number(st.executions)) ? Number(st.executions) : 0;
          hint.textContent = `servers: ${servers.length} · quota keys: ${list.length} · servertool exec: ${stCount} · updated: ${formatTs(snap.nowMs)}`;
        }
      }

      async function refreshControl() {
        setLog("controlOpLog", "");
        try {
          const snap = await apiFetch("/daemon/control/snapshot");
          UI.controlSnapshot = snap;
          UI.controlSnapshotUpdatedAt = Date.now();
          renderControlSnapshot();
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("control");
          setLog("controlOpLog", `Control snapshot failed: ${e.message || e}`);
        }
      }

      async function controlMutate(action, payload = {}) {
        const out = await apiFetch("/daemon/control/mutate", {
          method: "POST",
          body: JSON.stringify({ action, ...payload })
        });
        return out;
      }

      async function refreshProviders() {
        const body = $("providersTbody");
        body.replaceChildren();
        try {
          const data = await apiFetch("/config/providers");
          const list = Array.isArray(data.providers) ? data.providers : [];
          const grouped = new Map();
          for (const p of list) {
            const t = textOf(p.type || "unknown") || "unknown";
            if (!grouped.has(t)) grouped.set(t, []);
            grouped.get(t).push(p);
          }
          const types = Array.from(grouped.keys()).sort((a, b) => a.localeCompare(b));
          for (const type of types) {
            const groupRow = document.createElement("tr");
            groupRow.className = "group-row";
            const groupCell = document.createElement("td");
            groupCell.colSpan = 8;
            groupCell.textContent = `${type} (${grouped.get(type).length})`;
            groupRow.appendChild(groupCell);
            body.appendChild(groupRow);

            const items = grouped.get(type);
            items.sort((a, b) => textOf(a.id).localeCompare(textOf(b.id)));
            for (const p of items) {
              const pid = textOf(p.id);
              const tr = document.createElement("tr");
              tr.className = "provider-row";
              tr.setAttribute("data-provider-id", pid);
              if (pid && pid === UI.selectedProviderId) tr.classList.add("selected");
              tr.appendChild(createCell("td", pid || "", "mono indent"));
              tr.appendChild(createCell("td", p.type || "", ""));
              tr.appendChild(createCell("td", String(Boolean(p.enabled)), ""));
              tr.appendChild(createCell("td", p.baseURL || "", "mono truncate", { title: true }));
              const preview = Array.isArray(p.modelsPreview) ? p.modelsPreview.map((x) => textOf(x)).filter(Boolean) : [];
              const modelSummary = preview.length ? `${p.modelCount || 0}: ${preview.join(", ")}${(p.modelCount || 0) > preview.length ? ", …" : ""}` : String(p.modelCount || 0);
              tr.appendChild(createCell("td", modelSummary, "mono truncate", { title: true }));
              tr.appendChild(createCell("td", p.compatibilityProfile || "", "mono truncate", { title: true }));
              tr.appendChild(createCell("td", p.authType || "", ""));
              const actionsTd = document.createElement("td");
              actionsTd.className = "actions-cell";
              const box = document.createElement("div");
              box.className = "actions";
              const edit = document.createElement("button");
              edit.textContent = "Edit";
              edit.setAttribute("data-action", "edit");
              edit.setAttribute("data-id", textOf(p.id));
              const test = document.createElement("button");
              test.textContent = "Test";
              test.setAttribute("data-action", "test");
              test.setAttribute("data-id", textOf(p.id));
              test.disabled = !(p && p.enabled !== false && Number(p.modelCount || 0) > 0);
              const del = document.createElement("button");
              del.textContent = "Delete";
              del.className = "danger";
              del.setAttribute("data-action", "delete");
              del.setAttribute("data-id", textOf(p.id));
              box.appendChild(edit);
              box.appendChild(test);
              box.appendChild(del);
              actionsTd.appendChild(box);
              tr.appendChild(actionsTd);
              body.appendChild(tr);
            }
          }
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("providers");
          body.appendChild(createErrorRow(8, e && e.message ? e.message : e));
        }
      }

      async function loadProvider(id) {
        setLog("providerOpLog", "");
        setSelectedProviderId(id);
        try {
          const data = await apiFetch(`/config/providers/${encodeURIComponent(id)}`);
          $("providerIdInput").value = id;
          providerEditorSetValue(data.provider || {});
          $("providerEditorTitle").textContent = `Provider editor: ${id}`;
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("provider load");
          setLog("providerOpLog", `Load failed: ${e.message}`);
          toast(`Load failed: ${e.message}`);
        }
      }

      async function saveProvider() {
        setLog("providerOpLog", "");
        const id = ($("providerIdInput").value || "").trim();
        if (!id) {
          setLog("providerOpLog", "provider id is required");
          toast("provider id is required");
          return;
        }
        try {
          const provider = providerEditorGetValue() || {};
          if (provider && typeof provider === "object") provider.id = id;
          const result = await apiFetch(`/config/providers/${encodeURIComponent(id)}`, {
            method: "PUT",
            body: JSON.stringify({ provider })
          });
          setLog("providerOpLog", `Saved. Path: ${result.path || "—"}\nRestart required to apply.`);
          toast("Provider saved.", "ok");
          providerEditorSetDirty(false);
          await refreshProviders();
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("provider save");
          setLog("providerOpLog", `Save failed: ${e.message}`);
          toast(`Save failed: ${e.message}`);
        }
      }

      async function deleteProvider(id) {
        setLog("providerOpLog", "");
        if (!id) {
          setLog("providerOpLog", "provider id is required");
          toast("provider id is required");
          return;
        }
        if (!confirm(`Delete provider "${id}" from user config?`)) return;
        try {
          const result = await apiFetch(`/config/providers/${encodeURIComponent(id)}`, { method: "DELETE" });
          setLog("providerOpLog", `Deleted. Path: ${result.path || "—"}\nRestart required to apply.`);
          toast("Provider deleted.", "ok");
          await refreshProviders();
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("provider delete");
          setLog("providerOpLog", `Delete failed: ${e.message}`);
          toast(`Delete failed: ${e.message}`);
        }
      }

      async function createApiKeyCredential() {
        setLog("providerOpLog", "");
        $("apikeySecretRefOut").textContent = "";
        const provider = ($("providerIdInput").value || "").trim();
        const alias = ($("apikeyAliasInput").value || "default").trim() || "default";
        const apiKey = ($("apikeyValueInput").value || "").trim();
        if (!provider) {
          setLog("providerOpLog", "provider id is required before creating an authfile");
          return null;
        }
        if (!apiKey) {
          setLog("providerOpLog", "apiKey is required");
          return null;
        }
        try {
          const out = await apiFetch("/daemon/credentials/apikey", {
            method: "POST",
            body: JSON.stringify({ provider, alias, apiKey })
          });
          $("apikeySecretRefOut").textContent = `secretRef: ${out.secretRef}`;
          return out.secretRef;
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("authfile create");
          setLog("providerOpLog", `Create authfile failed: ${e.message}`);
          toast(`Create authfile failed: ${e.message}`);
          return null;
        }
      }

      function applyPresetToEditor() {
        const preset = $("providerPreset").value;
        const base = presetFor(preset);
        const authMode = $("authMode").value;
        if (authMode === "none") {
          delete base.auth;
        }
        if (authMode === "cookie") {
          base.auth = {
            type: "iflow-cookie",
            cookieFile: ($("cookieFileInput").value || "").trim() || "~/.routecodex/auth/iflow.cookie"
          };
        }
        if (authMode === "oauth") {
          const t = ($("oauthTypeInput").value || "").trim() || "qwen-oauth";
          const alias = ($("oauthAliasInput").value || "default").trim() || "default";
          base.auth = { type: t, tokenFile: alias };
        }
        if (authMode === "apikey") {
          const secretRef = ($("apikeySecretRefOut").textContent || "").replace(/^secretRef:\\s*/i, "").trim();
          base.auth = { type: "apikey", apiKey: secretRef || "authfile-REPLACE_ME" };
        }
        providerEditorSetValue(base);
        providerEditorSetDirty(true);
      }

      function updateAuthModeUi() {
        const mode = $("authMode").value;
        $("authApikeyBox").style.display = mode === "apikey" ? "block" : "none";
        $("authOauthBox").style.display = mode === "oauth" ? "block" : "none";
        $("authCookieBox").style.display = mode === "cookie" ? "block" : "none";
      }

      function findAuthIssueForProviderAlias(providerRaw, aliasRaw) {
        const provider = textOf(providerRaw || "").trim().toLowerCase();
        const alias = textOf(aliasRaw || "").trim().toLowerCase();
        if (!provider || !alias) return null;
        const list = Array.isArray(UI.quotaProviders) ? UI.quotaProviders : [];
        if (provider !== "antigravity") return null;
        const prefix = `antigravity.${alias}.`;
        for (const q of list) {
          const pk = textOf(q && q.providerKey ? q.providerKey : "").trim().toLowerCase();
          if (!pk.startsWith(prefix)) continue;
          const issue = q && q.authIssue && typeof q.authIssue === "object" ? q.authIssue : null;
          if (issue && issue.kind === "google_account_verification") {
            return { kind: issue.kind, url: textOf(issue.url || ""), message: textOf(issue.message || "") };
          }
        }
        return null;
      }

      function findCredentialForSelection(providerRaw, aliasRaw) {
        const provider = textOf(providerRaw || "").trim().toLowerCase();
        const alias = textOf(aliasRaw || "default").trim().toLowerCase() || "default";
        const list = Array.isArray(UI.credentials) ? UI.credentials : [];
        for (const item of list) {
          const itemProvider = textOf(item && item.provider ? item.provider : "").trim().toLowerCase();
          const itemAlias = textOf(item && item.alias ? item.alias : "default").trim().toLowerCase() || "default";
          const kind = textOf(item && item.kind ? item.kind : "").trim().toLowerCase();
          if (kind !== "oauth") continue;
          if (itemProvider === provider && itemAlias === alias) {
            return item;
          }
        }
        return null;
      }

      function formatCredentialExpiry(cred) {
        if (!cred || cred.expiresInSec == null) return "—";
        const sec = Number(cred.expiresInSec);
        if (!Number.isFinite(sec)) return "—";
        if (sec <= 0) return "expired";
        if (sec < 60) return `${sec}s`;
        const min = Math.round(sec / 60);
        if (min < 60) return `${min}m`;
        const hour = Math.round(min / 60);
        return `${hour}h`;
      }

      function setOauthMode(modeRaw) {
        const mode = modeRaw === "auto" ? "auto" : "manual";
        UI.oauthMode = mode;
        const manualBtn = $("oauthModeManualBtn");
        const autoBtn = $("oauthModeAutoBtn");
        const manualPanel = $("oauthManualPanel");
        const autoPanel = $("oauthAutoPanel");
        if (manualBtn) manualBtn.classList.toggle("active", mode === "manual");
        if (autoBtn) autoBtn.classList.toggle("active", mode === "auto");
        if (manualPanel) manualPanel.style.display = mode === "manual" ? "block" : "none";
        if (autoPanel) autoPanel.style.display = mode === "auto" ? "block" : "none";
      }

      function updateOauthAuthIssueHint() {
        const issueHint = $("oauthAuthIssueHint");
        const verifyCenter = $("oauthVerifyCenter");
        const verifyUrlEl = $("oauthVerifyUrl");
        const provider = textOf($("oauthProviderSelect").value || "").trim().toLowerCase();
        const alias = textOf($("oauthAuthAliasInput").value || "default").trim().toLowerCase() || "default";
        const issue = findAuthIssueForProviderAlias(provider, alias);
        const cred = findCredentialForSelection(provider, alias);

        const statusPill = $("oauthSelectionStatusPill");
        const expiryPill = $("oauthSelectionExpiryPill");
        const issuePill = $("oauthSelectionIssuePill");
        if (statusPill) {
          statusPill.textContent = `status: ${cred ? textOf(cred.status || "—") : "not found"}`;
          statusPill.className = "pill";
          const statusRaw = textOf(cred && cred.status ? cred.status : "").trim().toLowerCase();
          if (statusRaw === "valid") statusPill.classList.add("ok");
          else if (statusRaw === "expired" || statusRaw === "invalid") statusPill.classList.add("bad");
          else if (statusRaw) statusPill.classList.add("warn");
        }
        if (expiryPill) {
          expiryPill.textContent = `expires: ${formatCredentialExpiry(cred)}`;
          expiryPill.className = "pill";
          const exp = Number(cred && cred.expiresInSec != null ? cred.expiresInSec : NaN);
          if (Number.isFinite(exp) && exp > 0 && exp < 600) {
            expiryPill.classList.add("warn");
          }
        }
        if (issuePill) {
          const hasIssue = Boolean(issue);
          issuePill.textContent = hasIssue ? "issue: verify required" : "issue: —";
          issuePill.className = `pill${hasIssue ? " bad" : ""}`;
        }

        if (!issue) {
          if (issueHint) {
            issueHint.style.display = "none";
            issueHint.textContent = "";
          }
          if (verifyCenter) verifyCenter.style.display = "none";
          if (verifyUrlEl) verifyUrlEl.textContent = "—";
          return null;
        }

        if (issue.kind === "google_account_verification") {
          if (issueHint) {
            issueHint.textContent =
              `⚠ Google requires account verification for alias "${alias}".\n` +
              `Use Verify Center to open the exact verify URL in Camoufox, then re-run auth.`;
            issueHint.style.display = "block";
          }
          if (verifyCenter) verifyCenter.style.display = "block";
          if (verifyUrlEl) verifyUrlEl.textContent = issue.url || "(missing verify url from quota state)";
          return issue;
        }

        if (issueHint) {
          issueHint.style.display = "none";
          issueHint.textContent = "";
        }
        if (verifyCenter) verifyCenter.style.display = "none";
        if (verifyUrlEl) verifyUrlEl.textContent = "—";
        return issue;
      }

      async function openAuthIssueInCamoufox(provider, alias, url) {
        setLog("credentialOpLog", "");
        try {
          await apiFetch("/daemon/oauth/open", {
            method: "POST",
            body: JSON.stringify({ provider, alias, url })
          });
          setLog("credentialOpLog", `Opened verification URL in Camoufox for ${provider}.${alias}.`);
        } catch (e) {
          setLog("credentialOpLog", `Open failed: ${e.message}`);
        }
      }

      async function openSelectedVerifyUrl() {
        const provider = textOf($("oauthProviderSelect").value || "").trim().toLowerCase();
        const alias = textOf($("oauthAuthAliasInput").value || "default").trim().toLowerCase() || "default";
        const issue = findAuthIssueForProviderAlias(provider, alias);
        if (!issue || !issue.url) {
          setLog("credentialOpLog", "No verify URL available for current provider/alias.");
          return;
        }
        await openAuthIssueInCamoufox(provider, alias, issue.url);
      }

      async function copySelectedVerifyUrl() {
        const provider = textOf($("oauthProviderSelect").value || "").trim().toLowerCase();
        const alias = textOf($("oauthAuthAliasInput").value || "default").trim().toLowerCase() || "default";
        const issue = findAuthIssueForProviderAlias(provider, alias);
        if (!issue || !issue.url) {
          setLog("credentialOpLog", "No verify URL available for current provider/alias.");
          return;
        }
        try {
          await navigator.clipboard.writeText(issue.url);
          setLog("credentialOpLog", "Verify URL copied.");
        } catch (e) {
          setLog("credentialOpLog", `Copy failed: ${e && e.message ? e.message : String(e)}`);
        }
      }

      function listAntigravityProviderKeysByAlias(aliasRaw) {
        const alias = textOf(aliasRaw || "").trim().toLowerCase();
        if (!alias) return [];
        const list = Array.isArray(UI.quotaProviders) ? UI.quotaProviders : [];
        const prefix = `antigravity.${alias}.`;
        const out = [];
        for (const q of list) {
          const pk = textOf(q && q.providerKey ? q.providerKey : "").trim();
          if (!pk) continue;
          if (pk.toLowerCase().startsWith(prefix)) out.push(pk);
        }
        out.sort((a, b) => a.localeCompare(b));
        return out;
      }

      async function recoverAntigravityAliasIfAuthVerify(aliasRaw) {
        if (!UI.adminAuth || !UI.adminAuth.authenticated) {
          return;
        }
        const keys = listAntigravityProviderKeysByAlias(aliasRaw);
        if (!keys.length) return;
        const toRecover = [];
        for (const key of keys) {
          const q = getQuotaStateByProviderKey(key);
          if (!q) continue;
          if (textOf(q.reason || "").trim() === "authVerify") {
            toRecover.push(key);
          }
        }
        if (!toRecover.length) {
          return;
        }
        for (const key of toRecover) {
          try {
            await apiFetch(`/quota/providers/${encodeURIComponent(key)}/recover`, { method: "POST" });
          } catch {
            // best-effort
          }
        }
      }

      async function refreshCredentials() {
        const body = $("credentialsTbody");
        body.replaceChildren();
        try {
          const items = await apiFetch("/daemon/credentials");
          UI.credentials = Array.isArray(items) ? items : [];
          // Best-effort: load quota provider state so we can surface upstream auth issues (e.g. Google verify required).
          try {
            const quota = await apiFetch("/quota/providers");
            const quotaProviders = quota && Array.isArray(quota.providers) ? quota.providers : [];
            UI.quotaProviders = quotaProviders;
            UI.quotaProvidersUpdatedAt = Date.now();
            UI.quotaProviderMap = new Map(quotaProviders.map((q) => [textOf(q.providerKey), q]));
          } catch {
            // ignore
          }

          for (const c of items || []) {
            const tr = document.createElement("tr");
            const exp = c.expiresInSec == null ? "—" : `${c.expiresInSec}s`;
            tr.appendChild(createCell("td", c.kind || "", ""));
            tr.appendChild(createCell("td", c.provider || "", "mono"));
            tr.appendChild(createCell("td", c.alias || "", "mono"));
            const statusTd = document.createElement("td");
            const statusRaw = textOf(c.status || "").trim().toLowerCase();
            statusTd.appendChild(pill(c.status || "—", statusRaw === "valid" ? "ok" : "warn"));
            const issue = findAuthIssueForProviderAlias(c.provider, c.alias);
            if (issue) {
              statusTd.appendChild(document.createTextNode(" "));
              statusTd.appendChild(pill("verify required", "bad"));
            }
            tr.appendChild(statusTd);
            tr.appendChild(createCell("td", exp, "mono"));
            tr.appendChild(createCell("td", c.secretRef || "—", "mono"));

            const actionTd = document.createElement("td");
            actionTd.className = "actions-cell";
            const actions = document.createElement("div");
            actions.className = "auth-actions";
            let hasAction = false;

            if (issue && issue.url) {
              const openVerify = document.createElement("button");
              openVerify.type = "button";
              openVerify.className = "auth-action-btn";
              openVerify.textContent = "Open Verify";
              openVerify.addEventListener("click", () => {
                void openAuthIssueInCamoufox(c.provider, c.alias, issue.url);
              });
              actions.appendChild(openVerify);
              hasAction = true;
            }

            if (textOf(c.kind || "").trim().toLowerCase() === "oauth" && (statusRaw === "expired" || statusRaw === "invalid")) {
              const recover = document.createElement("button");
              recover.type = "button";
              recover.className = "auth-action-btn primary";
              recover.textContent = "Recover";
              recover.addEventListener("click", () => {
                void runCredentialAutoRecovery(c);
              });
              actions.appendChild(recover);
              hasAction = true;
            }

            if (hasAction) {
              actionTd.appendChild(actions);
            } else {
              actionTd.classList.add("mono");
              actionTd.textContent = "—";
            }
            tr.appendChild(actionTd);
            body.appendChild(tr);
          }
          updateOauthAuthIssueHint();
        } catch (e) {
          body.appendChild(createErrorRow(7, e && e.message ? e.message : e));
          updateOauthAuthIssueHint();
        }
      }

      async function loadSettings() {
        try {
          const data = await apiFetch("/config/settings");
          const v = (data.oauthBrowser || "default").toLowerCase();
          $("oauthBrowserSelect").value = v === "camoufox" ? "camoufox" : "default";
        } catch {}
      }

      async function saveSettings() {
        setLog("credentialOpLog", "");
        const oauthBrowser = $("oauthBrowserSelect").value;
        try {
          const out = await apiFetch("/config/settings", {
            method: "PUT",
            body: JSON.stringify({ oauthBrowser })
          });
          setLog("credentialOpLog", `Saved oauthBrowser=${out.oauthBrowser}.`);
        } catch (e) {
          setLog("credentialOpLog", `Save failed: ${e.message}`);
        }
      }

      async function authorizeOauth(mode = "manual") {
        const safeMode = mode === "auto" ? "auto" : "manual";
        setLog("credentialOpLog", "");
        appendLog("credentialOpLog", `[${safeMode}] start authorize request ...`);
        const provider = $("oauthProviderSelect").value;
        const alias = ($("oauthAuthAliasInput").value || "default").trim() || "default";
        updateOauthAuthIssueHint();

        const openBrowser = safeMode === "auto"
          ? Boolean($("oauthAutoOpenBrowser") && $("oauthAutoOpenBrowser").checked)
          : Boolean($("oauthManualOpenBrowser") && $("oauthManualOpenBrowser").checked);
        const forceReauthorize = safeMode === "auto"
          ? Boolean($("oauthAutoForceReauth") && $("oauthAutoForceReauth").checked)
          : Boolean($("oauthManualForceReauth") && $("oauthManualForceReauth").checked);
        const headful = safeMode === "auto"
          ? Boolean($("oauthAutoHeadful") && $("oauthAutoHeadful").checked)
          : Boolean($("oauthManualHeadful") && $("oauthManualHeadful").checked);

        try {
          const out = await apiFetch("/daemon/oauth/authorize", {
            method: "POST",
            body: JSON.stringify({ provider, alias, openBrowser, forceReauthorize, mode: safeMode, headful })
          });
          setLog("credentialOpLog", `[${safeMode}] OK. tokenFile: ${out.tokenFile || "—"}`);
          await refreshCredentials();
          if (textOf(provider).trim().toLowerCase() === "antigravity") {
            try {
              await recoverAntigravityAliasIfAuthVerify(alias);
            } catch {}
            try {
              await refreshQuota();
              await refreshCredentials();
            } catch {}
          }
        } catch (e) {
          setLog("credentialOpLog", `[${safeMode}] Authorize failed: ${e.message}`);
        }
      }

      function setOauthContext(providerRaw, aliasRaw) {
        const provider = textOf(providerRaw || "").trim().toLowerCase();
        const alias = textOf(aliasRaw || "default").trim() || "default";
        const providerSelect = $("oauthProviderSelect");
        if (providerSelect) {
          const optionExists = Array.from(providerSelect.options || []).some((opt) => textOf(opt.value).trim().toLowerCase() === provider);
          if (optionExists) {
            providerSelect.value = provider;
          }
        }
        const aliasInput = $("oauthAuthAliasInput");
        if (aliasInput) {
          aliasInput.value = alias;
        }
        updateOauthAuthIssueHint();
      }

      async function openManualAuthFallback(providerRaw, aliasRaw, reason) {
        const provider = textOf(providerRaw || "").trim().toLowerCase();
        const alias = textOf(aliasRaw || "default").trim() || "default";
        selectTab("credentials");
        setOauthMode("manual");
        setOauthContext(provider, alias);
        if (reason) {
          appendLog("credentialOpLog", reason);
        }

        appendLog("credentialOpLog", "[step3] 自动启动 Manual Auth（headful）…");
        try {
          await apiFetch("/config/settings", {
            method: "PUT",
            body: JSON.stringify({ oauthBrowser: "camoufox" })
          });
        } catch (e) {
          appendLog("credentialOpLog", "[step3] set oauthBrowser=camoufox failed: " + (e && e.message ? e.message : String(e)));
        }

        try {
          const out = await apiFetch("/daemon/oauth/authorize", {
            method: "POST",
            body: JSON.stringify({
              provider,
              alias,
              mode: "manual",
              openBrowser: true,
              forceReauthorize: true,
              headful: true
            })
          });
          appendLog("credentialOpLog", "[step3] manual auth started: tokenFile=" + textOf(out && out.tokenFile ? out.tokenFile : "—"));
          appendLog("credentialOpLog", "[manual] 已尝试弹出认证窗口；若未自动完成，请在弹出的 portal 完成登录。");
          toast("Manual auth started: " + provider + "." + alias, "ok");
          return true;
        } catch (e) {
          appendLog("credentialOpLog", "[step3] manual auth auto-start failed: " + (e && e.message ? e.message : String(e)));
          appendLog("credentialOpLog", "[manual] 请点击 Start Manual Auth 重试。");
        }

        try {
          const btn = $("oauthAuthorizeManualBtn");
          if (btn && typeof btn.scrollIntoView === "function") {
            btn.scrollIntoView({ behavior: "smooth", block: "center" });
          }
          if (btn && typeof btn.focus === "function") {
            btn.focus();
          }
        } catch {
          // ignore focus/scroll failures
        }
        return false;
      }

      async function runCredentialAutoRecovery(cred) {
        const id = textOf(cred && cred.id ? cred.id : "").trim();
        const provider = textOf(cred && cred.provider ? cred.provider : "").trim().toLowerCase();
        const alias = textOf(cred && cred.alias ? cred.alias : "default").trim() || "default";
        if (!id || !provider) {
          setLog("credentialOpLog", "[recover] missing credential id/provider");
          return;
        }

        selectTab("credentials");
        setOauthContext(provider, alias);
        setLog("credentialOpLog", "[recover] " + provider + "." + alias + " (id=" + id + ")");

        let refreshOk = false;
        appendLog("credentialOpLog", "[step1] 尝试 refresh token …");
        try {
          const out = await apiFetch("/daemon/credentials/" + encodeURIComponent(id) + "/refresh", {
            method: "POST"
          });
          appendLog(
            "credentialOpLog",
            "[step1] refresh result: status=" + textOf(out && out.status ? out.status : "—") + " refreshed=" + (out && out.refreshed === true ? "yes" : "no")
          );
          await refreshCredentials();
          const latest = findCredentialForSelection(provider, alias);
          const latestStatus = textOf(latest && latest.status ? latest.status : "").trim().toLowerCase();
          const exp = Number(latest && latest.expiresInSec != null ? latest.expiresInSec : NaN);
          if (latestStatus === "valid" && (!Number.isFinite(exp) || exp > 0)) {
            refreshOk = true;
            appendLog("credentialOpLog", "[done] refresh 后已恢复有效 token。");
            toast("OAuth refreshed: " + provider + "." + alias, "ok");
          }
        } catch (e) {
          appendLog("credentialOpLog", "[step1] refresh failed: " + (e && e.message ? e.message : String(e)));
        }
        if (refreshOk) {
          return;
        }

        appendLog("credentialOpLog", "[step2] refresh 未恢复，启动 Camoufox auto oauth …");
        try {
          await apiFetch("/config/settings", {
            method: "PUT",
            body: JSON.stringify({ oauthBrowser: "camoufox" })
          });
        } catch (e) {
          appendLog("credentialOpLog", "[step2] set oauthBrowser=camoufox failed: " + (e && e.message ? e.message : String(e)));
        }

        try {
          const out = await apiFetch("/daemon/oauth/authorize", {
            method: "POST",
            body: JSON.stringify({
              provider,
              alias,
              mode: "auto",
              openBrowser: true,
              forceReauthorize: false,
              headful: false
            })
          });
          appendLog("credentialOpLog", "[step2] auto oauth ok: tokenFile=" + textOf(out && out.tokenFile ? out.tokenFile : "—"));
          await refreshCredentials();
          if (provider === "antigravity") {
            try {
              await refreshQuota();
              await refreshCredentials();
            } catch {
              // ignore quota refresh errors in recovery path
            }
          }
          const latest = findCredentialForSelection(provider, alias);
          const latestStatus = textOf(latest && latest.status ? latest.status : "").trim().toLowerCase();
          if (latestStatus === "valid") {
            appendLog("credentialOpLog", "[done] auto oauth 后 token 已恢复有效。");
            toast("OAuth recovered: " + provider + "." + alias, "ok");
            return;
          }
          appendLog("credentialOpLog", "[step2] auto oauth 执行完成，但状态仍非 valid。");
        } catch (e) {
          appendLog("credentialOpLog", "[step2] auto oauth failed: " + (e && e.message ? e.message : String(e)));
        }

        const manualStarted = await openManualAuthFallback(provider, alias, "[step3] 自动恢复失败，切换到手动认证。");
        if (!manualStarted) {
          toast("Auto recovery failed, switched to manual auth (" + provider + "." + alias + ").");
        }
      }

      const routingEditorState = {
	        value: {},
	        dirty: false
	      };

	      function routingEditorClone(value) {
	        try {
	          return value == null ? value : JSON.parse(JSON.stringify(value));
	        } catch {
	          return value;
	        }
	      }

	      function routingEditorSetDirty(dirty) {
	        routingEditorState.dirty = Boolean(dirty);
	      }

	      function routingEditorSetValue(value) {
	        routingEditorState.value = routingEditorClone(value) || {};
	        routingEditorSetDirty(false);
	        routingEditorRender();
	      }

	      function routingEditorGetValue() {
	        return routingEditorClone(routingEditorState.value) || {};
	      }

	      function routingEditorPathToString(path) {
	        if (!path || !path.length) return "";
	        return path.map((p) => String(p)).join(".");
	      }

	      function routingEditorGetByPath(root, path) {
	        let cur = root;
	        for (const part of path || []) {
	          if (cur == null) return undefined;
	          cur = cur[part];
	        }
	        return cur;
	      }

	      function routingEditorSetByPath(root, path, nextValue) {
	        if (!root || typeof root !== "object") return;
	        if (!path || !path.length) return;
	        const last = path[path.length - 1];
	        let cur = root;
	        for (let i = 0; i < path.length - 1; i += 1) {
	          const part = path[i];
	          const existing = cur[part];
	          if (existing == null || typeof existing !== "object") cur[part] = {};
	          cur = cur[part];
	        }
	        cur[last] = nextValue;
	      }

	      function routingEditorDeleteByPath(root, path) {
	        if (!root || typeof root !== "object") return;
	        if (!path || !path.length) return;
	        const last = path[path.length - 1];
	        let cur = root;
	        for (let i = 0; i < path.length - 1; i += 1) {
	          const part = path[i];
	          if (cur == null) return;
	          cur = cur[part];
	        }
	        if (Array.isArray(cur)) {
	          const idx = Number(last);
	          if (Number.isFinite(idx) && idx >= 0 && idx < cur.length) cur.splice(idx, 1);
	          return;
	        }
	        try { delete cur[last]; } catch {}
	      }

	      function routingEditorKind(value) {
	        if (value === null) return "null";
	        if (Array.isArray(value)) return "array";
	        const t = typeof value;
	        if (t === "string") return "string";
	        if (t === "number") return "number";
	        if (t === "boolean") return "boolean";
	        if (t === "object") return "object";
	        return "string";
	      }

	      function routingEditorCoerce(kind, raw) {
	        if (kind === "null") return null;
	        if (kind === "boolean") return raw === true || raw === "true";
	        if (kind === "number") {
	          const n = typeof raw === "number" ? raw : Number.parseFloat(String(raw));
	          return Number.isFinite(n) ? n : 0;
	        }
	        if (kind === "array") return [];
	        if (kind === "object") return {};
	        return String(raw ?? "");
	      }

	      function looksLikeRoutingTargetString(path, value) {
	        const s = textOf(value).trim();
	        if (!s) return false;
	        if (s.length > 320) return false;
	        if (s.includes(" ")) return false;
	        if (!s.includes(".")) return false;
	        const root = routingEditorState.value || {};
	        const parentPath = path.slice(0, -1);
	        const parent = routingEditorGetByPath(root, parentPath);
	        const parentKey = path.length >= 2 ? path[path.length - 2] : null;
	        if (parentKey === "targets") return true;
	        if (Array.isArray(parent) && path.length === 2 && typeof path[0] === "string") return true;
	        return false;
	      }

	      function resolveTargetToProviderKeys(target, providersOverride) {
        const raw = textOf(target).trim();
        if (!raw) return [];
        const list = Array.isArray(providersOverride)
          ? providersOverride
          : (Array.isArray(UI.quotaProviders) ? UI.quotaProviders : []);
        const keys = list.map((p) => textOf(p && p.providerKey ? p.providerKey : "")).filter(Boolean);
        const known = new Set(keys);
        if (!known.size) return [];
        if (known.has(raw)) return [raw];

        const candidates = new Set();
        const bracketMatch = raw.match(/^([^.[\]]+)\[([^\]]+)\]\.(.+)$/);
        if (bracketMatch) {
          const providerId = textOf(bracketMatch[1]).trim();
          const authAlias = textOf(bracketMatch[2]).trim();
          const modelId = textOf(bracketMatch[3]).trim();
          if (providerId && authAlias && modelId) {
            candidates.add(providerId + "." + authAlias + "." + modelId);
          }
        }

        const dotted = raw.split(".").filter(Boolean);
        if (dotted.length >= 3) {
          const providerId = dotted[0];
          const modelId = dotted.slice(2).join(".");
          if (providerId && modelId) {
            candidates.add(raw);
            candidates.add(providerId + "." + modelId);
          }
        } else if (dotted.length === 2) {
          candidates.add(raw);
        }

        for (const c of candidates) {
          if (known.has(c)) return [c];
        }

        const out = [];
        const addByProviderModel = (providerId, modelId) => {
          if (!providerId || !modelId) return;
          const prefix = providerId + ".";
          const suffix = "." + modelId;
          for (const k of keys) {
            if (k.startsWith(prefix) && k.endsWith(suffix)) out.push(k);
          }
        };

        if (bracketMatch) {
          addByProviderModel(textOf(bracketMatch[1]).trim(), textOf(bracketMatch[3]).trim());
        }

        if (dotted.length >= 2) {
          addByProviderModel(dotted[0], dotted.slice(1).join("."));
          if (dotted.length >= 3) {
            addByProviderModel(dotted[0], dotted.slice(2).join("."));
          }
        }

        return Array.from(new Set(out)).sort((a, b) => a.localeCompare(b));
      }

      function getQuotaStateByProviderKey(providerKey) {
	        const map = UI.quotaProviderMap instanceof Map ? UI.quotaProviderMap : null;
	        if (map && map.has(providerKey)) return map.get(providerKey);
	        const list = Array.isArray(UI.quotaProviders) ? UI.quotaProviders : [];
	        return list.find((p) => textOf(p && p.providerKey ? p.providerKey : "") === providerKey) || null;
	      }

	      async function routingQuotaAction(kind, providerKey) {
	        if (!providerKey) return;
	        if (!UI.adminAuth || !UI.adminAuth.authenticated) {
	          notifyUnauthorizedOnce("routing quota action");
	          return;
	        }
	        try {
	          if (kind === "recover") {
	            await apiFetch(`/quota/providers/${encodeURIComponent(providerKey)}/recover`, { method: "POST" });
	          } else if (kind === "disable") {
	            const minutes = Number.parseFloat(textOf($("routingQuotaDurationSelect").value || "60"));
	            if (!Number.isFinite(minutes) || minutes <= 0) throw new Error("Invalid minutes");
	            const modeRaw = (textOf($("routingQuotaModeSelect").value) || "cooldown").trim().toLowerCase();
	            const mode = modeRaw === "blacklist" ? "blacklist" : "cooldown";
	            await apiFetch(`/quota/providers/${encodeURIComponent(providerKey)}/disable`, {
	              method: "POST",
	              body: JSON.stringify({ mode, durationMinutes: minutes })
	            });
	          } else {
	            return;
	          }
	          await refreshRuntimes();
	          routingEditorRender();
	        } catch (e) {
	          if (e && e.status === 401) notifyUnauthorizedOnce("routing quota action");
	          toast(`Action failed: ${e && e.message ? e.message : String(e)}`);
	        }
	      }

	      function routingEditorRenderTargetActions(target) {
	        const providerKeys = resolveTargetToProviderKeys(target);
	        if (!providerKeys.length) return null;

	        const box = document.createElement("div");
	        box.className = "routing-target-actions";

	        for (const providerKey of providerKeys) {
	          const row = document.createElement("div");
	          row.className = "routing-target-row";

	          const key = document.createElement("span");
	          key.className = "routing-target-key mono";
	          key.textContent = providerKey;

	          const state = getQuotaStateByProviderKey(providerKey);
	          const inPool = state ? Boolean(state.inPool) : null;
	          const untilMs = state ? Math.max(Number(state.blacklistUntil || 0), Number(state.cooldownUntil || 0)) : 0;
	          const meta = document.createElement("span");
	          meta.className = "routing-target-meta";
	          meta.textContent =
	            inPool === null
	              ? "unknown"
	              : inPool
	                ? "online"
	                : untilMs
	                  ? `offline ${formatEpochWithDelta(untilMs)}`
	                  : "offline";

	          const offBtn = document.createElement("button");
	          offBtn.textContent = "Offline";
	          offBtn.className = "danger";
	          offBtn.addEventListener("click", (e) => {
	            e.preventDefault();
	            e.stopPropagation();
	            void routingQuotaAction("disable", providerKey);
	          });

	          const recBtn = document.createElement("button");
	          recBtn.textContent = "Recover";
	          recBtn.addEventListener("click", (e) => {
	            e.preventDefault();
	            e.stopPropagation();
	            void routingQuotaAction("recover", providerKey);
	          });

	          row.appendChild(key);
	          row.appendChild(meta);
	          row.appendChild(offBtn);
	          row.appendChild(recBtn);
	          box.appendChild(row);
	        }

	        return box;
	      }

	      function routingEditorRender() {
	        const container = $("routingKvEditor");
	        if (!container) return;
	        try {
	          container.replaceChildren();
	        } catch {
	          try { container.innerHTML = ""; } catch {}
	        }
	        try {
	          container.appendChild(routingEditorRenderNode("routing", routingEditorState.value || {}, [], 0, true));
	        } catch (e) {
	          const msg = e && e.message ? e.message : String(e);
	          try { container.textContent = `Render failed: ${msg}`; } catch {}
	        }
	      }

	      function routingEditorRenderNode(label, value, path, depth, isRoot = false) {
	        const isObj = value !== null && typeof value === "object";
	        const isArr = Array.isArray(value);
	        const kind = routingEditorKind(value);

	        if (!isObj) {
	          const row = document.createElement("div");
	          row.className = "kv-leaf";

	          const keyEl = document.createElement("div");
	          keyEl.className = "kv-key";
	          keyEl.textContent = label;

	          const typeSel = document.createElement("select");
	          typeSel.className = "kv-type";
	          typeSel.innerHTML = [
	            "<option value=\"string\">string</option>",
	            "<option value=\"number\">number</option>",
	            "<option value=\"boolean\">boolean</option>",
	            "<option value=\"null\">null</option>",
	            "<option value=\"object\">object</option>",
	            "<option value=\"array\">array</option>"
	          ].join("");
	          typeSel.value = kind;
	          typeSel.addEventListener("click", (e) => e.stopPropagation());
	          typeSel.addEventListener("change", () => {
	            const root = routingEditorState.value || {};
	            routingEditorSetByPath(root, path, routingEditorCoerce(typeSel.value, ""));
	            routingEditorSetDirty(true);
	            routingEditorRender();
	          });

	          const valWrap = document.createElement("div");
	          valWrap.className = "kv-val";

	          if (kind === "boolean") {
	            const sel = document.createElement("select");
	            sel.innerHTML = `<option value="true">true</option><option value="false">false</option>`;
	            sel.value = value ? "true" : "false";
	            sel.addEventListener("click", (e) => e.stopPropagation());
	            sel.addEventListener("change", () => {
	              const root = routingEditorState.value || {};
	              routingEditorSetByPath(root, path, sel.value === "true");
	              routingEditorSetDirty(true);
	              routingEditorRender();
	            });
	            valWrap.appendChild(sel);
	          } else if (kind === "number") {
	            const inp = document.createElement("input");
	            inp.type = "number";
	            inp.value = String(value);
	            inp.addEventListener("click", (e) => e.stopPropagation());
	            inp.addEventListener("change", () => {
	              const root = routingEditorState.value || {};
	              const n = Number.parseFloat(inp.value);
	              routingEditorSetByPath(root, path, Number.isFinite(n) ? n : 0);
	              routingEditorSetDirty(true);
	              routingEditorRender();
	            });
	            valWrap.appendChild(inp);
	          } else if (kind === "null") {
	            const span = document.createElement("span");
	            span.className = "mono";
	            span.textContent = "null";
	            valWrap.appendChild(span);
	          } else {
	            const inp = document.createElement("input");
	            inp.type = "text";
	            inp.value = value == null ? "" : String(value);
	            inp.addEventListener("click", (e) => e.stopPropagation());
	            inp.addEventListener("change", () => {
	              const root = routingEditorState.value || {};
	              routingEditorSetByPath(root, path, String(inp.value));
	              routingEditorSetDirty(true);
	              routingEditorRender();
	            });
	            valWrap.appendChild(inp);

	            if (looksLikeRoutingTargetString(path, value)) {
	              const widget = routingEditorRenderTargetActions(inp.value);
	              if (widget) valWrap.appendChild(widget);
	            }
	          }

	          const actions = document.createElement("div");
	          actions.className = "kv-actions";
	          if (!isRoot) {
	            const del = document.createElement("button");
	            del.textContent = "Del";
	            del.className = "danger";
	            del.addEventListener("click", (e) => {
	              e.preventDefault();
	              e.stopPropagation();
	              const root = routingEditorState.value || {};
	              routingEditorDeleteByPath(root, path);
	              routingEditorSetDirty(true);
	              routingEditorRender();
	            });
	            actions.appendChild(del);
	          }
	          const pathEl = document.createElement("span");
	          pathEl.className = "kv-path mono";
	          pathEl.textContent = routingEditorPathToString(path);
	          actions.appendChild(pathEl);

	          row.appendChild(keyEl);
	          row.appendChild(typeSel);
	          row.appendChild(valWrap);
	          row.appendChild(actions);
	          return row;
	        }

	        const details = document.createElement("details");
	        details.open = isRoot || depth < 1;

	        const summary = document.createElement("summary");

	        const keyEl = document.createElement("div");
	        keyEl.className = "kv-key";
	        keyEl.textContent = label;

	        const metaEl = document.createElement("div");
	        metaEl.className = "kv-meta";
	        metaEl.textContent = kvTypeMeta(value);

	        const actions = document.createElement("div");
	        actions.className = "kv-actions";

	        if (isArr) {
	          const add = document.createElement("button");
	          add.textContent = "+Item";
	          add.addEventListener("click", (e) => {
	            e.preventDefault();
	            e.stopPropagation();
	            const t = (prompt("Item type: string/number/boolean/null/object/array", "string") || "string").trim().toLowerCase();
	            const k = ["string","number","boolean","null","object","array"].includes(t) ? t : "string";
	            let init = "";
	            if (k === "boolean") init = prompt("Value: true/false", "false") || "false";
	            else if (k === "number") init = prompt("Value (number)", "0") || "0";
	            else if (k === "string") init = prompt("Value (string)", "") || "";
	            const v = routingEditorCoerce(k, k === "boolean" ? init === "true" : init);
	            const root = routingEditorState.value || {};
	            const arr = routingEditorGetByPath(root, path);
	            if (Array.isArray(arr)) {
	              arr.push(v);
	              routingEditorSetDirty(true);
	              routingEditorRender();
	            }
	          });
	          actions.appendChild(add);
	        } else {
	          const add = document.createElement("button");
	          add.textContent = "+Key";
	          add.addEventListener("click", (e) => {
	            e.preventDefault();
	            e.stopPropagation();
	            const name = (prompt("Key name", "") || "").trim();
	            if (!name) return;
	            const t = (prompt("Value type: string/number/boolean/null/object/array", "string") || "string").trim().toLowerCase();
	            const k = ["string","number","boolean","null","object","array"].includes(t) ? t : "string";
	            let init = "";
	            if (k === "boolean") init = prompt("Value: true/false", "false") || "false";
	            else if (k === "number") init = prompt("Value (number)", "0") || "0";
	            else if (k === "string") init = prompt("Value (string)", "") || "";
	            const v = routingEditorCoerce(k, k === "boolean" ? init === "true" : init);
	            const root = routingEditorState.value || {};
	            const obj = routingEditorGetByPath(root, path);
	            if (obj && typeof obj === "object" && !Array.isArray(obj)) {
	              obj[name] = v;
	              routingEditorSetDirty(true);
	              routingEditorRender();
	            }
	          });
	          actions.appendChild(add);
	        }

	        if (!isRoot) {
	          const del = document.createElement("button");
	          del.textContent = "Del";
	          del.className = "danger";
	          del.addEventListener("click", (e) => {
	            e.preventDefault();
	            e.stopPropagation();
	            const root = routingEditorState.value || {};
	            routingEditorDeleteByPath(root, path);
	            routingEditorSetDirty(true);
	            routingEditorRender();
	          });
	          actions.appendChild(del);
	        }

	        const pathEl = document.createElement("span");
	        pathEl.className = "kv-path mono";
	        pathEl.textContent = routingEditorPathToString(path);
	        actions.appendChild(pathEl);

	        summary.appendChild(keyEl);
	        summary.appendChild(metaEl);
	        summary.appendChild(actions);
	        details.appendChild(summary);

	        if (isArr) {
	          for (let i = 0; i < value.length; i += 1) {
	            details.appendChild(routingEditorRenderNode(String(i), value[i], path.concat([i]), depth + 1));
	          }
	          return details;
	        }

	        let keys = [];
	        try {
	          keys = Object.keys(value);
	          keys.sort((a, b) => a.localeCompare(b));
	        } catch {
	          keys = [];
	        }
	        for (const childKey of keys) {
	          details.appendChild(routingEditorRenderNode(childKey, value[childKey], path.concat([childKey]), depth + 1));
	        }

	        return details;
	      }

	      async function loadRouting() {
	        setLog("routingOpLog", "");
	        const auth = UI.adminAuth ? UI.adminAuth : await refreshAdminAuthStatus();
	        if (!auth || !auth.authenticated) {
	          notifyUnauthorizedOnce("routing");
	          return;
	        }
	        try {
	          const selectedPath = textOf($("routingSourceSelect").value || "").trim();
	          const query = selectedPath ? `?path=${encodeURIComponent(selectedPath)}` : "";
	          const out = await apiFetch(`/config/routing${query}`);
	          UI.routingLocation = out.location || "virtualrouter.routing";
	          routingEditorSetValue(out.routing || {});
	          setLog("routingOpLog", `Loaded. Path: ${out.path || "—"}\nLocation: ${UI.routingLocation}`);
	          toast("Routing loaded.", "ok");
	        } catch (e) {
	          if (e && e.status === 401) notifyUnauthorizedOnce("routing");
	          setLog("routingOpLog", `Load failed: ${e.message}`);
	          toast(`Load failed: ${e.message}`);
	        }
	      }

	      async function saveRouting() {
	        setLog("routingOpLog", "");
	        const auth = UI.adminAuth ? UI.adminAuth : await refreshAdminAuthStatus();
	        if (!auth || !auth.authenticated) {
	          notifyUnauthorizedOnce("routing save");
	          return;
	        }
	        try {
	          const selectedPath = textOf($("routingSourceSelect").value || "").trim();
	          const query = selectedPath ? `?path=${encodeURIComponent(selectedPath)}` : "";
	          const routing = routingEditorGetValue() || {};
	          const out = await apiFetch(`/config/routing${query}`, {
	            method: "PUT",
	            body: JSON.stringify({ routing, location: UI.routingLocation, path: selectedPath || undefined })
	          });
	          UI.routingLocation = out.location || UI.routingLocation;
	          setLog("routingOpLog", `Saved. Path: ${out.path || "—"}\nLocation: ${UI.routingLocation}\nRestart required to apply.`);
	          toast("Routing saved.", "ok");
	          routingEditorSetDirty(false);
	        } catch (e) {
	          if (e && e.status === 401) notifyUnauthorizedOnce("routing save");
	          setLog("routingOpLog", `Save failed: ${e.message}`);
	          toast(`Save failed: ${e.message}`);
	        }
	      }

	      async function refreshRoutingSources() {
	        const select = $("routingSourceSelect");
	        if (!select) return;
	        const prev = textOf(select.value || "");
	        try {
	          const out = await apiFetch("/config/routing/sources");
	          const sources = Array.isArray(out && out.sources) ? out.sources : [];
	          UI.routingSources = sources;
	          UI.routingSourcesUpdatedAt = Date.now();

	          select.replaceChildren();
	          for (const s of sources) {
	            const opt = document.createElement("option");
	            opt.value = textOf(s.path || "");
	            const version = s.version ? ` v=${s.version}` : "";
	            const loc = s.location ? ` (${s.location})` : "";
	            const kind = s.kind ? `[${s.kind}] ` : "";
	            opt.textContent = `${kind}${textOf(s.label || s.path || "")}${version}${loc}`;
	            select.appendChild(opt);
	          }

	          const active = textOf(out && out.activePath ? out.activePath : "");
	          const hasPrev = sources.some((s) => textOf(s.path) === prev);
	          const hasActive = sources.some((s) => textOf(s.path) === active);
	          if (hasPrev) select.value = prev;
	          else if (hasActive) select.value = active;

	          toast("Routing sources refreshed.", "ok");
	        } catch (e) {
	          if (e && e.status === 401) notifyUnauthorizedOnce("routing sources");
	          toast(`Routing sources failed: ${e && e.message ? e.message : String(e)}`);
	        }
	      }

	      async function refreshRuntimes() {
	        try {
	          const quota = await apiFetch("/quota/providers");
	          const quotaProviders = quota && Array.isArray(quota.providers) ? quota.providers : [];
	          UI.quotaProviders = quotaProviders;
	          UI.quotaProvidersUpdatedAt = Date.now();
	          UI.quotaProviderMap = new Map(quotaProviders.map((q) => [textOf(q.providerKey), q]));
	        } catch (e) {
	          if (e && e.status === 401) notifyUnauthorizedOnce("pool status");
	          throw e;
	        }
	      }

      function formatEpochMs(ms) {
        if (typeof ms !== "number" || !Number.isFinite(ms) || ms <= 0) return "—";
        try {
          return new Date(ms).toLocaleString();
        } catch {
          return String(ms);
        }
      }

      function formatDurationMs(ms) {
        if (typeof ms !== "number" || !Number.isFinite(ms)) return "—";
        const abs = Math.abs(ms);
        const sign = ms < 0 ? "-" : "";
        const s = Math.round(abs / 1000);
        if (s < 60) return `${sign}${s}s`;
        const m = Math.round(s / 60);
        if (m < 60) return `${sign}${m}m`;
        const h = Math.round(m / 60);
        if (h < 48) return `${sign}${h}h`;
        const d = Math.round(h / 24);
        return `${sign}${d}d`;
      }

      function formatEpochWithDelta(ms) {
        if (typeof ms !== "number" || !Number.isFinite(ms) || ms <= 0) return "—";
        const delta = ms - Date.now();
        const tail = delta >= 0 ? `in ${formatDurationMs(delta)}` : `${formatDurationMs(delta)} ago`;
        return `${formatEpochMs(ms)} (${tail})`;
      }

	      function pill(text, kind) {
	        const span = document.createElement("span");
	        span.className = `pill ${kind || ""}`.trim();
	        span.textContent = textOf(text);
	        return span;
	      }

      function extractRoutingTargets(routing) {
        const out = new Set();
        if (!routing || typeof routing !== "object") return out;
        for (const routeName of Object.keys(routing)) {
          const pools = routing[routeName];
          if (!Array.isArray(pools)) continue;
          for (const pool of pools) {
            if (!pool || typeof pool !== "object") continue;
            const targets = pool.targets;
            if (!Array.isArray(targets)) continue;
            for (const t of targets) {
              if (typeof t === "string" && t.trim()) out.add(t.trim());
            }
          }
        }
        return out;
      }

      function resolveRoutedProviderKeys(routingTargets, providers) {
        const targets = routingTargets instanceof Set ? Array.from(routingTargets) : [];
        const list = Array.isArray(providers) ? providers : [];
        const resolved = new Set();
        if (!targets.length || !list.length) return resolved;

        for (const t of targets) {
          const mapped = resolveTargetToProviderKeys(t, list);
          for (const key of mapped) {
            if (key) resolved.add(key);
          }
        }
        return resolved;
      }

      async function refreshRoutingTargets() {
        try {
          const routingOut = await apiFetch("/config/routing");
          UI.routingTargets = extractRoutingTargets(routingOut && routingOut.routing ? routingOut.routing : {});
          UI.routingTargetsUpdatedAt = Date.now();
        } catch {
          UI.routingTargets = null;
          UI.routingTargetsUpdatedAt = Date.now();
        }
      }

	      async function refreshQuota() {
	        const body = $("quotaTbody");
	        body.replaceChildren();
	        setLog("quotaOpLog", "");
          clearQuotaRenderedGroups();
	        try {
	          // Load routing targets so we can filter out providers not referenced by routing pools.
	          await refreshRoutingTargets();
          // Force refresh quota first so UI doesn't show stale pool state.
          try {
            await apiFetch("/daemon/modules/quota/refresh", { method: "POST" });
          } catch (e) {
            // Backwards compatibility: older servers may only support reset.
            if (e && e.status === 404) {
              try {
                await apiFetch("/daemon/modules/quota/reset", { method: "POST" });
              } catch (e2) {
                throw e2;
              }
            } else {
              throw e;
            }
          }
          const out = await apiFetch("/quota/providers");
          UI.quotaProviders = Array.isArray(out.providers) ? out.providers : [];
          UI.quotaProvidersUpdatedAt = Date.now();
	          UI.quotaProviderMap = new Map(UI.quotaProviders.map((q) => [textOf(q.providerKey), q]));
	          updateOauthAuthIssueHint();
	          renderQuotaProviders();
            updateQuotaSelectionSummary();
	        } catch (e) {
	          if (e && e.status === 401) notifyUnauthorizedOnce("quota");
	          else toast(e && e.message ? e.message : String(e || "quota refresh failed"));
	          body.appendChild(createErrorRow(8, e && e.message ? e.message : e));
	        }
	      }

        function normalizeProviderKeyList(value) {
          if (Array.isArray(value)) {
            return value.map((k) => textOf(k)).map((k) => k.trim()).filter(Boolean);
          }
          const single = textOf(value || "").trim();
          return single ? [single] : [];
        }

        function clearQuotaRenderedGroups() {
          UI.quotaRenderedVisibleKeys = [];
          UI.quotaRenderedGroups = new Map();
        }

        function computeSelectionState(keys) {
          const sel = UI.quotaSelection instanceof Set ? UI.quotaSelection : new Set();
          let any = false;
          let all = true;
          for (const k of keys) {
            const hit = sel.has(k);
            if (hit) any = true;
            else all = false;
          }
          return { any, all };
        }

        function setGroupCheckboxState(checkbox, keys) {
          if (!checkbox) return;
          const { any, all } = computeSelectionState(keys);
          checkbox.indeterminate = Boolean(any && !all);
          checkbox.checked = Boolean(all && keys.length > 0);
        }

        function syncQuotaRowCheckboxes() {
          const sel = UI.quotaSelection instanceof Set ? UI.quotaSelection : new Set();
          const body = $("quotaTbody");
          if (!body) return;
          body.querySelectorAll("input[data-select-key]").forEach((el) => {
            const key = el.getAttribute("data-select-key");
            if (!key) return;
            el.checked = sel.has(key);
          });
        }

        function updateQuotaSelectionSummary() {
          syncQuotaRowCheckboxes();
          const hint = $("quotaSelectionHint");
          if (hint) {
            const n = UI.quotaSelection instanceof Set ? UI.quotaSelection.size : 0;
            hint.textContent = `selected ${n}`;
          }
          const master = $("quotaSelectAllVisibleToggle");
          if (master) {
            setGroupCheckboxState(master, Array.isArray(UI.quotaRenderedVisibleKeys) ? UI.quotaRenderedVisibleKeys : []);
          }
          if (UI.quotaRenderedGroups instanceof Map) {
            for (const entry of UI.quotaRenderedGroups.values()) {
              if (!entry || !entry.checkbox || !Array.isArray(entry.keys)) continue;
              setGroupCheckboxState(entry.checkbox, entry.keys);
            }
          }
        }

        function setQuotaSelection(keys, selected) {
          if (!(UI.quotaSelection instanceof Set)) UI.quotaSelection = new Set();
          for (const k of keys) {
            if (!k) continue;
            if (selected) UI.quotaSelection.add(k);
            else UI.quotaSelection.delete(k);
          }
          updateQuotaSelectionSummary();
        }

        function clearQuotaSelection() {
          if (UI.quotaSelection instanceof Set) UI.quotaSelection.clear();
          updateQuotaSelectionSummary();
        }

        function resolveQuotaActionTargets() {
          const selected = UI.quotaSelection instanceof Set ? Array.from(UI.quotaSelection) : [];
          if (selected.length) return selected;
          return normalizeProviderKeyList($("quotaKeyInput")?.value);
        }

        let quotaRefreshTimer = null;
        function scheduleQuotaRefresh() {
          const auto = $("quotaAutoRefreshToggle");
          if (auto && auto.checked === false) return;
          if (quotaRefreshTimer) clearTimeout(quotaRefreshTimer);
          quotaRefreshTimer = setTimeout(() => {
            quotaRefreshTimer = null;
            void refreshQuota();
          }, 550);
        }

	      function renderQuotaProviders() {
	        const body = $("quotaTbody");
	        body.replaceChildren();
          clearQuotaRenderedGroups();

	        const filter = textOf($("quotaFilterInput").value || "").trim().toLowerCase();
	        const hideOk = Boolean($("quotaHideOkToggle").checked);
        const routedProviderKeys = resolveRoutedProviderKeys(UI.routingTargets, UI.quotaProviders);

        const list = Array.isArray(UI.quotaProviders) ? UI.quotaProviders : [];
        const next = list
          .filter((q) => {
            const keyRaw = textOf(q && q.providerKey ? q.providerKey : "");
            const key = keyRaw.toLowerCase();
            if (filter && !key.includes(filter)) return false;
            if (hideOk && q && q.inPool === true) return false;
            if (!routedProviderKeys.has(keyRaw)) return false;
            return true;
          })
          .slice();

        // Keep order stable across polling refreshes: avoid health-based sorting which makes the table jump.
        next.sort((a, b) => textOf(a?.providerKey).localeCompare(textOf(b?.providerKey)));

	        if (!next.length) {
	          body.appendChild(createErrorRow(8, "No providers matched filter."));
	          return;
	        }

        function splitProviderKey(providerKey) {
          const raw = textOf(providerKey || "");
          const parts = raw.split(".");
          if (parts.length >= 3) {
            return { providerId: parts[0], authAlias: parts[1], model: parts.slice(2).join(".") };
          }
          if (parts.length === 2) {
            return { providerId: parts[0], authAlias: "", model: parts[1] };
          }
          return { providerId: raw, authAlias: "", model: "" };
        }

        const byProvider = new Map();
        for (const q of next) {
          const pk = textOf(q && q.providerKey ? q.providerKey : "");
          const { providerId, authAlias, model } = splitProviderKey(pk);
          if (!byProvider.has(providerId)) byProvider.set(providerId, new Map());
          const byAlias = byProvider.get(providerId);
          if (!byAlias.has(authAlias)) byAlias.set(authAlias, []);
          byAlias.get(authAlias).push({ q, pk, providerId, authAlias, model });
        }

	        const providerIds = Array.from(byProvider.keys()).sort((a, b) => a.localeCompare(b));
	        const groupCols = 8;

	        const appendGroupRow = (label, opts = {}) => {
	          const tr = document.createElement("tr");
	          tr.className = "group-row";
            const keys = Array.isArray(opts.keys) ? opts.keys : [];
            const canSelect = Boolean(keys.length);
            const td0 = document.createElement("td");
            td0.className = "check-cell";
            if (canSelect) {
              const cb = document.createElement("input");
              cb.type = "checkbox";
              cb.title = "Select group";
              cb.addEventListener("change", () => setQuotaSelection(keys, cb.checked));
              td0.appendChild(cb);
              if (UI.quotaRenderedGroups instanceof Map && typeof opts.groupId === "string" && opts.groupId) {
                UI.quotaRenderedGroups.set(opts.groupId, { checkbox: cb, keys });
              }
              setGroupCheckboxState(cb, keys);
            }
            tr.appendChild(td0);

	          const td = document.createElement("td");
	          td.colSpan = groupCols - 1;
	          td.textContent = label;
	          if (opts.indent) td.className = "indent";
	          tr.appendChild(td);
	          body.appendChild(tr);
	        };

	        for (const providerId of providerIds) {
	          const byAlias = byProvider.get(providerId);
	          let modelsCount = 0;
	          for (const v of byAlias.values()) modelsCount += v.length;
            const providerKeys = Array.from(byAlias.values()).flatMap((items) => items.map((it) => it.pk));
	          appendGroupRow(`${providerId} (${modelsCount})`, { keys: providerKeys, groupId: `provider:${providerId}` });

	          const aliases = Array.from(byAlias.keys()).sort((a, b) => a.localeCompare(b));
	          for (const alias of aliases) {
	            const items = byAlias.get(alias);
            const fpSuffix = (() => {
              if (providerId !== "antigravity") return "";
              if (!items || !items.length) return "";
              const q0 = items[0] && items[0].q ? items[0].q : null;
              const suffix = textOf(q0 && (q0.fpSuffix || q0.fingerprintSuffix) ? (q0.fpSuffix || q0.fingerprintSuffix) : "");
              return suffix;
	            })();
	            const fpTag = fpSuffix ? ` · fp=${fpSuffix}` : "";
              const aliasKeys = Array.isArray(items) ? items.map((it) => it.pk) : [];
	            appendGroupRow(`${alias || "(no-key)"} (${items.length})${fpTag}`, {
                indent: true,
                keys: aliasKeys,
                groupId: `alias:${providerId}.${alias || "(no-key)"}`
              });

	            for (const item of items) {
	              const q = item.q;
	              const tr = document.createElement("tr");
	              tr.className = "provider-row";
	              tr.setAttribute("data-provider-key", item.pk);

                const selTd = document.createElement("td");
                selTd.className = "check-cell";
                const cb = document.createElement("input");
                cb.type = "checkbox";
                cb.setAttribute("data-select-key", item.pk);
                cb.checked = UI.quotaSelection instanceof Set ? UI.quotaSelection.has(item.pk) : false;
                cb.addEventListener("change", () => {
                  setQuotaSelection([item.pk], cb.checked);
                });
                selTd.appendChild(cb);
                tr.appendChild(selTd);
	              tr.appendChild(createCell("td", "", "mono"));
	              tr.appendChild(createCell("td", item.model || item.pk, "mono indent", { title: true }));
                UI.quotaRenderedVisibleKeys.push(item.pk);

	              const inPool = Boolean(q.inPool);
	              const inTd = document.createElement("td");
	              inTd.appendChild(pill(inPool ? "true" : "false", inPool ? "ok" : "bad"));
              tr.appendChild(inTd);

              const reason = textOf(q.reason || "");
              const reasonKind =
                reason === "ok" ? "ok" :
                reason === "authVerify" ? "bad" :
                reason === "cooldown" ? "warn" :
                reason === "blacklist" || reason === "fatal" || reason === "quotaDepleted" ? "bad" : "warn";
              const reasonTd = document.createElement("td");
              reasonTd.appendChild(pill(reason || "—", reasonKind));
              const issue = q && q.authIssue && typeof q.authIssue === "object" ? q.authIssue : null;
              if (issue && issue.kind === "google_account_verification") {
                const url = textOf(issue.url || "");
                if (url) {
                  reasonTd.appendChild(document.createTextNode(" "));
                  const a = document.createElement("a");
                  a.href = url;
                  a.target = "_blank";
                  a.rel = "noreferrer";
                  a.textContent = "verify";
                  a.className = "mono";
                  reasonTd.appendChild(a);
                }
              }
              tr.appendChild(reasonTd);

              const cooldown = formatEpochWithDelta(q.cooldownUntil);
              const blacklist = formatEpochWithDelta(q.blacklistUntil);
              const until = `cooldown=${cooldown || "—"} blacklist=${blacklist || "—"}`;
              tr.appendChild(createCell("td", until, "mono", { title: true }));

              tr.appendChild(createCell("td", q.consecutiveErrorCount ?? 0, "mono"));

              const actionsTd = document.createElement("td");
              actionsTd.className = "actions-cell";
              const box = document.createElement("div");
              box.className = "actions";
              const recover = document.createElement("button");
              recover.textContent = "Recover";
              recover.setAttribute("data-action", "quota-recover");
              recover.setAttribute("data-key", item.pk);
              const reset = document.createElement("button");
              reset.textContent = "Reset";
              reset.setAttribute("data-action", "quota-reset");
              reset.setAttribute("data-key", item.pk);
              const disable = document.createElement("button");
              disable.textContent = "Offline…";
              disable.className = "danger";
              disable.setAttribute("data-action", "quota-disable");
              disable.setAttribute("data-key", item.pk);
              box.appendChild(recover);
              box.appendChild(reset);
              box.appendChild(disable);
              actionsTd.appendChild(box);
              tr.appendChild(actionsTd);

	              body.appendChild(tr);
	            }
	          }
	        }
          updateQuotaSelectionSummary();
	      }

      function formatRemainingFraction(v) {
        if (typeof v !== "number" || !Number.isFinite(v)) return "—";
        const pct = Math.max(0, Math.min(1, v)) * 100;
        return `${pct.toFixed(1)}%`;
      }

      async function refreshQuotaSnapshot() {
        const body = $("quotaSnapshotTbody");
        body.replaceChildren();
        setLog("quotaSnapshotLog", "");
        try {
          // Ensure routing + provider pool snapshots exist so we can filter routed models.
          await refreshRoutingTargets();
          if (!Array.isArray(UI.quotaProviders) || UI.quotaProviders.length === 0) {
            try {
              const outProviders = await apiFetch("/quota/providers");
              UI.quotaProviders = Array.isArray(outProviders.providers) ? outProviders.providers : [];
              UI.quotaProvidersUpdatedAt = Date.now();
            } catch {
              // ignore: snapshot view can still render unfiltered
            }
          }
          const out = await apiFetch("/quota/summary");
          let list = Array.isArray(out.records) ? out.records : [];

          const onlyRouted = Boolean($("quotaSnapshotOnlyRoutedToggle").checked);
          if (onlyRouted) {
            const routedProviderKeys = resolveRoutedProviderKeys(UI.routingTargets, UI.quotaProviders);
            const allowedSnapshotKeys = new Set();
            for (const providerKey of routedProviderKeys) {
              if (!providerKey.toLowerCase().startsWith("antigravity.")) continue;
              const parts = providerKey.split(".");
              if (parts.length < 3) continue;
              const alias = parts[1];
              const modelId = parts.slice(2).join(".");
              if (!alias || !modelId) continue;
              allowedSnapshotKeys.add(`antigravity://${alias}/${modelId}`);
            }
            list = list.filter((r) => allowedSnapshotKeys.has(textOf(r && r.key ? r.key : "")));
          }

          list.sort((a, b) => String(a.key || "").localeCompare(String(b.key || "")));
          for (const r of list) {
            const raw = textOf(r && r.key ? r.key : "");
            const prefix = "antigravity://";
            const rest = raw.startsWith(prefix) ? raw.slice(prefix.length) : raw;
            const parts = rest.split("/");
            const alias = parts.length >= 2 ? parts[0] : "";
            const model = parts.length >= 2 ? parts.slice(1).join("/") : rest;
            const tr = document.createElement("tr");
            tr.appendChild(createCell("td", alias || "—", "mono", { title: true }));
            tr.appendChild(createCell("td", model || "—", "mono", { title: true }));
            tr.appendChild(createCell("td", formatRemainingFraction(r.remainingFraction), "mono"));
            tr.appendChild(createCell("td", formatEpochWithDelta(r.resetAt), "mono", { title: true }));
            tr.appendChild(createCell("td", formatEpochMs(r.fetchedAt), "mono", { title: true }));
            body.appendChild(tr);
          }
          if (!list.length) {
            body.appendChild(createErrorRow(5, "No quota records to show (check filter or click Refresh antigravity snapshot)."));
          }
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("quota snapshot");
          body.appendChild(createErrorRow(5, e && e.message ? e.message : e));
        }
      }

      async function refreshQuotaSnapshotNow() {
        setLog("quotaSnapshotLog", "");
        try {
          const out = await apiFetch("/quota/refresh", { method: "POST" });
          const result = out && out.result ? out.result : null;
          setLog(
            "quotaSnapshotLog",
            `OK. refreshedAt=${result && result.refreshedAt ? formatEpochMs(result.refreshedAt) : "—"} tokenCount=${result && typeof result.tokenCount === "number" ? result.tokenCount : "—"} records=${result && typeof result.recordCount === "number" ? result.recordCount : "—"}`
          );
          await refreshQuotaSnapshot();
          toast("Quota snapshot refreshed.", "ok");
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("quota refresh");
          setLog("quotaSnapshotLog", `Refresh failed: ${e && e.message ? e.message : e}`);
          toast(`Refresh failed: ${e && e.message ? e.message : String(e)}`);
        }
      }

      function formatInt(n) {
        const v = typeof n === "number" && Number.isFinite(n) ? n : 0;
        try { return v.toLocaleString(); } catch { return String(v); }
      }

      function formatTokensRow(label, totals) {
        const inTok = formatInt(totals.totalPromptTokens);
        const outTok = formatInt(totals.totalCompletionTokens);
        const totTok = formatInt(totals.totalOutputTokens);
        const req = formatInt(totals.requestCount);
        const err = formatInt(totals.errorCount);
        return `${label}: requests=${req} (err=${err}) tokens in/out/total=${inTok}/${outTok}/${totTok}`;
      }

      function summarizeStatsRows(rows) {
        const byProvider = new Map();
        const byRuntime = new Map();
        const byModel = new Map();
        let totalReq = 0;
        let totalErr = 0;
        for (const r of rows) {
          if (!r || !r.providerKey) continue;
          const providerKey = textOf(r.providerKey);
          const providerId = (providerKey.split(".")[0] || providerKey).trim() || providerKey;
          const runtime = (() => {
            const parts = providerKey.split(".").filter(Boolean);
            if (parts.length >= 2) return `${parts[0]}.${parts[1]}`;
            return providerKey;
          })();
          const model = textOf(r.model || "");
          const req = typeof r.requestCount === "number" ? r.requestCount : 0;
          const err = typeof r.errorCount === "number" ? r.errorCount : 0;
          totalReq += req;
          totalErr += err;
          const p = byProvider.get(providerId) || { providerId, requestCount: 0, errorCount: 0 };
          p.requestCount += req;
          p.errorCount += err;
          byProvider.set(providerId, p);
          const rt = byRuntime.get(runtime) || { runtime, requestCount: 0, errorCount: 0 };
          rt.requestCount += req;
          rt.errorCount += err;
          byRuntime.set(runtime, rt);
          const mKey = model || "—";
          const m = byModel.get(mKey) || { model: mKey, requestCount: 0, errorCount: 0 };
          m.requestCount += req;
          m.errorCount += err;
          byModel.set(mKey, m);
        }
        return {
          totalReq,
          totalErr,
          byProvider: Array.from(byProvider.values()).sort((a, b) => b.requestCount - a.requestCount),
          byRuntime: Array.from(byRuntime.values()).sort((a, b) => b.requestCount - a.requestCount),
          byModel: Array.from(byModel.values()).sort((a, b) => b.requestCount - a.requestCount)
        };
      }

      function renderStatsTable(bodyEl, rows, colCount, emptyMsg) {
        bodyEl.replaceChildren();
        if (!rows.length) {
          bodyEl.appendChild(createInfoRow(colCount, emptyMsg));
          return;
        }
        for (const r of rows) {
          const tr = document.createElement("tr");
          for (const cell of r) {
            tr.appendChild(createCell("td", cell, "mono truncate", { title: true }));
          }
          bodyEl.appendChild(tr);
        }
      }

      async function refreshStats() {
        $("statsSessionTotalsBox").textContent = "";
        $("statsHistoricalTotalsBox").textContent = "";
        const sessionProvidersBody = $("statsSessionProvidersTbody");
        const sessionRuntimesBody = $("statsSessionRuntimesTbody");
        const sessionModelsBody = $("statsSessionModelsTbody");
        const sessionErrorsBody = $("statsSessionErrorsTbody");
        const histProvidersBody = $("statsHistoricalProvidersTbody");
        const histRuntimesBody = $("statsHistoricalRuntimesTbody");
        const histModelsBody = $("statsHistoricalModelsTbody");
        const histErrorsBody = $("statsHistoricalErrorsTbody");
        sessionProvidersBody.replaceChildren();
        sessionRuntimesBody.replaceChildren();
        sessionModelsBody.replaceChildren();
        sessionErrorsBody.replaceChildren();
        histProvidersBody.replaceChildren();
        histRuntimesBody.replaceChildren();
        histModelsBody.replaceChildren();
        histErrorsBody.replaceChildren();

        try {
          const out = await apiFetch("/daemon/stats");
          const session = out && out.session ? out.session : null;
          const historical = out && out.historical ? out.historical : null;
          const sessionRows = session && Array.isArray(session.totals) ? session.totals : [];
          const histRows = historical && Array.isArray(historical.totals) ? historical.totals : [];

          const s = summarizeStatsRows(sessionRows);
          const h = summarizeStatsRows(histRows);

          $("statsSessionTotalsBox").textContent = `ALL (session): requests=${formatInt(s.totalReq)} (err=${formatInt(s.totalErr)})`;
          $("statsHistoricalTotalsBox").textContent = `ALL (historical): requests=${formatInt(h.totalReq)} (err=${formatInt(h.totalErr)})`;

          renderStatsTable(
            sessionProvidersBody,
            s.byProvider.map((p) => [p.providerId, formatInt(p.requestCount), formatInt(p.errorCount)]),
            3,
            "No provider stats recorded in this session."
          );
          renderStatsTable(
            sessionRuntimesBody,
            s.byRuntime.map((r) => [r.runtime, formatInt(r.requestCount), formatInt(r.errorCount)]),
            3,
            "No runtime stats recorded in this session."
          );
          renderStatsTable(
            sessionModelsBody,
            s.byModel.map((m) => [m.model, formatInt(m.requestCount), formatInt(m.errorCount)]),
            3,
            "No model stats recorded in this session."
          );

          renderStatsTable(
            histProvidersBody,
            h.byProvider.map((p) => [p.providerId, formatInt(p.requestCount), formatInt(p.errorCount)]),
            3,
            "No historical stats recorded."
          );
          renderStatsTable(
            histRuntimesBody,
            h.byRuntime.map((r) => [r.runtime, formatInt(r.requestCount), formatInt(r.errorCount)]),
            3,
            "No historical stats recorded."
          );
          renderStatsTable(
            histModelsBody,
            h.byModel.map((m) => [m.model, formatInt(m.requestCount), formatInt(m.errorCount)]),
            3,
            "No historical stats recorded."
          );

          const toProviderKeys = (rows) =>
            rows
              .filter((r) => r && r.providerKey)
              .map((r) => ({
                providerKey: textOf(r.providerKey),
                model: textOf(r.model || "—") || "—",
                req: typeof r.requestCount === "number" ? r.requestCount : 0,
                err: typeof r.errorCount === "number" ? r.errorCount : 0
              }))
              .sort((a, b) => b.req - a.req || b.err - a.err || a.providerKey.localeCompare(b.providerKey))
              .slice(0, 50)
              .map((x) => [x.providerKey, x.model, formatInt(x.req), formatInt(x.err)]);

          renderStatsTable(sessionErrorsBody, toProviderKeys(sessionRows), 4, "No provider stats recorded in this session.");
          renderStatsTable(histErrorsBody, toProviderKeys(histRows), 4, "No historical provider stats recorded.");

          $("statsLastUpdated").textContent = `updated ${formatEpochMs(Date.now())}`;
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("stats");
          const msg = e && e.message ? e.message : e;
          renderStatsTable(sessionProvidersBody, [], 3, textOf(msg));
          renderStatsTable(sessionRuntimesBody, [], 3, textOf(msg));
          renderStatsTable(sessionModelsBody, [], 3, textOf(msg));
          renderStatsTable(sessionErrorsBody, [], 4, textOf(msg));
          renderStatsTable(histProvidersBody, [], 3, textOf(msg));
          renderStatsTable(histRuntimesBody, [], 3, textOf(msg));
          renderStatsTable(histModelsBody, [], 3, textOf(msg));
          renderStatsTable(histErrorsBody, [], 4, textOf(msg));
        }
      }

      async function refreshTokens() {
        const body = $("tokensTbody");
        body.replaceChildren();
        $("tokenTotalsBox").textContent = "";
        try {
          const out = await apiFetch("/daemon/stats");
          const session = out && out.session ? out.session : null;
          const historical = out && out.historical ? out.historical : null;
          const totals = out && out.totals ? out.totals : null;

          const sessionTotals = totals && totals.session ? totals.session : { requestCount: 0, errorCount: 0, totalPromptTokens: 0, totalCompletionTokens: 0, totalOutputTokens: 0 };
          const historicalTotals = totals && totals.historical ? totals.historical : { requestCount: 0, errorCount: 0, totalPromptTokens: 0, totalCompletionTokens: 0, totalOutputTokens: 0 };

          const lines = [];
          lines.push(formatTokensRow("ALL (session)", sessionTotals));
          lines.push(formatTokensRow("ALL (historical)", historicalTotals));
          $("tokenTotalsBox").textContent = lines.join("\n");

          const sessionRows = session && Array.isArray(session.totals) ? session.totals : [];
          const histRows = historical && Array.isArray(historical.totals) ? historical.totals : [];

          const byKey = new Map();
          const keyOf = (r) => `${textOf(r.providerKey)}|${textOf(r.model || "")}`;
          for (const r of sessionRows) {
            if (!r || !r.providerKey) continue;
            byKey.set(keyOf(r), { providerKey: textOf(r.providerKey), model: textOf(r.model || ""), session: r, historical: null });
          }
          for (const r of histRows) {
            if (!r || !r.providerKey) continue;
            const k = keyOf(r);
            const existing = byKey.get(k) || { providerKey: textOf(r.providerKey), model: textOf(r.model || ""), session: null, historical: null };
            existing.historical = r;
            byKey.set(k, existing);
          }

          const rows = Array.from(byKey.values()).sort((a, b) => {
            const ak = `${a.providerKey}.${a.model}`;
            const bk = `${b.providerKey}.${b.model}`;
            return ak.localeCompare(bk);
          });

          for (const row of rows) {
            const tr = document.createElement("tr");
            tr.appendChild(createCell("td", row.providerKey, "mono truncate", { title: true }));
            tr.appendChild(createCell("td", row.model || "—", "mono truncate", { title: true }));

            const s = row.session;
            const sReqErr = s ? `${formatInt(s.requestCount)} / ${formatInt(s.errorCount)}` : "—";
            const sTok = s ? `${formatInt(s.totalPromptTokens)}/${formatInt(s.totalCompletionTokens)}/${formatInt(s.totalOutputTokens)}` : "—";
            tr.appendChild(createCell("td", sReqErr, "mono"));
            tr.appendChild(createCell("td", sTok, "mono"));

            const h = row.historical;
            const hReqErr = h ? `${formatInt(h.requestCount)} / ${formatInt(h.errorCount)}` : "—";
            const hTok = h ? `${formatInt(h.totalPromptTokens)}/${formatInt(h.totalCompletionTokens)}/${formatInt(h.totalOutputTokens)}` : "—";
            tr.appendChild(createCell("td", hReqErr, "mono"));
            tr.appendChild(createCell("td", hTok, "mono"));

            body.appendChild(tr);
          }
        } catch (e) {
          body.appendChild(createErrorRow(7, e && e.message ? e.message : e));
        }
      }

      async function testProviderFromPool(providerId) {
        setLog("providerOpLog", "");
        try {
          const detail = await apiFetch(`/config/providers/${encodeURIComponent(providerId)}`);
          const provider = detail && detail.provider ? detail.provider : null;
          const models = provider && provider.models && typeof provider.models === "object" ? Object.keys(provider.models) : [];
          if (!models.length) {
            throw new Error("No models configured for this provider");
          }
          const modelId = models[0];
          const directModel = `${providerId}.${modelId}`;
          const payload = { model: directModel, input: [{ role: "user", content: "ping" }], stream: false };
          const headers = new Headers({ "content-type": "application/json" });
          const apiKey = getApiKey();
          if (apiKey) headers.set("x-api-key", apiKey);
          const started = Date.now();
          const resp = await fetch("/v1/responses", { method: "POST", headers, body: JSON.stringify(payload) });
          const text = await resp.text();
          const ms = Date.now() - started;
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status} (${ms}ms): ${text}`);
          }
          let json = null;
          try { json = text ? JSON.parse(text) : null; } catch { json = null; }
          const summary =
            json && typeof json.output_text === "string"
              ? json.output_text.slice(0, 200)
              : json && Array.isArray(json.output)
                ? "(output items=" + json.output.length + ")"
                : "(ok)";
          setLog("providerOpLog", `Test OK (${ms}ms) model=${directModel}\n${summary}`);
        } catch (e) {
          setLog("providerOpLog", `Test failed: ${e && e.message ? e.message : e}`);
        }
      }

	      async function quotaAction(kind, providerKeys) {
	        setLog("quotaOpLog", "");
          const keys = normalizeProviderKeyList(providerKeys);
	        if (!keys.length) {
	          setLog("quotaOpLog", "providerKey required (or select rows)");
	          toast("providerKey required (or select rows)");
	          return;
	        }
	        try {
            const many = keys.length > 1;
            if (many) {
              const ok = confirm(`${kind} on ${keys.length} providerKeys?`);
              if (!ok) return;
            }
	          if (kind === "recover") {
              for (const key of keys) {
	              await apiFetch(`/quota/providers/${encodeURIComponent(key)}/recover`, { method: "POST" });
              }
	            scheduleQuotaRefresh();
	            toast(many ? `Recovered (${keys.length}).` : "Recovered.", "ok");
	            return;
	          }
	          if (kind === "reset") {
              for (const key of keys) {
	              await apiFetch(`/quota/providers/${encodeURIComponent(key)}/reset`, { method: "POST" });
              }
	            scheduleQuotaRefresh();
	            toast(many ? `Reset (${keys.length}).` : "Reset.", "ok");
	            return;
	          }
	          if (kind === "disable") {
	            const minutes = Number.parseFloat(textOf($("quotaDurationSelect").value || "60"));
	            if (!Number.isFinite(minutes) || minutes <= 0) {
	              throw new Error("Invalid minutes");
	            }
	            const modeRaw = (textOf($("quotaModeSelect").value) || "cooldown").trim().toLowerCase();
	            const mode = modeRaw === "blacklist" ? "blacklist" : "cooldown";
              for (const key of keys) {
	              await apiFetch(`/quota/providers/${encodeURIComponent(key)}/disable`, {
	                method: "POST",
	                body: JSON.stringify({ mode, durationMinutes: minutes })
	              });
              }
	            scheduleQuotaRefresh();
	            toast(many ? `Applied (${keys.length}).` : "Applied.", "ok");
	            return;
	          }
	        } catch (e) {
	          if (e && e.status === 401) notifyUnauthorizedOnce("quota action");
	          setLog("quotaOpLog", `Action failed: ${e && e.message ? e.message : e}`);
	          toast(`Action failed: ${e && e.message ? e.message : String(e)}`);
	        }
	      }

      async function resetQuotaModule() {
        setLog("quotaOpLog", "");
        if (!confirm("Reset provider-quota module now? This clears cooldown/blacklist state.")) return;
        try {
          const out = await apiFetch("/daemon/modules/provider-quota/reset", { method: "POST" });
          setLog("quotaOpLog", `OK. resetAt=${out.resetAt || "—"}`);
          await refreshQuota();
          toast("Quota module reset.", "ok");
        } catch (e) {
          if (e && e.status === 401) notifyUnauthorizedOnce("quota reset");
          setLog("quotaOpLog", `Reset failed: ${e.message}`);
          toast(`Reset failed: ${e.message}`);
        }
      }

      // Bind events
      document.querySelectorAll(".tab[data-tab]").forEach((btn) => {
        btn.addEventListener("click", () => selectTab(btn.getAttribute("data-tab")));
      });

      async function refreshAdminAuthStatus() {
        try {
          const status = await apiFetch("/daemon/auth/status", { method: "GET" });
          if (status && status.ok) {
            const hasPassword = Boolean(status.hasPassword);
            const authed = Boolean(status.authenticated);
            UI.adminAuth = { hasPassword, authenticated: authed };
            $("adminAuthHint").textContent = authed ? "authenticated" : hasPassword ? "login required" : "setup required (localhost only)";
            $("setupPasswordBtn").style.display = hasPassword ? "none" : "inline-block";
            $("loginPasswordBtn").style.display = hasPassword ? "inline-block" : "none";
            $("changePasswordDetails").style.display = hasPassword && authed ? "block" : "none";
            return { hasPassword, authenticated: authed };
          }
        } catch (e) {
          const msg = e && e.message ? e.message : String(e);
          $("adminAuthHint").textContent = msg;
          toast(`Admin auth status failed: ${msg}`);
        }
        UI.adminAuth = { hasPassword: false, authenticated: false };
        $("changePasswordDetails").style.display = "none";
        return { hasPassword: false, authenticated: false };
      }

      $("adminPasswordInput").addEventListener("keydown", async (ev) => {
        if (ev.key !== "Enter") return;
        ev.preventDefault();
        const status = UI.adminAuth ? UI.adminAuth : await refreshAdminAuthStatus();
        if (status.hasPassword) $("loginPasswordBtn").click();
        else $("setupPasswordBtn").click();
      });

      $("setupPasswordBtn").addEventListener("click", async () => {
        const pw = ($("adminPasswordInput").value || "");
        try {
          $("adminAuthHint").textContent = "setting password…";
          await apiFetch("/daemon/auth/setup", { method: "POST", body: JSON.stringify({ password: pw }) });
          $("adminPasswordInput").value = "";
          $("oldAdminPasswordInput").value = "";
          $("newAdminPasswordInput").value = "";
          toast("Password set. You're now logged in.", "ok");
          await refreshAdminAuthStatus();
          await refreshStatus();
          await refreshProviders();
          await refreshCredentials();
          await refreshQuota();
          await refreshQuotaSnapshot();
          await refreshRuntimes();
          await refreshRoutingSources();
          await loadRouting();
        } catch (e) {
          const msg = e && e.message ? e.message : String(e);
          $("adminAuthHint").textContent = msg;
          toast(`Set password failed: ${msg}`);
        }
      });

      $("loginPasswordBtn").addEventListener("click", async () => {
        const pw = ($("adminPasswordInput").value || "");
        try {
          $("adminAuthHint").textContent = "logging in…";
          await apiFetch("/daemon/auth/login", { method: "POST", body: JSON.stringify({ password: pw }) });
          $("adminPasswordInput").value = "";
          $("oldAdminPasswordInput").value = "";
          $("newAdminPasswordInput").value = "";
          toast("Logged in.", "ok");
          await refreshAdminAuthStatus();
          await refreshStatus();
          await refreshProviders();
          await refreshCredentials();
          await refreshQuota();
          await refreshRuntimes();
          await refreshRoutingSources();
          await loadRouting();
        } catch (e) {
          const msg = e && e.message ? e.message : String(e);
          $("adminAuthHint").textContent = msg;
          toast(`Login failed: ${msg}`);
        }
      });

      $("logoutPasswordBtn").addEventListener("click", async () => {
        try {
          $("adminAuthHint").textContent = "logging out…";
          await apiFetch("/daemon/auth/logout", { method: "POST" });
          toast("Logged out.", "ok");
          await refreshAdminAuthStatus();
        } catch (e) {
          const msg = e && e.message ? e.message : String(e);
          $("adminAuthHint").textContent = msg;
          toast(`Logout failed: ${msg}`);
        }
      });

      $("changePasswordBtn").addEventListener("click", async () => {
        const oldPassword = ($("oldAdminPasswordInput").value || "");
        const newPassword = ($("newAdminPasswordInput").value || "");
        try {
          $("adminAuthHint").textContent = "changing password…";
          await apiFetch("/daemon/auth/change", {
            method: "POST",
            body: JSON.stringify({ oldPassword, newPassword })
          });
          $("oldAdminPasswordInput").value = "";
          $("newAdminPasswordInput").value = "";
          toast("Password changed.", "ok");
          await refreshAdminAuthStatus();
        } catch (e) {
          const msg = e && e.message ? e.message : String(e);
          $("adminAuthHint").textContent = msg;
          toast(`Change password failed: ${msg}`);
        }
      });

      $("saveApiKeyBtn").addEventListener("click", () => {
        const value = ($("apiKeyInput").value || "").trim();
        setApiKey(value);
        $("apiKeyHint").textContent = value ? "saved (session only)" : "";
        Promise.resolve()
          .then(refreshStatus)
          .then(() => selectTab(getActiveTab()))
          .catch(() => {});
      });
      $("clearApiKeyBtn").addEventListener("click", () => {
        setApiKey("");
        $("apiKeyInput").value = "";
        $("apiKeyHint").textContent = "";
        Promise.resolve()
          .then(refreshStatus)
          .then(() => selectTab(getActiveTab()))
          .catch(() => {});
      });

      $("refreshClockBtn").addEventListener("click", refreshClockTab);
      $("clockSessionFilterInput").addEventListener("keydown", (ev) => {
        if (ev && ev.key === "Enter") {
          ev.preventDefault();
          void refreshClockTab();
        }
      });

      $("restartRuntimeBtn").addEventListener("click", async () => {
        setLog("providerOpLog", "");
        if (!confirm("Reload config from disk and rebuild runtime now?")) return;
        try {
          const out = await apiFetch("/daemon/restart", { method: "POST" });
          const warnings = Array.isArray(out.warnings) && out.warnings.length ? `\nWarnings:\n- ${out.warnings.join("\n- ")}` : "";
          setLog("providerOpLog", `Restarted.\nconfigPath: ${out.configPath || "—"}\nreloadedAt: ${out.reloadedAt || "—"}${warnings}`);
	          await refreshStatus();
	          await refreshProviders();
	          await refreshCredentials();
	          await refreshQuota();
	          await refreshQuotaSnapshot();
	          await refreshRuntimes();
	        } catch (e) {
	          setLog("providerOpLog", `Restart failed: ${e.message}`);
	        }
      });

      $("controlRefreshBtn").addEventListener("click", refreshControl);
      $("controlRestartAllBtn").addEventListener("click", async () => {
        setLog("controlOpLog", "");
        if (!confirm("Broadcast restart all local RouteCodex servers now?")) return;
        try {
          const out = await controlMutate("servers.restart", {});
          setLog("controlOpLog", `Restart requested.\n${JSON.stringify(out, null, 2)}`);
          await refreshControl();
          await refreshStatus();
        } catch (e) {
          setLog("controlOpLog", `Restart failed: ${e.message || e}`);
        }
      });
      $("controlQuotaRefreshBtn").addEventListener("click", async () => {
        setLog("controlOpLog", "");
        try {
          const out = await controlMutate("quota.refresh", {});
          setLog("controlOpLog", `Quota refresh requested.\n${JSON.stringify(out, null, 2)}`);
          await refreshControl();
        } catch (e) {
          setLog("controlOpLog", `Quota refresh failed: ${e.message || e}`);
        }
      });
      $("controlServerToolToggleBtn").addEventListener("click", async () => {
        setLog("controlOpLog", "");
        try {
          const snap = UI.controlSnapshot && typeof UI.controlSnapshot === "object" ? UI.controlSnapshot : null;
          const state = snap && snap.serverTool && typeof snap.serverTool === "object" && snap.serverTool.state
            ? snap.serverTool.state
            : null;
          const enabled = state && state.enabled === true;
          const nextEnabled = !enabled;
          const out = await controlMutate("servertool.set_enabled", { enabled: nextEnabled });
          setLog("controlOpLog", `ServerTool ${nextEnabled ? "enabled" : "disabled"}.\n${JSON.stringify(out, null, 2)}`);
          await refreshControl();
        } catch (e) {
          setLog("controlOpLog", `ServerTool toggle failed: ${e.message || e}`);
        }
      });
      $("controlQuotaOfflineBtn").addEventListener("click", async () => {
        setLog("controlOpLog", "");
        const providerKey = ($("controlQuotaKeyInput").value || "").trim();
        if (!providerKey) return toast("providerKey required");
        const mode = $("controlQuotaModeSelect").value === "blacklist" ? "blacklist" : "cooldown";
        const minutes = Number($("controlQuotaDurationSelect").value || 0);
        const durationMs = Number.isFinite(minutes) && minutes > 0 ? minutes * 60 * 1000 : 0;
        if (!durationMs) return toast("duration required");
        try {
          const out = await controlMutate("quota.disable", { providerKey, mode, durationMs });
          setLog("controlOpLog", `Offline requested.\n${JSON.stringify(out, null, 2)}`);
          await refreshControl();
        } catch (e) {
          setLog("controlOpLog", `Offline failed: ${e.message || e}`);
        }
      });
      $("controlQuotaRecoverBtn").addEventListener("click", async () => {
        setLog("controlOpLog", "");
        const providerKey = ($("controlQuotaKeyInput").value || "").trim();
        if (!providerKey) return toast("providerKey required");
        try {
          const out = await controlMutate("quota.recover", { providerKey });
          setLog("controlOpLog", `Recover requested.\n${JSON.stringify(out, null, 2)}`);
          await refreshControl();
        } catch (e) {
          setLog("controlOpLog", `Recover failed: ${e.message || e}`);
        }
      });
      $("controlQuotaResetBtn").addEventListener("click", async () => {
        setLog("controlOpLog", "");
        const providerKey = ($("controlQuotaKeyInput").value || "").trim();
        if (!providerKey) return toast("providerKey required");
        try {
          const out = await controlMutate("quota.reset", { providerKey });
          setLog("controlOpLog", `Reset requested.\n${JSON.stringify(out, null, 2)}`);
          await refreshControl();
        } catch (e) {
          setLog("controlOpLog", `Reset failed: ${e.message || e}`);
        }
      });

      $("refreshProvidersBtn").addEventListener("click", refreshProviders);
      $("refreshStatsBtn").addEventListener("click", refreshStats);
      $("statsAutoRefresh").addEventListener("change", syncStatsAutoRefresh);
      $("refreshTokensBtn").addEventListener("click", refreshTokens);
      $("newProviderBtn").addEventListener("click", () => {
        $("providerEditorTitle").textContent = "Provider editor (new)";
        $("providerIdInput").value = "";
        setSelectedProviderId("");
        providerEditorSetValue(presetFor($("providerPreset").value));
        setLog("providerOpLog", "");
      });
      $("providersTbody").addEventListener("click", async (ev) => {
        const btn = ev.target.closest("button");
        if (btn) {
          const id = btn.getAttribute("data-id");
          const action = btn.getAttribute("data-action");
          if (action === "test" && id) {
            setSelectedProviderId(id);
            await testProviderFromPool(id);
            return;
          }
          if (action === "edit" && id) {
            await loadProvider(id);
            return;
          }
          if (action === "delete" && id) {
            await deleteProvider(id);
            return;
          }
          return;
        }

        const row = ev.target.closest("tr.provider-row");
        if (!row) return;
        const id = row.getAttribute("data-provider-id");
        if (!id) return;
        await loadProvider(id);
      });
      $("loadProviderBtn").addEventListener("click", async () => {
        const id = ($("providerIdInput").value || "").trim();
        if (id) await loadProvider(id);
      });
      $("applyPresetBtn").addEventListener("click", applyPresetToEditor);
      $("saveProviderBtn").addEventListener("click", saveProvider);
      $("deleteProviderBtn").addEventListener("click", async () => {
        const id = ($("providerIdInput").value || "").trim();
        await deleteProvider(id);
      });
      $("createApiKeyCredentialBtn").addEventListener("click", async () => {
        const secretRef = await createApiKeyCredential();
        if (secretRef) {
          providerEditorSetAuthApiKey(secretRef);
          toast("Authfile created and applied to provider editor.", "ok");
        }
      });

      $("providerEditorExpandBtn").addEventListener("click", () => setAllDetailsOpen($("providerKvEditor"), true, true));
      $("providerEditorCollapseBtn").addEventListener("click", () => setAllDetailsOpen($("providerKvEditor"), false, true));

      $("authMode").addEventListener("change", updateAuthModeUi);
      updateAuthModeUi();

      $("refreshCredentialsBtn").addEventListener("click", refreshCredentials);
      $("saveOauthBrowserBtn").addEventListener("click", saveSettings);
      $("oauthModeManualBtn").addEventListener("click", () => {
        setOauthMode("manual");
        appendLog("credentialOpLog", "[ui] switched to manual mode");
      });
      $("oauthModeAutoBtn").addEventListener("click", () => {
        setOauthMode("auto");
        appendLog("credentialOpLog", "[ui] switched to auto mode");
      });
      $("oauthAuthorizeManualBtn").addEventListener("click", () => {
        appendLog("credentialOpLog", "[ui] click Start Manual Auth");
        void authorizeOauth("manual");
      });
      $("oauthAuthorizeAutoBtn").addEventListener("click", () => {
        appendLog("credentialOpLog", "[ui] click Run Auto Auth");
        void authorizeOauth("auto");
      });
      $("oauthVerifyOpenBtn").addEventListener("click", () => void openSelectedVerifyUrl());
      $("oauthVerifyCopyBtn").addEventListener("click", () => void copySelectedVerifyUrl());
      $("oauthVerifyRecheckBtn").addEventListener("click", async () => {
        try {
          await refreshQuota();
          await refreshCredentials();
          setLog("credentialOpLog", "Rechecked quota/credential state.");
        } catch (e) {
          setLog("credentialOpLog", `Recheck failed: ${e && e.message ? e.message : String(e)}`);
        }
      });
      $("oauthProviderSelect").addEventListener("change", updateOauthAuthIssueHint);
      $("oauthAuthAliasInput").addEventListener("input", updateOauthAuthIssueHint);
      setOauthMode("manual");

	      $("refreshQuotaBtn").addEventListener("click", refreshQuota);
	      $("refreshQuotaSnapshotBtn").addEventListener("click", refreshQuotaSnapshotNow);
	      $("quotaFilterInput").addEventListener("input", renderQuotaProviders);
	      $("quotaHideOkToggle").addEventListener("change", renderQuotaProviders);
	      $("quotaOnlyRoutedTargetsToggle").addEventListener("change", renderQuotaProviders);
        $("quotaSelectVisibleBtn").addEventListener("click", () => {
          const keys = Array.isArray(UI.quotaRenderedVisibleKeys) ? UI.quotaRenderedVisibleKeys : [];
          setQuotaSelection(keys, true);
        });
        $("quotaClearSelectionBtn").addEventListener("click", clearQuotaSelection);
        $("quotaSelectAllVisibleToggle").addEventListener("change", () => {
          const master = $("quotaSelectAllVisibleToggle");
          const keys = Array.isArray(UI.quotaRenderedVisibleKeys) ? UI.quotaRenderedVisibleKeys : [];
          setQuotaSelection(keys, Boolean(master && master.checked));
        });
	      $("quotaApplyDisableBtn").addEventListener("click", () => void quotaAction("disable", resolveQuotaActionTargets()));
	      $("quotaApplyRecoverBtn").addEventListener("click", () => void quotaAction("recover", resolveQuotaActionTargets()));
	      $("quotaApplyResetBtn").addEventListener("click", () => void quotaAction("reset", resolveQuotaActionTargets()));
	      $("quotaTbody").addEventListener("click", (ev) => {
	        const tr = ev.target.closest("tr");
	        if (tr && tr.getAttribute) {
	          const pk = tr.getAttribute("data-provider-key");
          if (pk) $("quotaKeyInput").value = pk;
        }
        const el = ev.target.closest("button");
        if (!el) return;
	        const action = el.getAttribute("data-action");
	        const key = el.getAttribute("data-key");
	        if (key) $("quotaKeyInput").value = key;
	        if (action === "quota-recover") void quotaAction("recover", [key]);
	        else if (action === "quota-reset") void quotaAction("reset", [key]);
	        else if (action === "quota-disable") void quotaAction("disable", [key]);
	      });
      $("resetQuotaBtn").addEventListener("click", resetQuotaModule);

      $("loadRoutingBtn").addEventListener("click", loadRouting);
      $("saveRoutingBtn").addEventListener("click", saveRouting);
      $("refreshRoutingSourcesBtn").addEventListener("click", refreshRoutingSources);
      $("routingSourceSelect").addEventListener("change", loadRouting);
      $("routingRegExpandBtn").addEventListener("click", () => setAllDetailsOpen($("routingKvEditor"), true));
      $("routingRegCollapseBtn").addEventListener("click", () => setAllDetailsOpen($("routingKvEditor"), false));
      $("refreshRoutingPoolBtn").addEventListener("click", async () => {
        try {
          await refreshRuntimes();
          toast("Pool status refreshed.", "ok");
        } catch (e) {
          toast(`Refresh failed: ${e && e.message ? e.message : String(e)}`);
        }
      });
      $("routingShowPathsToggle").addEventListener("change", () => {
        try {
          document.body.classList.toggle("show-routing-paths", Boolean($("routingShowPathsToggle").checked));
        } catch {}
      });

      // Init
      (async () => {
        const auth = await refreshAdminAuthStatus();
        const savedKey = getApiKey();
        if (savedKey) {
          $("apiKeyHint").textContent = "saved (session only)";
          $("apiKeyInput").value = savedKey;
        }
        await refreshStatus();
        await refreshProviders();
        await refreshCredentials();
        await refreshQuota();
        await refreshRuntimes();
        if (auth && auth.authenticated) {
          await refreshRoutingSources();
          await loadRouting();
        }
        await loadSettings();
      })();
    </script>
  </body>
</html>
