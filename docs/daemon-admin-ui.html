<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>RouteCodex Daemon Admin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #070a14;
        --panel: rgba(255, 255, 255, 0.05);
        --panel-2: rgba(255, 255, 255, 0.03);
        --border: rgba(255, 255, 255, 0.08);
        --text: rgba(255, 255, 255, 0.92);
        --muted: rgba(255, 255, 255, 0.62);
        --accent: #4ea1ff;
        --ok: #4cd964;
        --warn: #ffb547;
        --err: #ff5f5f;
        --radius: 12px;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: radial-gradient(circle at 25% 0, #131a36 0, var(--bg) 50%, #03040a 100%);
        color: var(--text);
      }

      .container {
        max-width: 1680px;
        margin: 22px auto 40px;
        padding: 0 16px;
      }

      .card {
        border: 1px solid var(--border);
        background: linear-gradient(180deg, var(--panel), var(--panel-2));
        border-radius: var(--radius);
        padding: 14px;
        box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
      }

      header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 14px;
        flex-wrap: wrap;
        margin-bottom: 14px;
      }

      .title h1 {
        margin: 0;
        font-size: 16px;
        font-weight: 650;
      }

      .title p {
        margin: 3px 0 0;
        font-size: 12px;
        color: var(--muted);
      }

      .statusline {
        display: flex;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }

      .pill {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.03);
        border-radius: 999px;
        padding: 4px 10px;
        font-size: 12px;
        color: var(--muted);
      }

      .dot {
        width: 8px;
        height: 8px;
        border-radius: 999px;
        background: var(--warn);
      }

      .dot.ok {
        background: var(--ok);
      }

      .dot.err {
        background: var(--err);
      }

      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="text"],
      input[type="password"],
      select,
      textarea {
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.25);
        color: var(--text);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
        outline: none;
      }

      textarea {
        width: 100%;
        min-height: 220px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        line-height: 1.45;
      }

      button {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.04);
        color: var(--text);
        border-radius: 10px;
        padding: 8px 10px;
        font-size: 12px;
        cursor: pointer;
      }

      button.primary {
        border-color: rgba(78, 161, 255, 0.55);
        background: rgba(78, 161, 255, 0.14);
      }

      button.danger {
        border-color: rgba(255, 95, 95, 0.55);
        background: rgba(255, 95, 95, 0.14);
      }

      .tabs {
        display: flex;
        gap: 6px;
        margin: 14px 0 10px;
        flex-wrap: wrap;
      }

      .tab {
        padding: 8px 12px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.02);
        color: var(--muted);
      }

      .tab.active {
        color: var(--text);
        border-color: rgba(78, 161, 255, 0.55);
        background: rgba(78, 161, 255, 0.12);
      }

      .grid {
        display: grid;
        grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
        gap: 12px;
      }

      .grid.grid-wide-left {
        grid-template-columns: minmax(0, 1.6fr) minmax(0, 1fr);
      }

      /* Ensure grid children can shrink without overflowing into the next column */
      .grid > .card {
        min-width: 0;
      }

      @media (max-width: 980px) {
        .grid {
          grid-template-columns: minmax(0, 1fr);
        }
      }

      .section-title {
        font-size: 13px;
        font-weight: 650;
        margin: 0 0 6px;
      }

      .section-sub {
        margin: 0 0 10px;
        font-size: 12px;
        color: var(--muted);
      }

      .table {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }

      .table th,
      .table td {
        padding: 8px 10px;
        font-size: 12px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        vertical-align: top;
        overflow-wrap: anywhere;
        word-break: break-word;
      }

      .table th {
        text-align: left;
        color: var(--muted);
        font-weight: 600;
        background: rgba(255, 255, 255, 0.03);
      }

      .table tr.group-row td {
        background: rgba(255, 255, 255, 0.02);
        color: rgba(255, 255, 255, 0.86);
        font-weight: 650;
      }

      .indent {
        padding-left: 22px !important;
      }

      .table-wrap {
        width: 100%;
        max-width: 100%;
        overflow: auto;
        border-radius: 12px;
        border: 1px solid var(--border);
      }

      .table-wrap .table {
        border: 0;
        min-width: 860px;
      }

      .table td.actions-cell {
        width: 220px;
        overflow: visible;
      }

      .actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .truncate {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        color: var(--muted);
        word-break: break-all;
      }

      .notice {
        border: 1px solid rgba(255, 181, 71, 0.35);
        background: rgba(255, 181, 71, 0.08);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        color: rgba(255, 255, 255, 0.82);
      }

      .log {
        white-space: pre-wrap;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
        font-size: 12px;
        line-height: 1.45;
        color: rgba(255, 255, 255, 0.84);
        background: rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 10px 12px;
      }

      @media (max-width: 640px) {
        header {
          flex-direction: column;
          align-items: flex-start;
        }
        .statusline {
          width: 100%;
          justify-content: flex-start;
        }
        .row {
          align-items: stretch;
        }
        .row > input,
        .row > select,
        .row > button {
          max-width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="card">
        <header>
          <div class="title">
            <h1>RouteCodex Daemon Admin</h1>
            <p>
              Writes to <span class="mono">~/.routecodex/config.json</span>. If
              <span class="mono">httpserver.apikey</span> is configured, remote access is allowed
              with the key; otherwise this page is localhost-only.
            </p>
          </div>
          <div class="statusline">
            <div class="pill"><span id="statusDot" class="dot"></span><span id="statusText">connecting…</span></div>
            <div class="pill"><span class="mono" id="serverId">serverId: —</span></div>
            <button id="restartRuntimeBtn" class="primary">Restart runtime</button>
          </div>
        </header>

        <div class="row" style="margin-bottom: 10px;">
          <label for="apiKeyInput">Server API Key (optional)</label>
          <input
            id="apiKeyInput"
            type="password"
            placeholder="x-api-key / Authorization: Bearer …"
            style="flex: 1; min-width: 260px;"
          />
          <button id="saveApiKeyBtn" class="primary">Save</button>
          <button id="clearApiKeyBtn">Clear</button>
          <span class="mono" id="apiKeyHint"></span>
        </div>

        <div class="tabs">
          <button class="tab active" data-tab="providers">Provider Pool</button>
          <button class="tab" data-tab="credentials">Auth Provider Pool</button>
          <button class="tab" data-tab="quota">Quota Pool</button>
          <button class="tab" data-tab="routing">Runtime Routing Pool</button>
        </div>

        <section id="panelProviders" data-panel="providers">
          <div class="grid grid-wide-left">
            <div class="card" style="box-shadow: none;">
              <p class="section-title">Providers in <span class="mono">virtualrouter.providers</span></p>
              <p class="section-sub">
                API keys are stored as authfiles and referenced with <span class="mono">authfile-…</span>. The UI never reads or returns secrets.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshProvidersBtn" class="primary">Refresh</button>
                <button id="newProviderBtn">New provider…</button>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>id</th>
                      <th>type</th>
                      <th>enabled</th>
                      <th>baseURL</th>
                      <th>models</th>
                      <th>compat</th>
                      <th>auth</th>
                      <th></th>
                    </tr>
                  </thead>
                  <tbody id="providersTbody"></tbody>
                </table>
              </div>
            </div>

            <div class="card" style="box-shadow: none;">
              <p class="section-title" id="providerEditorTitle">Provider editor</p>
              <p class="section-sub">
                Edit provider JSON (secrets are not allowed inline). Save writes to disk and creates a backup.
              </p>

              <div class="notice" style="margin-bottom: 10px;">
                If you use <span class="mono">httpserver.apikey</span>, set it above so API calls don’t return 401. Without apikey configured, this page is localhost-only.
              </div>

              <div class="row" style="margin-bottom: 10px;">
                <label for="providerIdInput">provider id</label>
                <input id="providerIdInput" type="text" placeholder="e.g. tab, glm, qwen" style="width: 240px;" />
                <label for="providerPreset">preset</label>
                <select id="providerPreset">
                  <option value="responses">responses (OpenAI /v1/responses)</option>
                  <option value="openai">openai (OpenAI /v1/chat/completions)</option>
                  <option value="openai-standard">openai-standard</option>
                  <option value="iflow">iflow (cookieFile)</option>
                  <option value="custom" selected>custom (start empty)</option>
                </select>
              </div>

              <div class="row" style="margin-bottom: 10px;">
                <label for="authMode">auth</label>
                <select id="authMode">
                  <option value="apikey">apikey (store as authfile)</option>
                  <option value="oauth">oauth (alias-only + authorize in Auth tab)</option>
                  <option value="cookie">cookieFile</option>
                  <option value="none">none</option>
                </select>
              </div>

              <div id="authApikeyBox" class="card" style="box-shadow:none; padding: 10px; margin-bottom: 10px;">
                <p class="section-title" style="margin-bottom: 8px;">API key</p>
                <div class="row" style="margin-bottom: 8px;">
                  <label for="apikeyAliasInput">alias</label>
                  <input id="apikeyAliasInput" type="text" placeholder="default" style="width: 220px;" />
                  <label for="apikeyValueInput">apiKey</label>
                  <input
                    id="apikeyValueInput"
                    type="password"
                    placeholder="will be written to ~/.routecodex/auth/*.key"
                    style="flex: 1; min-width: 260px;"
                  />
                </div>
                <div class="row">
                  <span class="mono" id="apikeySecretRefOut"></span>
                  <button id="createApiKeyCredentialBtn">Create authfile</button>
                </div>
              </div>

              <div id="authOauthBox" class="card" style="box-shadow:none; padding: 10px; margin-bottom: 10px; display:none;">
                <p class="section-title" style="margin-bottom: 8px;">OAuth</p>
                <p class="section-sub" style="margin-bottom: 8px;">
                  Use Auth tab to authorize. Here we only reference <span class="mono">tokenFile</span> as an alias.
                </p>
                <div class="row">
                  <label for="oauthTypeInput">auth.type</label>
                  <input
                    id="oauthTypeInput"
                    type="text"
                    placeholder="qwen-oauth / iflow-oauth / gemini-cli-oauth / antigravity-oauth"
                    style="flex: 1; min-width: 260px;"
                  />
                  <label for="oauthAliasInput">tokenFile alias</label>
                  <input id="oauthAliasInput" type="text" placeholder="default" style="width: 240px;" />
                </div>
              </div>

              <div id="authCookieBox" class="card" style="box-shadow:none; padding: 10px; margin-bottom: 10px; display:none;">
                <p class="section-title" style="margin-bottom: 8px;">Cookie file</p>
                <div class="row">
                  <label for="cookieFileInput">cookieFile</label>
                  <input
                    id="cookieFileInput"
                    type="text"
                    placeholder="~/.routecodex/auth/iflow-work.cookie"
                    style="flex: 1; min-width: 280px;"
                  />
                </div>
              </div>

              <textarea
                id="providerJsonEditor"
                spellcheck="false"
                placeholder="{\n  \"enabled\": true,\n  \"type\": \"responses\",\n  \"baseURL\": \"https://...\",\n  \"auth\": { \"type\": \"apikey\", \"apiKey\": \"authfile-...\" }\n}"
              ></textarea>

              <div class="row" style="margin-top: 10px;">
                <button id="loadProviderBtn">Load</button>
                <button id="applyPresetBtn">Apply preset</button>
                <button id="saveProviderBtn" class="primary">Save</button>
                <button id="deleteProviderBtn" class="danger">Delete</button>
              </div>

              <div id="providerOpLog" class="log" style="margin-top: 10px; display:none;"></div>
            </div>
          </div>
        </section>

        <section id="panelCredentials" data-panel="credentials" style="display:none;">
          <div class="grid">
            <div class="card" style="box-shadow:none;">
              <p class="section-title">Credentials</p>
              <p class="section-sub">
                Token files + API key authfiles in <span class="mono">~/.routecodex/auth</span>.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshCredentialsBtn" class="primary">Refresh</button>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>kind</th>
                      <th>provider</th>
                      <th>alias</th>
                      <th>status</th>
                      <th>expires</th>
                      <th>secretRef</th>
                    </tr>
                  </thead>
                  <tbody id="credentialsTbody"></tbody>
                </table>
              </div>
            </div>

            <div class="card" style="box-shadow:none;">
              <p class="section-title">OAuth / Browser settings</p>
              <p class="section-sub">
                Set <span class="mono">ROUTECODEX_OAUTH_BROWSER</span> via config so “Authorize” can auto-open with Camoufox.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <label for="oauthBrowserSelect">oauthBrowser</label>
                <select id="oauthBrowserSelect">
                  <option value="default">default</option>
                  <option value="camoufox">camoufox</option>
                </select>
                <button id="saveOauthBrowserBtn" class="primary">Save</button>
              </div>

              <p class="section-title" style="margin-top: 10px;">Authorize OAuth</p>
              <div class="row" style="margin-bottom: 10px;">
                <label for="oauthProviderSelect">provider</label>
                <select id="oauthProviderSelect">
                  <option value="qwen">qwen</option>
                  <option value="iflow">iflow</option>
                  <option value="gemini-cli">gemini-cli</option>
                  <option value="antigravity">antigravity</option>
                </select>
                <label for="oauthAuthAliasInput">alias</label>
                <input id="oauthAuthAliasInput" type="text" placeholder="default" style="width: 240px;" />
              </div>
              <div class="row" style="margin-bottom: 10px;">
                <label><input id="oauthOpenBrowser" type="checkbox" checked /> open browser</label>
                <label><input id="oauthForceReauth" type="checkbox" /> force reauthorize</label>
                <button id="oauthAuthorizeBtn" class="primary">Authorize</button>
              </div>

              <div id="credentialOpLog" class="log" style="display:none;"></div>
            </div>
          </div>
        </section>

        <section id="panelQuota" data-panel="quota" style="display:none;">
          <div class="grid">
            <div class="card" style="box-shadow:none;">
              <p class="section-title">Quota (daemon)</p>
              <p class="section-sub">
                VirtualRouter consumes this via <span class="mono">quotaView</span>. When
                <span class="mono">inPool=false</span>, the provider is treated as removed from the route pool.
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshQuotaBtn" class="primary">Refresh</button>
                <button id="resetQuotaBtn" class="danger">Reset quota module</button>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerKey</th>
                      <th>auth</th>
                      <th>inPool</th>
                      <th>reason</th>
                      <th>cooldownUntil</th>
                      <th>blacklistUntil</th>
                      <th>errCount</th>
                      <th></th>
                    </tr>
                  </thead>
                  <tbody id="quotaTbody"></tbody>
                </table>
              </div>
              <div id="quotaOpLog" class="log" style="margin-top: 10px; display:none;"></div>
            </div>

            <div class="card" style="box-shadow:none;">
              <p class="section-title">Notes</p>
              <div class="notice">
                <div style="margin-bottom: 6px;">
                  Use this view to confirm 429/backoff/blacklist decisions and whether a provider is currently eligible.
                </div>
                <div>
                  If a provider looks stuck, try <span class="mono">Reset quota module</span>, then <span class="mono">Restart runtime</span>.
                </div>
              </div>
            </div>
          </div>
        </section>

        <section id="panelRouting" data-panel="routing" style="display:none;">
          <div class="grid">
            <div class="card" style="box-shadow:none;">
              <p class="section-title">Routing editor</p>
              <p class="section-sub">Edits <span class="mono">virtualrouter.routing</span> in user config.</p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="loadRoutingBtn" class="primary">Load</button>
                <button id="saveRoutingBtn" class="primary">Save</button>
              </div>
              <textarea id="routingEditor" spellcheck="false" placeholder="{\n  \"default\": [...]\n}"></textarea>
              <div id="routingOpLog" class="log" style="margin-top: 10px; display:none;"></div>
            </div>

            <div class="card" style="box-shadow:none;">
              <p class="section-title">Runtime providers</p>
              <p class="section-sub">
                What the running process currently has loaded (restart required after edits).
              </p>
              <div class="row" style="margin-bottom: 10px;">
                <button id="refreshRuntimesBtn" class="primary">Refresh</button>
              </div>
              <div class="table-wrap">
                <table class="table">
                  <thead>
                    <tr>
                      <th>providerKey</th>
                      <th>runtimeKey</th>
                      <th>family</th>
                      <th>protocol</th>
                      <th>series</th>
                    </tr>
                  </thead>
                  <tbody id="runtimesTbody"></tbody>
                </table>
              </div>
            </div>
          </div>
        </section>
      </div>
    </div>

    <script>
      const $ = (id) => document.getElementById(id);

      function setLog(id, value) {
        const el = $(id);
        if (!el) return;
        el.style.display = value ? "block" : "none";
        const raw = value || "";
        const max = 12000;
        const out = raw.length > max ? raw.slice(0, max) + "\n…(truncated)" : raw;
        el.textContent = out;
      }

      function getApiKey() {
        try {
          return sessionStorage.getItem("routecodex:apikey") || "";
        } catch {
          return "";
        }
      }

      function setApiKey(value) {
        try {
          if (!value) sessionStorage.removeItem("routecodex:apikey");
          else sessionStorage.setItem("routecodex:apikey", value);
        } catch {}
      }

      async function apiFetch(path, opts = {}) {
        const headers = new Headers(opts.headers || {});
        const apiKey = getApiKey();
        if (apiKey) headers.set("x-api-key", apiKey);
        if (!headers.has("content-type") && opts.body) headers.set("content-type", "application/json");
        const res = await fetch(path, { ...opts, headers });
        const text = await res.text();
        let json = null;
        try {
          json = text ? JSON.parse(text) : null;
        } catch {
          json = null;
        }
        if (!res.ok) {
          const msg =
            (json && json.error && (json.error.message || json.error.code)) ||
            `HTTP ${res.status} ${res.statusText}`;
          const err = new Error(msg);
          err.status = res.status;
          err.payload = json;
          throw err;
        }
        return json;
      }

      function selectTab(name) {
        document.querySelectorAll(".tab").forEach((btn) => {
          btn.classList.toggle("active", btn.getAttribute("data-tab") === name);
        });
        const panels = [
          { name: "providers", el: $("panelProviders") },
          { name: "credentials", el: $("panelCredentials") },
          { name: "quota", el: $("panelQuota") },
          { name: "routing", el: $("panelRouting") }
        ];
        for (const p of panels) p.el.style.display = p.name === name ? "block" : "none";

        // Light auto-refresh on tab switch to avoid showing stale "Unauthorized" after setting apikey.
        void maybeRefreshTab(name);
      }

      function getActiveTab() {
        const active = document.querySelector(".tab.active");
        const name = active ? active.getAttribute("data-tab") : null;
        return name || "providers";
      }

      const tabLastRefreshedAt = {
        providers: 0,
        credentials: 0,
        quota: 0,
        routing: 0
      };

      async function maybeRefreshTab(name) {
        const key = name in tabLastRefreshedAt ? name : "providers";
        const now = Date.now();
        if (now - tabLastRefreshedAt[key] < 1500) {
          return;
        }
        tabLastRefreshedAt[key] = now;
        try {
          if (key === "providers") await refreshProviders();
          else if (key === "credentials") await refreshCredentials();
          else if (key === "quota") await refreshQuota();
          else if (key === "routing") await refreshRuntimes();
        } catch {
          // ignore refresh failures on tab switch
        }
      }

      function textOf(value) {
        if (value === null || value === undefined) return "";
        return String(value);
      }

      function createCell(tag, text, className, opts = {}) {
        const el = document.createElement(tag);
        if (className) el.className = className;
        const s = textOf(text);
        el.textContent = s;
        if (opts.title && s) el.title = s;
        return el;
      }

      function createErrorRow(colSpan, message) {
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = colSpan;
        td.className = "mono";
        td.textContent = `Failed to load: ${textOf(message)}`;
        tr.appendChild(td);
        return tr;
      }

      function presetFor(type) {
        if (type === "responses") {
          return {
            enabled: true,
            type: "responses",
            baseURL: "https://api.openai.com/v1",
            auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
            responses: { process: "chat", streaming: "always" },
            config: { responses: { process: "chat", streaming: "always" } },
            models: {}
          };
        }
        if (type === "openai") {
          return {
            enabled: true,
            type: "openai",
            baseURL: "https://api.openai.com/v1",
            auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
            models: {}
          };
        }
        if (type === "openai-standard") {
          return {
            enabled: true,
            type: "openai-standard",
            baseURL: "https://api.openai.com/v1",
            auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
            models: {}
          };
        }
        if (type === "iflow") {
          return {
            enabled: true,
            type: "iflow",
            baseURL: "https://apis.iflow.cn/v1",
            compatibilityProfile: "chat:iflow",
            auth: { type: "iflow-cookie", cookieFile: "~/.routecodex/auth/iflow-work.cookie" },
            models: {}
          };
        }
        return {
          enabled: true,
          type: "responses",
          baseURL: "",
          auth: { type: "apikey", apiKey: "authfile-REPLACE_ME" },
          models: {}
        };
      }

      async function refreshStatus() {
        try {
          const data = await apiFetch("/daemon/status");
          $("serverId").textContent = `serverId: ${data.serverId || "—"}`;
          $("statusText").textContent = "connected";
          $("statusDot").classList.add("ok");
          $("statusDot").classList.remove("err");
        } catch (e) {
          $("statusText").textContent = e && e.status === 401 ? "401 (set API key above)" : "disconnected";
          $("statusDot").classList.remove("ok");
          $("statusDot").classList.add("err");
        }
      }

      async function refreshProviders() {
        const body = $("providersTbody");
        body.replaceChildren();
        try {
          const data = await apiFetch("/config/providers");
          const list = Array.isArray(data.providers) ? data.providers : [];
          const grouped = new Map();
          for (const p of list) {
            const t = textOf(p.type || "unknown") || "unknown";
            if (!grouped.has(t)) grouped.set(t, []);
            grouped.get(t).push(p);
          }
          const types = Array.from(grouped.keys()).sort((a, b) => a.localeCompare(b));
          for (const type of types) {
            const groupRow = document.createElement("tr");
            groupRow.className = "group-row";
            const groupCell = document.createElement("td");
            groupCell.colSpan = 8;
            groupCell.textContent = `${type} (${grouped.get(type).length})`;
            groupRow.appendChild(groupCell);
            body.appendChild(groupRow);

            const items = grouped.get(type);
            items.sort((a, b) => textOf(a.id).localeCompare(textOf(b.id)));
            for (const p of items) {
              const tr = document.createElement("tr");
              tr.appendChild(createCell("td", p.id || "", "mono indent"));
              tr.appendChild(createCell("td", p.type || "", ""));
              tr.appendChild(createCell("td", String(Boolean(p.enabled)), ""));
              tr.appendChild(createCell("td", p.baseURL || "", "mono truncate", { title: true }));
              const preview = Array.isArray(p.modelsPreview) ? p.modelsPreview.map((x) => textOf(x)).filter(Boolean) : [];
              const modelSummary = preview.length ? `${p.modelCount || 0}: ${preview.join(", ")}${(p.modelCount || 0) > preview.length ? ", …" : ""}` : String(p.modelCount || 0);
              tr.appendChild(createCell("td", modelSummary, "mono truncate", { title: true }));
              tr.appendChild(createCell("td", p.compatibilityProfile || "", "mono truncate", { title: true }));
              tr.appendChild(createCell("td", p.authType || "", ""));
              const actionsTd = document.createElement("td");
              actionsTd.className = "actions-cell";
              const box = document.createElement("div");
              box.className = "actions";
              const edit = document.createElement("button");
              edit.textContent = "Edit";
              edit.setAttribute("data-action", "edit");
              edit.setAttribute("data-id", textOf(p.id));
              const test = document.createElement("button");
              test.textContent = "Test";
              test.setAttribute("data-action", "test");
              test.setAttribute("data-id", textOf(p.id));
              test.disabled = !(p && p.enabled !== false && Number(p.modelCount || 0) > 0);
              const del = document.createElement("button");
              del.textContent = "Delete";
              del.className = "danger";
              del.setAttribute("data-action", "delete");
              del.setAttribute("data-id", textOf(p.id));
              box.appendChild(edit);
              box.appendChild(test);
              box.appendChild(del);
              actionsTd.appendChild(box);
              tr.appendChild(actionsTd);
              body.appendChild(tr);
            }
          }
        } catch (e) {
          body.appendChild(createErrorRow(8, e && e.message ? e.message : e));
        }
      }

      async function loadProvider(id) {
        setLog("providerOpLog", "");
        try {
          const data = await apiFetch(`/config/providers/${encodeURIComponent(id)}`);
          $("providerIdInput").value = id;
          $("providerJsonEditor").value = JSON.stringify(data.provider || {}, null, 2);
          $("providerEditorTitle").textContent = `Provider editor: ${id}`;
        } catch (e) {
          setLog("providerOpLog", `Load failed: ${e.message}`);
        }
      }

      async function saveProvider() {
        setLog("providerOpLog", "");
        const id = ($("providerIdInput").value || "").trim();
        if (!id) {
          setLog("providerOpLog", "provider id is required");
          return;
        }
        try {
          const provider = JSON.parse($("providerJsonEditor").value || "{}");
          const result = await apiFetch(`/config/providers/${encodeURIComponent(id)}`, {
            method: "PUT",
            body: JSON.stringify({ provider })
          });
          setLog("providerOpLog", `Saved. Path: ${result.path || "—"}\nRestart required to apply.`);
          await refreshProviders();
        } catch (e) {
          setLog("providerOpLog", `Save failed: ${e.message}`);
        }
      }

      async function deleteProvider(id) {
        setLog("providerOpLog", "");
        if (!id) {
          setLog("providerOpLog", "provider id is required");
          return;
        }
        if (!confirm(`Delete provider "${id}" from user config?`)) return;
        try {
          const result = await apiFetch(`/config/providers/${encodeURIComponent(id)}`, { method: "DELETE" });
          setLog("providerOpLog", `Deleted. Path: ${result.path || "—"}\nRestart required to apply.`);
          await refreshProviders();
        } catch (e) {
          setLog("providerOpLog", `Delete failed: ${e.message}`);
        }
      }

      async function createApiKeyCredential() {
        setLog("providerOpLog", "");
        $("apikeySecretRefOut").textContent = "";
        const provider = ($("providerIdInput").value || "").trim();
        const alias = ($("apikeyAliasInput").value || "default").trim() || "default";
        const apiKey = ($("apikeyValueInput").value || "").trim();
        if (!provider) {
          setLog("providerOpLog", "provider id is required before creating an authfile");
          return null;
        }
        if (!apiKey) {
          setLog("providerOpLog", "apiKey is required");
          return null;
        }
        try {
          const out = await apiFetch("/daemon/credentials/apikey", {
            method: "POST",
            body: JSON.stringify({ provider, alias, apiKey })
          });
          $("apikeySecretRefOut").textContent = `secretRef: ${out.secretRef}`;
          return out.secretRef;
        } catch (e) {
          setLog("providerOpLog", `Create authfile failed: ${e.message}`);
          return null;
        }
      }

      function applyPresetToEditor() {
        const preset = $("providerPreset").value;
        const base = presetFor(preset);
        const authMode = $("authMode").value;
        if (authMode === "none") {
          delete base.auth;
        }
        if (authMode === "cookie") {
          base.auth = {
            type: "iflow-cookie",
            cookieFile: ($("cookieFileInput").value || "").trim() || "~/.routecodex/auth/iflow.cookie"
          };
        }
        if (authMode === "oauth") {
          const t = ($("oauthTypeInput").value || "").trim() || "qwen-oauth";
          const alias = ($("oauthAliasInput").value || "default").trim() || "default";
          base.auth = { type: t, tokenFile: alias };
        }
        if (authMode === "apikey") {
          const secretRef = ($("apikeySecretRefOut").textContent || "").replace(/^secretRef:\\s*/i, "").trim();
          base.auth = { type: "apikey", apiKey: secretRef || "authfile-REPLACE_ME" };
        }
        $("providerJsonEditor").value = JSON.stringify(base, null, 2);
      }

      function updateAuthModeUi() {
        const mode = $("authMode").value;
        $("authApikeyBox").style.display = mode === "apikey" ? "block" : "none";
        $("authOauthBox").style.display = mode === "oauth" ? "block" : "none";
        $("authCookieBox").style.display = mode === "cookie" ? "block" : "none";
      }

      async function refreshCredentials() {
        const body = $("credentialsTbody");
        body.replaceChildren();
        try {
          const items = await apiFetch("/daemon/credentials");
          for (const c of items || []) {
            const tr = document.createElement("tr");
            const exp = c.expiresInSec == null ? "—" : `${c.expiresInSec}s`;
            tr.appendChild(createCell("td", c.kind || "", ""));
            tr.appendChild(createCell("td", c.provider || "", "mono"));
            tr.appendChild(createCell("td", c.alias || "", "mono"));
            tr.appendChild(createCell("td", c.status || "", ""));
            tr.appendChild(createCell("td", exp, "mono"));
            tr.appendChild(createCell("td", c.secretRef || "—", "mono"));
            body.appendChild(tr);
          }
        } catch (e) {
          body.appendChild(createErrorRow(6, e && e.message ? e.message : e));
        }
      }

      async function loadSettings() {
        try {
          const data = await apiFetch("/config/settings");
          const v = (data.oauthBrowser || "default").toLowerCase();
          $("oauthBrowserSelect").value = v === "camoufox" ? "camoufox" : "default";
        } catch {}
      }

      async function saveSettings() {
        setLog("credentialOpLog", "");
        const oauthBrowser = $("oauthBrowserSelect").value;
        try {
          const out = await apiFetch("/config/settings", {
            method: "PUT",
            body: JSON.stringify({ oauthBrowser })
          });
          setLog("credentialOpLog", `Saved oauthBrowser=${out.oauthBrowser}.`);
        } catch (e) {
          setLog("credentialOpLog", `Save failed: ${e.message}`);
        }
      }

      async function authorizeOauth() {
        setLog("credentialOpLog", "");
        const provider = $("oauthProviderSelect").value;
        const alias = ($("oauthAuthAliasInput").value || "default").trim() || "default";
        const openBrowser = $("oauthOpenBrowser").checked;
        const forceReauthorize = $("oauthForceReauth").checked;
        try {
          const out = await apiFetch("/daemon/oauth/authorize", {
            method: "POST",
            body: JSON.stringify({ provider, alias, openBrowser, forceReauthorize })
          });
          setLog("credentialOpLog", `OK. tokenFile: ${out.tokenFile || "—"}`);
          await refreshCredentials();
        } catch (e) {
          setLog("credentialOpLog", `Authorize failed: ${e.message}`);
        }
      }

      async function loadRouting() {
        setLog("routingOpLog", "");
        try {
          const out = await apiFetch("/config/routing");
          $("routingEditor").value = JSON.stringify(out.routing || {}, null, 2);
          setLog("routingOpLog", `Loaded. Path: ${out.path || "—"}`);
        } catch (e) {
          setLog("routingOpLog", `Load failed: ${e.message}`);
        }
      }

      async function saveRouting() {
        setLog("routingOpLog", "");
        try {
          const routing = JSON.parse($("routingEditor").value || "{}");
          const out = await apiFetch("/config/routing", {
            method: "PUT",
            body: JSON.stringify({ routing })
          });
          setLog("routingOpLog", `Saved. Path: ${out.path || "—"}\nRestart required to apply.`);
        } catch (e) {
          setLog("routingOpLog", `Save failed: ${e.message}`);
        }
      }

      async function refreshRuntimes() {
        const body = $("runtimesTbody");
        body.replaceChildren();
        try {
          const items = await apiFetch("/providers/runtimes");
          for (const r of items || []) {
            const tr = document.createElement("tr");
            tr.appendChild(createCell("td", r.providerKey || "", "mono truncate", { title: true }));
            tr.appendChild(createCell("td", r.runtimeKey || "", "mono truncate", { title: true }));
            tr.appendChild(createCell("td", r.family || "", ""));
            tr.appendChild(createCell("td", r.protocol || "", ""));
            tr.appendChild(createCell("td", r.series || "", ""));
            body.appendChild(tr);
          }
        } catch (e) {
          body.appendChild(createErrorRow(5, e && e.message ? e.message : e));
        }
      }

      function formatEpochMs(ms) {
        if (typeof ms !== "number" || !Number.isFinite(ms) || ms <= 0) return "—";
        try {
          return new Date(ms).toLocaleString();
        } catch {
          return String(ms);
        }
      }

      async function refreshQuota() {
        const body = $("quotaTbody");
        body.replaceChildren();
        setLog("quotaOpLog", "");
        try {
          const out = await apiFetch("/quota/providers");
          const list = Array.isArray(out.providers) ? out.providers : [];
          for (const q of list) {
            const tr = document.createElement("tr");
            tr.appendChild(createCell("td", q.providerKey || "", "mono truncate", { title: true }));
            tr.appendChild(createCell("td", q.authType || "", ""));
            tr.appendChild(createCell("td", String(Boolean(q.inPool)), ""));
            tr.appendChild(createCell("td", q.reason || "", ""));
            tr.appendChild(createCell("td", formatEpochMs(q.cooldownUntil), "mono"));
            tr.appendChild(createCell("td", formatEpochMs(q.blacklistUntil), "mono"));
            tr.appendChild(createCell("td", q.consecutiveErrorCount ?? 0, "mono"));
            const actionsTd = document.createElement("td");
            actionsTd.className = "actions-cell";
            const box = document.createElement("div");
            box.className = "actions";
            const recover = document.createElement("button");
            recover.textContent = "Recover";
            recover.setAttribute("data-action", "quota-recover");
            recover.setAttribute("data-key", textOf(q.providerKey));
            const reset = document.createElement("button");
            reset.textContent = "Reset";
            reset.setAttribute("data-action", "quota-reset");
            reset.setAttribute("data-key", textOf(q.providerKey));
            const disable = document.createElement("button");
            disable.textContent = "Disable…";
            disable.className = "danger";
            disable.setAttribute("data-action", "quota-disable");
            disable.setAttribute("data-key", textOf(q.providerKey));
            box.appendChild(recover);
            box.appendChild(reset);
            box.appendChild(disable);
            actionsTd.appendChild(box);
            tr.appendChild(actionsTd);
            body.appendChild(tr);
          }
        } catch (e) {
          body.appendChild(createErrorRow(8, e && e.message ? e.message : e));
        }
      }

      async function testProviderFromPool(providerId) {
        setLog("providerOpLog", "");
        try {
          const detail = await apiFetch(`/config/providers/${encodeURIComponent(providerId)}`);
          const provider = detail && detail.provider ? detail.provider : null;
          const models = provider && provider.models && typeof provider.models === "object" ? Object.keys(provider.models) : [];
          if (!models.length) {
            throw new Error("No models configured for this provider");
          }
          const modelId = models[0];
          const directModel = `${providerId}.${modelId}`;
          const payload = { model: directModel, input: "ping", stream: false };
          const headers = new Headers({ "content-type": "application/json" });
          const apiKey = getApiKey();
          if (apiKey) headers.set("x-api-key", apiKey);
          const started = Date.now();
          const resp = await fetch("/v1/responses", { method: "POST", headers, body: JSON.stringify(payload) });
          const text = await resp.text();
          const ms = Date.now() - started;
          if (!resp.ok) {
            throw new Error(`HTTP ${resp.status} (${ms}ms): ${text}`);
          }
          let json = null;
          try { json = text ? JSON.parse(text) : null; } catch { json = null; }
          const summary =
            json && typeof json.output_text === "string"
              ? json.output_text.slice(0, 200)
              : json && Array.isArray(json.output)
                ? "(output items=" + json.output.length + ")"
                : "(ok)";
          setLog("providerOpLog", `Test OK (${ms}ms) model=${directModel}\n${summary}`);
        } catch (e) {
          setLog("providerOpLog", `Test failed: ${e && e.message ? e.message : e}`);
        }
      }

      async function quotaAction(kind, providerKey) {
        setLog("quotaOpLog", "");
        if (!providerKey) return;
        try {
          if (kind === "recover") {
            await apiFetch(`/quota/providers/${encodeURIComponent(providerKey)}/recover`, { method: "POST" });
            await refreshQuota();
            return;
          }
          if (kind === "reset") {
            await apiFetch(`/quota/providers/${encodeURIComponent(providerKey)}/reset`, { method: "POST" });
            await refreshQuota();
            return;
          }
          if (kind === "disable") {
            const minutesRaw = prompt("Disable duration (minutes)", "60");
            if (!minutesRaw) return;
            const minutes = Number.parseFloat(minutesRaw);
            if (!Number.isFinite(minutes) || minutes <= 0) {
              throw new Error("Invalid minutes");
            }
            const modeRaw = prompt("Mode: cooldown or blacklist", "cooldown");
            const mode = (modeRaw || "cooldown").trim().toLowerCase() === "blacklist" ? "blacklist" : "cooldown";
            await apiFetch(`/quota/providers/${encodeURIComponent(providerKey)}/disable`, {
              method: "POST",
              body: JSON.stringify({ mode, durationMinutes: minutes })
            });
            await refreshQuota();
            return;
          }
        } catch (e) {
          setLog("quotaOpLog", `Action failed: ${e && e.message ? e.message : e}`);
        }
      }

      async function resetQuotaModule() {
        setLog("quotaOpLog", "");
        if (!confirm("Reset provider-quota module now? This clears cooldown/blacklist state.")) return;
        try {
          const out = await apiFetch("/daemon/modules/provider-quota/reset", { method: "POST" });
          setLog("quotaOpLog", `OK. resetAt=${out.resetAt || "—"}`);
          await refreshQuota();
        } catch (e) {
          setLog("quotaOpLog", `Reset failed: ${e.message}`);
        }
      }

      // Bind events
      document.querySelectorAll(".tab").forEach((btn) => {
        btn.addEventListener("click", () => selectTab(btn.getAttribute("data-tab")));
      });

      $("saveApiKeyBtn").addEventListener("click", () => {
        const value = ($("apiKeyInput").value || "").trim();
        setApiKey(value);
        $("apiKeyHint").textContent = value ? "saved (session only)" : "";
        Promise.resolve()
          .then(refreshStatus)
          .then(() => selectTab(getActiveTab()))
          .catch(() => {});
      });
      $("clearApiKeyBtn").addEventListener("click", () => {
        setApiKey("");
        $("apiKeyInput").value = "";
        $("apiKeyHint").textContent = "";
        Promise.resolve()
          .then(refreshStatus)
          .then(() => selectTab(getActiveTab()))
          .catch(() => {});
      });

      $("restartRuntimeBtn").addEventListener("click", async () => {
        setLog("providerOpLog", "");
        if (!confirm("Reload config from disk and rebuild runtime now?")) return;
        try {
          const out = await apiFetch("/daemon/restart", { method: "POST" });
          const warnings = Array.isArray(out.warnings) && out.warnings.length ? `\nWarnings:\n- ${out.warnings.join("\n- ")}` : "";
          setLog("providerOpLog", `Restarted.\nconfigPath: ${out.configPath || "—"}\nreloadedAt: ${out.reloadedAt || "—"}${warnings}`);
          await refreshStatus();
          await refreshProviders();
          await refreshCredentials();
          await refreshQuota();
          await refreshRuntimes();
        } catch (e) {
          setLog("providerOpLog", `Restart failed: ${e.message}`);
        }
      });

      $("refreshProvidersBtn").addEventListener("click", refreshProviders);
      $("newProviderBtn").addEventListener("click", () => {
        $("providerEditorTitle").textContent = "Provider editor (new)";
        $("providerIdInput").value = "";
        $("providerJsonEditor").value = JSON.stringify(presetFor($("providerPreset").value), null, 2);
        setLog("providerOpLog", "");
      });
      $("providersTbody").addEventListener("click", async (ev) => {
        const btn = ev.target.closest("button");
        if (!btn) return;
        const id = btn.getAttribute("data-id");
        const action = btn.getAttribute("data-action");
        if (action === "test" && id) {
          await testProviderFromPool(id);
          return;
        }
        if (action === "edit") await loadProvider(id);
        if (action === "delete") await deleteProvider(id);
      });
      $("loadProviderBtn").addEventListener("click", async () => {
        const id = ($("providerIdInput").value || "").trim();
        if (id) await loadProvider(id);
      });
      $("applyPresetBtn").addEventListener("click", applyPresetToEditor);
      $("saveProviderBtn").addEventListener("click", saveProvider);
      $("deleteProviderBtn").addEventListener("click", async () => {
        const id = ($("providerIdInput").value || "").trim();
        await deleteProvider(id);
      });
      $("createApiKeyCredentialBtn").addEventListener("click", createApiKeyCredential);

      $("authMode").addEventListener("change", updateAuthModeUi);
      updateAuthModeUi();

      $("refreshCredentialsBtn").addEventListener("click", refreshCredentials);
      $("saveOauthBrowserBtn").addEventListener("click", saveSettings);
      $("oauthAuthorizeBtn").addEventListener("click", authorizeOauth);

      $("refreshQuotaBtn").addEventListener("click", refreshQuota);
      $("quotaTbody").addEventListener("click", (ev) => {
        const el = ev.target;
        if (!el || el.tagName !== "BUTTON") return;
        const action = el.getAttribute("data-action");
        const key = el.getAttribute("data-key");
        if (action === "quota-recover") void quotaAction("recover", key);
        else if (action === "quota-reset") void quotaAction("reset", key);
        else if (action === "quota-disable") void quotaAction("disable", key);
      });
      $("resetQuotaBtn").addEventListener("click", resetQuotaModule);

      $("loadRoutingBtn").addEventListener("click", loadRouting);
      $("saveRoutingBtn").addEventListener("click", saveRouting);
      $("refreshRuntimesBtn").addEventListener("click", refreshRuntimes);

      // Init
      (async () => {
        const savedKey = getApiKey();
        if (savedKey) {
          $("apiKeyHint").textContent = "saved (session only)";
          $("apiKeyInput").value = savedKey;
        }
        await refreshStatus();
        await refreshProviders();
        await refreshCredentials();
        await refreshQuota();
        await refreshRuntimes();
        await loadSettings();
      })();
    </script>
  </body>
</html>
