# 非流式场景下的Claude Code Router分析

## 递归调用的位置

### 1. **工具调用后的递归**（主要位置）

```typescript
// 位置1：工具调用完成后的递归（index.ts:243-250）
if (data.event === 'message_delta' && toolMessages.length) {
  // 将工具调用添加到消息历史
  req.body.messages.push({
    role: 'assistant',
    content: assistantMessages
  })
  req.body.messages.push({
    role: 'user', 
    content: toolMessages
  })
  
  // 🔴 递归调用：重新发送请求到同一个API
  const response = await fetch(`http://127.0.0.1:${config.PORT}/v1/messages`, {
    method: "POST",
    headers: {
      'x-api-key': config.APIKEY,
      'content-type': 'application/json',
    },
    body: JSON.stringify(req.body), // 包含工具结果的更新后请求
  })
}
```

### 2. **图像分析Agent的递归**（次要位置）

```typescript
// 位置2：图像分析工具的递归调用（image.agent.ts:132-154）
const agentResponse = await fetch(`http://127.0.0.1:${context.config.PORT}/v1/messages`, {
  method: "POST",
  body: JSON.stringify({
    model: context.config.Router.image,
    system: [{ /* 图像分析的system prompt */ }],
    messages: [
      {
        role: 'user',
        content: imageMessages, // 从缓存中获取的图像数据
      }
    ],
    stream: false, // 🔴 非流式调用
  }),
})
```

## 非流式场景下的状态管理需求

### 1. **图像缓存管理**（主要需求）

```typescript
// 图像缓存：基于请求ID
imageCache.storeImage(`${req.id}_Image#${imgId}`, msg.source);

// 图像检索：工具调用时从缓存获取
const image = imageCache.getImage(`${context.req.id}_Image#${imgId}`);
```

**为什么需要缓存？**
- 图像内容被替换为占位符 `[Image #1]`
- 工具调用时需要重新获取原始图像数据
- 缓存键基于请求ID确保隔离

### 2. **工具调用参数组装**（次要需求）

在非流式场景下，工具调用参数是完整的，不需要跨事件累积：

```typescript
// 非流式：工具参数是完整的对象
{
  "name": "analyzeImage",
  "input": {
    "imageId": ["1", "2"],
    "task": "描述这张图片"
  }
}
```

### 3. **递归调用的上下文维护**（关键需求）

```typescript
// 递归调用前：更新消息历史
req.body.messages.push({
  role: 'assistant',
  content: assistantMessages // 工具调用
})
req.body.messages.push({
  role: 'user',
  content: toolMessages // 工具结果
})

// 递归调用：发送更新后的完整对话历史
const response = await fetch(`http://127.0.0.1:${config.PORT}/v1/messages`, {
  body: JSON.stringify(req.body) // 包含完整对话历史
})
```

## 非流式场景的简化分析

### 状态管理的真实需求（修正后）

#### 1. **图像缓存管理**（20%）
- 请求级别的图像缓存
- 图像ID生成和检索
- 缓存清理

#### 2. **递归调用协调**（15%）
- 消息历史更新
- 工具结果插入
- 递归调用触发

#### 3. **工具执行状态**（5%）
- 当前执行的工具信息
- 工具结果收集

## 重新评估：静态表 vs 动态处理

### 静态表能解决的（提升到80-85%）：

1. **基础协议转换** ✅
   - 模型映射
   - 参数转换
   - 消息结构转换

2. **工具定义转换** ✅
   - 工具schema转换
   - 参数格式转换

3. **错误码映射** ✅
   - 标准错误响应转换

4. **响应格式转换** ✅
   - 非流式响应结构转换
   - 工具结果格式转换

### 需要动态处理的（降低到15-20%）：

1. **图像缓存逻辑**（10%）
   - 图像ID生成：`${req.id}_Image#${imgId}`
   - 图像内容替换：`[Image #${imgId}]`
   - 缓存检索逻辑

2. **递归调用协调**（5%）
   - 消息历史更新
   - 工具结果插入
   - 递归触发逻辑

3. **工具执行**（5%）
   - 工具调用执行
   - 结果格式化

## 非流式场景的特殊处理

### 1. **简化的工具调用流程**
```
请求接收 → 工具检测 → 工具执行 → 结果插入 → 递归调用 → 响应返回
```

### 2. **无需流处理状态**
- 不需要跨事件的状态维护
- 不需要SSE事件解析
- 工具参数是完整的JSON对象

### 3. **递归调用是主要复杂度**
- 单次HTTP请求可能触发多次内部递归调用
- 每次递归都需要更新消息历史
- 需要避免无限递归

## 结论

在**非流式场景**下：

1. **静态表能解决80-85%的问题**，主要是协议转换
2. **只需要15-20%的动态处理**，主要是：
   - 图像缓存管理
   - 递归调用协调
   - 工具执行逻辑

3. **递归调用是主要复杂度来源**：
   - 工具调用完成后，需要递归调用同一API
   - 需要维护完整的对话历史
   - 需要正确处理工具结果的插入

这比流式场景简单很多，状态管理需求大大降低！