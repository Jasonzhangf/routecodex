/**
 * Hybrid Pipeline Assembler (Enhanced PipelineAssembler)
 * 
 * Extends the existing PipelineAssembler to support hybrid V1/V2 modes
 * while maintaining full backward compatibility.
 */

import type { MergedConfig } from '../../../config/merged-config-types.js';
import { PipelineAssembler } from './pipeline-assembler.js';
import { HybridPipelineAssembler, type AssembledHybridPipelines } from '../../v2/core/hybrid-adapter/hybrid-assembler.js';

/**
 * Enhanced Pipeline Assembler with Hybrid Support
 * 
 * This assembler detects hybrid configuration in merged-config and
 * automatically switches to hybrid mode when needed.
 */
export class HybridPipelineAssemblerWrapper {
  /**
   * Main assembly method that detects and routes to appropriate assembler
   */
  static async assemble(mergedConfig: unknown): Promise<AssembledHybridPipelines> {
    const config = mergedConfig as Record<string, any>;
    const systemConfig = config.system || {};
    const hybridConfig = config.modules?.hybridpipeline?.config;
    
    // Check if hybrid mode is explicitly enabled
    if (hybridConfig?.enabled && hybridConfig.mode && hybridConfig.mode !== 'v1') {
      console.log(`üîÑ Hybrid pipeline mode detected: ${hybridConfig.mode}`);
      
      // Use hybrid assembler
      try {
        const result = await HybridPipelineAssembler.assemble(mergedConfig);
        console.log(`‚úÖ Hybrid pipeline assembled successfully: ${result.mode}`);
        return result;
      } catch (error) {
        console.warn(`‚ö†Ô∏è  Hybrid assembly failed, falling back to V1:`, error instanceof Error ? error.message : String(error));
        // Fall back to V1 assembler
        const v1Result = await PipelineAssembler.assemble(mergedConfig);
        return this.convertToHybridFormat(v1Result, 'v1');
      }
    }
    
    // Default to V1 assembler for backward compatibility
    const v1Result = await PipelineAssembler.assemble(mergedConfig);
    return this.convertToHybridFormat(v1Result, 'v1');
  }

  /**
   * Assemble from file
   */
  static async assembleFromFile(mergedConfigPath: string): Promise<AssembledHybridPipelines> {
    const fs = await import('fs/promises');
    const path = await import('path');
    
    const abs = mergedConfigPath.startsWith('.') 
      ? path.resolve(process.cwd(), mergedConfigPath) 
      : mergedConfigPath;
    
    const content = await fs.readFile(abs, 'utf-8');
    const mergedConfig = JSON.parse(content);
    
    return this.assemble(mergedConfig);
  }

  /**
   * Convert V1 assembly result to hybrid format
   */
  private static convertToHybridFormat(
    v1Result: { manager: any; routePools: Record<string, string[]>; routeMeta: Record<string, any> },
    mode: 'v1' | 'v2' | 'hybrid'
  ): AssembledHybridPipelines {
    return {
      manager: v1Result.manager, // V1 manager is compatible with hybrid interface
      routePools: v1Result.routePools,
      routeMeta: v1Result.routeMeta,
      mode
    };
  }
}

// Export for backward compatibility
export { AssembledHybridPipelines, HybridPipelineAssemblerWrapper as PipelineAssembler };
