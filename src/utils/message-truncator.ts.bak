/**
 * Message Truncation Utility
 * 消息截断工具 - 处理大型消息内容的智能截断和展开
 */

export interface TruncationOptions {
  maxLength?: number;
  maxLines?: number;
  maxArrayItems?: number;
  maxObjectDepth?: number;
  preserveStructure?: boolean;
  showTruncationInfo?: boolean;
}

export interface TruncationResult {
  data: any;
  isTruncated: boolean;
  truncationInfo: {
    originalLength: number;
    truncatedLength: number;
    truncationType: 'length' | 'lines' | 'array' | 'depth' | 'none';
    truncatedPaths: string[];
  };
}

export class MessageTruncator {
  private static readonly DEFAULT_OPTIONS: Required<TruncationOptions> = {
    maxLength: 10000, // 字符串最大长度
    maxLines: 50, // 行数限制
    maxArrayItems: 20, // 数组最大项数
    maxObjectDepth: 5, // 对象最大深度
    preserveStructure: true, // 保持结构完整性
    showTruncationInfo: true // 显示截断信息
  };

  /**
   * 智能截断数据
   */
  static truncate(data: any, options: TruncationOptions = {}): TruncationResult {
    const config = { ...this.DEFAULT_OPTIONS, ...options };
    const result = this.performTruncation(data, '', config);

    return {
      data: result.data,
      isTruncated: result.isTruncated,
      truncationInfo: {
        originalLength: this.getDataSize(data),
        truncatedLength: this.getDataSize(result.data),
        truncationType: result.truncationType,
        truncatedPaths: result.truncatedPaths
      }
    };
  }

  /**
   * 执行截断操作
   */
  private static performTruncation(
    data: any,
    path: string,
    options: Required<TruncationOptions>,
    depth: number = 0,
    visited: Set<any> = new Set()
  ): { data: any; isTruncated: boolean; truncationType: string; truncatedPaths: string[] } {

    // 防止循环引用
    if (typeof data === 'object' && data !== null) {
      if (visited.has(data)) {
        return {
          data: '[Circular Reference]',
          isTruncated: false,
          truncationType: 'none',
          truncatedPaths: []
        };
      }
      visited.add(data);
    }

    // 检查深度限制
    if (depth > options.maxObjectDepth) {
      return {
        data: '[Max Depth Exceeded]',
        isTruncated: true,
        truncationType: 'depth',
        truncatedPaths: [path]
      };
    }

    // 处理不同类型的数据
    if (typeof data === 'string') {
      return this.truncateString(data, path, options);
    } else if (Array.isArray(data)) {
      return this.truncateArray(data, path, options, depth, visited);
    } else if (typeof data === 'object' && data !== null) {
      return this.truncateObject(data, path, options, depth, visited);
    }

    // 基本类型直接返回
    return {
      data: data,
      isTruncated: false,
      truncationType: 'none',
      truncatedPaths: []
    };
  }

  /**
   * 截断字符串
   */
  private static truncateString(
    str: string,
    path: string,
    options: Required<TruncationOptions>
  ): { data: any; isTruncated: boolean; truncationType: string; truncatedPaths: string[] } {

    // 检查行数限制
    const lines = str.split('\n');
    if (lines.length > options.maxLines) {
      const truncatedLines = lines.slice(0, options.maxLines);
      const truncatedStr = truncatedLines.join('\n') +
        `\n\n... [truncated ${lines.length - options.maxLines} lines]`;

      return {
        data: options.showTruncationInfo ?
          this.addTruncationMarker(truncatedStr, 'lines', lines.length - options.maxLines) :
          truncatedStr,
        isTruncated: true,
        truncationType: 'lines',
        truncatedPaths: [path]
      };
    }

    // 检查长度限制
    if (str.length > options.maxLength) {
      const truncatedStr = str.substring(0, options.maxLength) +
        '... [truncated]';

      return {
        data: options.showTruncationInfo ?
          this.addTruncationMarker(truncatedStr, 'length', str.length - options.maxLength) :
          truncatedStr,
        isTruncated: true,
        truncationType: 'length',
        truncatedPaths: [path]
      };
    }

    return {
      data: str,
      isTruncated: false,
      truncationType: 'none',
      truncatedPaths: []
    };
  }

  /**
   * 截断数组
   */
  private static truncateArray(
    arr: any[],
    path: string,
    options: Required<TruncationOptions>,
    depth: number,
    visited: Set<any>
  ): { data: any; isTruncated: boolean; truncationType: string; truncatedPaths: string[] } {

    if (arr.length <= options.maxArrayItems) {
      // 数组长度在限制内，递归处理每个元素
      const result: any[] = [];
      let hasTruncation = false;
      const truncatedPaths: string[] = [];

      for (let i = 0; i < arr.length; i++) {
        const itemResult = this.performTruncation(
          arr[i],
          `${path}[${i}]`,
          options,
          depth + 1,
          visited
        );

        result.push(itemResult.data);
        if (itemResult.isTruncated) {
          hasTruncation = true;
          truncatedPaths.push(...itemResult.truncatedPaths);
        }
      }

      return {
        data: result,
        isTruncated: hasTruncation,
        truncationType: hasTruncation ? 'array' : 'none',
        truncatedPaths
      };
    }

    // 数组过长，截断并保留首尾元素
    const keepStart = Math.floor(options.maxArrayItems / 2);
    const keepEnd = options.maxArrayItems - keepStart;

    const result: any[] = [];
    let hasTruncation = false;
    const truncatedPaths: string[] = [path];

    // 保留前半部分
    for (let i = 0; i < keepStart && i < arr.length; i++) {
      const itemResult = this.performTruncation(
        arr[i],
        `${path}[${i}]`,
        options,
        depth + 1,
        visited
      );

      result.push(itemResult.data);
      if (itemResult.isTruncated) {
        hasTruncation = true;
        truncatedPaths.push(...itemResult.truncatedPaths);
      }
    }

    // 添加截断标记
    const omitted = arr.length - options.maxArrayItems;
    const truncationMarker = options.showTruncationInfo ?
      `[... ${omitted} omitted items ...]` :
      `[... ${omitted} omitted ...]`;

    result.push(truncationMarker);

    // 保留后半部分
    for (let i = arr.length - keepEnd; i < arr.length; i++) {
      const itemResult = this.performTruncation(
        arr[i],
        `${path}[${i}]`,
        options,
        depth + 1,
        visited
      );

      result.push(itemResult.data);
      if (itemResult.isTruncation) {
        hasTruncation = true;
        truncatedPaths.push(...itemResult.truncatedPaths);
      }
    }

    return {
      data: result,
      isTruncated: true,
      truncationType: 'array',
      truncatedPaths
    };
  }

  /**
   * 截断对象
   */
  private static truncateObject(
    obj: Record<string, any>,
    path: string,
    options: Required<TruncationOptions>,
    depth: number,
    visited: Set<any>
  ): { data: any; isTruncated: boolean; truncationType: string; truncatedPaths: string[] } {

    const result: Record<string, any> = {};
    let hasTruncation = false;
    const truncatedPaths: string[] = [];

    // 特殊处理大型字段
    const entries = Object.entries(obj);
    const entriesToProcess = entries.filter(([key, value]) => {
      // 识别大型字段
      if (typeof value === 'string' && value.length > options.maxLength) {
        return true;
      }
      if (Array.isArray(value) && value.length > options.maxArrayItems) {
        return true;
      }
      return true; // 先处理所有字段
    });

    // 按优先级排序（重要的字段先处理）
    const prioritizedEntries = this.prioritizeFields(entriesToProcess);

    for (const [key, value] of prioritizedEntries) {
      const currentPath = path ? `${path}.${key}` : key;

      const fieldResult = this.performTruncation(
        value,
        currentPath,
        options,
        depth + 1,
        visited
      );

      result[key] = fieldResult.data;
      if (fieldResult.isTruncated) {
        hasTruncation = true;
        truncatedPaths.push(...fieldResult.truncatedPaths);
      }
    }

    return {
      data: result,
      isTruncated: hasTruncation,
      truncationType: hasTruncation ? 'object' : 'none',
      truncatedPaths
    };
  }

  /**
   * 字段优先级排序
   */
  private static prioritizeFields(entries: [string, any][]): [string, any][] {
    const priorityKeys = [
      'id', 'model', 'messages', 'content', 'choices', 'usage',
      'prompt', 'completion', 'input', 'output', 'config'
    ];

    return entries.sort(([keyA], [keyB]) => {
      const priorityA = priorityKeys.indexOf(keyA);
      const priorityB = priorityKeys.indexOf(keyB);

      if (priorityA !== -1 && priorityB !== -1) {
        return priorityA - priorityB;
      }
      if (priorityA !== -1) return -1;
      if (priorityB !== -1) return 1;

      // 按字段名排序
      return keyA.localeCompare(keyB);
    });
  }

  /**
   * 添加截断标记
   */
  private static addTruncationMarker(
    data: string,
    type: string,
    omitted: number
  ): string {
    const marker = `\n\n[TRUNCATED: ${type} - ${omitted} omitted]`;
    return data + marker;
  }

  /**
   * 获取数据大小（估算）
   */
  private static getDataSize(data: any): number {
    if (typeof data === 'string') {
      return data.length;
    } else if (Array.isArray(data)) {
      return data.reduce((sum, item) => sum + this.getDataSize(item), 0);
    } else if (typeof data === 'object' && data !== null) {
      return Object.values(data).reduce((sum, item) => sum + this.getDataSize(item), 0);
    }
    return JSON.stringify(data).length;
  }

  /**
   * 检测大型消息内容
   */
  static detectLargeContent(data: any, threshold: number = 5000): {
    isLarge: boolean;
    largeFields: string[];
    totalSize: number;
  } {
    const largeFields: string[] = [];
    let totalSize = 0;

    const checkSize = (value: any, path: string = '') => {
      if (typeof value === 'string') {
        if (value.length > threshold) {
          largeFields.push(`${path} (${value.length} chars)`);
        }
        totalSize += value.length;
      } else if (Array.isArray(value)) {
        if (value.length > 100) { // 大数组
          largeFields.push(`${path} (array[${value.length}])`);
        }
        value.forEach((item, index) => {
          checkSize(item, `${path}[${index}]`);
        });
      } else if (typeof value === 'object' && value !== null) {
        Object.entries(value).forEach(([key, val]) => {
          checkSize(val, path ? `${path}.${key}` : key);
        });
      }
    };

    checkSize(data);

    return {
      isLarge: totalSize > threshold || largeFields.length > 0,
      largeFields,
      totalSize
    };
  }

  /**
   * 获取智能截断建议
   */
  static getTruncationSuggestions(data: any): {
    recommended: TruncationOptions;
    reason: string;
    detectedIssues: string[];
  } {
    const detection = this.detectLargeContent(data);
    const issues: string[] = [];

    let suggestions: TruncationOptions = {
      maxLength: 10000,
      maxLines: 50,
      maxArrayItems: 20,
      maxObjectDepth: 5,
      preserveStructure: true,
      showTruncationInfo: true
    };

    if (detection.totalSize > 50000) {
      issues.push('数据总量超过50KB，建议启用严格截断');
      suggestions = {
        ...suggestions,
        maxLength: 5000,
        maxLines: 30,
        maxArrayItems: 10
      };
    } else if (detection.totalSize > 20000) {
      issues.push('数据总量超过20KB，建议启用中度截断');
      suggestions = {
        ...suggestions,
        maxLength: 8000,
        maxLines: 40,
        maxArrayItems: 15
      };
    }

    if (detection.largeFields.some(field => field.includes('messages'))) {
      issues.push('检测到大型messages字段，建议优先截断');
    }

    return {
      recommended: suggestions,
      reason: issues.length > 0 ? issues.join('; ') : '数据大小正常，无需特殊处理',
      detectedIssues: issues
    };
  }
}