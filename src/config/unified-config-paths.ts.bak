import fs from 'fs';
import path from 'path';
import { homedir } from 'os';

/**
 * Unified Configuration Path Resolution System
 *
 * This system provides a single source of truth for all RouteCodex configuration
 * path resolution, supporting multiple discovery methods while maintaining backward
 * compatibility with existing environment variables and file locations.
 */

export interface ConfigPathOptions {
  /** Explicit preferred path (highest priority) */
  preferredPath?: string;
  /** Specific configuration file name to look for */
  configName?: string;
  /** Whether to use strict mode (fail if no config found) */
  strict?: boolean;
  /** Whether to allow directory scanning for config files */
  allowDirectoryScan?: boolean;
  /** Base directory for configuration resolution */
  baseDir?: string;
}

export interface ConfigPathResult {
  /** The resolved configuration path */
  resolvedPath: string;
  /** Source of the resolution */
  source: 'explicit' | 'environment' | 'default' | 'fallback';
  /** Type of configuration target */
  configType: 'file' | 'directory';
  /** Whether the path exists */
  exists: boolean;
  /** Warning messages if any */
  warnings?: string[];
  /** Information about resolution process */
  resolutionInfo?: {
    candidates: string[];
    environmentVariables: Record<string, string | undefined>;
    scannedDirectories?: string[];
  };
}

/**
 * Environment variable precedence order for configuration paths
 */
const ENVIRONMENT_VARIABLES = [
  'ROUTECODEX_CONFIG_PATH',  // Primary environment variable
  'ROUTECODEX_CONFIG'        // Alternative format
];

/**
 * Default configuration file preferences for directory scanning
 */
const CONFIG_FILE_PREFERENCES = [
  'default.json',      // Default/primary configuration
  'glm.json',          // GLM provider configuration
  'routecodex.json',   // Legacy format
  'config.json',       // Generic config name
  'lmstudio.json',     // LM Studio configuration
  'qwen.json',         // Qwen provider configuration
];

/**
 * Default configuration directory structure
 */
// const DEFAULT_CONFIG_DIRECTORIES = [
//   path.join(homedir(), '.routecodex', 'config'),  // Primary config directory
//   path.join(homedir(), '.routecodex'),               // Legacy directory
//   path.join(process.cwd(), 'config'),               // Current directory config
//   process.cwd(),                                    // Current directory
// ];

/**
 * Unified configuration path resolver
 */
export class UnifiedConfigPathResolver {
  /**
   * Resolve configuration path using unified precedence order
   */
  static resolveConfigPath(options: ConfigPathOptions = {}): ConfigPathResult {
    const {
      preferredPath,
      configName,
      strict = false,
      allowDirectoryScan = true,
      baseDir = process.cwd()
    } = options;

    const warnings: string[] = [];
    const candidates: string[] = [];
    const scannedDirectories: string[] = [];
    const envVars: Record<string, string | undefined> = {};

    // Collect environment variables
    ENVIRONMENT_VARIABLES.forEach(envVar => {
      envVars[envVar] = process.env[envVar];
    });

    // Build candidate list in precedence order
    const candidateList = this.buildCandidateList({
      preferredPath,
      configName,
      allowDirectoryScan,
      baseDir,
      envVars
    });

    candidates.push(...candidateList);

    // Try to resolve from candidates
    for (const candidate of candidateList) {
      try {
        const expandedPath = this.expandPath(candidate);
        if (!expandedPath) {continue;}

        if (fs.existsSync(expandedPath)) {
          const stat = fs.statSync(expandedPath);

          if (stat.isFile()) {
            return {
              resolvedPath: expandedPath,
              source: this.determineSource(candidate, preferredPath, envVars),
              configType: 'file',
              exists: true,
              warnings: warnings.length > 0 ? warnings : undefined,
              resolutionInfo: {
                candidates,
                environmentVariables: envVars,
                scannedDirectories
              }
            };
          }

          if (stat.isDirectory() && allowDirectoryScan) {
            const configFile = this.scanConfigDirectory(expandedPath, configName);
            if (configFile) {
              scannedDirectories.push(expandedPath);
              return {
                resolvedPath: configFile,
                source: this.determineSource(candidate, preferredPath, envVars),
                configType: 'file',
                exists: true,
                warnings: warnings.length > 0 ? warnings : undefined,
                resolutionInfo: {
                  candidates,
                  environmentVariables: envVars,
                  scannedDirectories
                }
              };
            }
          }
        }
      } catch (error) {
        // Log filesystem access errors but continue
        if (strict) {
          throw new Error(`Filesystem error accessing ${candidate}: ${error}`);
        }
        warnings.push(`Could not access ${candidate}: ${error}`);
      }
    }

    // No configuration found
    if (strict) {
      throw new Error(`No configuration file found. Searched: ${candidates.join(', ')}`);
    }

    // Return fallback path
    const fallbackPath = configName
      ? path.join(this.getDefaultConfigDirectory(), configName)
      : path.join(this.getDefaultConfigDirectory(), 'config.json');

    return {
      resolvedPath: fallbackPath,
      source: 'fallback',
      configType: 'file',
      exists: false,
      warnings: [
        'No configuration file found, using fallback path',
        ...warnings
      ],
      resolutionInfo: {
        candidates,
        environmentVariables: envVars,
        scannedDirectories
      }
    };
  }

  /**
   * Get the default configuration directory
   */
  static getDefaultConfigDirectory(): string {
    return path.join(homedir(), '.routecodex', 'config');
  }

  /**
   * Scan a directory for configuration files
   */
  static scanConfigDirectory(directory: string, preferredName?: string): string | null {
    try {
      const entries = fs.readdirSync(directory)
        .filter(file => file.toLowerCase().endsWith('.json'))
        .map(file => ({
          name: file,
          mtime: fs.statSync(path.join(directory, file)).mtimeMs,
          isPreferred: preferredName ? file.toLowerCase() === preferredName.toLowerCase() : false
        }));

      if (entries.length === 0) {
        return null;
      }

      // Prioritize preferred name if specified
      if (preferredName) {
        const preferred = entries.find(entry => entry.isPreferred);
        if (preferred) {
          return path.join(directory, preferred.name);
        }
      }

      // Look for preferred configuration names
      for (const preferredName of CONFIG_FILE_PREFERENCES) {
        const found = entries.find(entry => entry.name.toLowerCase() === preferredName.toLowerCase());
        if (found) {
          return path.join(directory, found.name);
        }
      }

      // Fall back to most recently modified file
      entries.sort((a, b) => b.mtime - a.mtime);
      return path.join(directory, entries[0].name);

    } catch (error) {
      // Directory doesn't exist or isn't accessible
      return null;
    }
  }

  /**
   * Build candidate list for configuration resolution
   */
  private static buildCandidateList(options: {
    preferredPath?: string;
    configName?: string;
    allowDirectoryScan: boolean;
    baseDir: string;
    envVars: Record<string, string | undefined>;
  }): string[] {
    const { preferredPath, configName, allowDirectoryScan, baseDir, envVars } = options;
    const candidates: string[] = [];

    // 1. Explicit preferred path (highest priority)
    if (preferredPath) {
      candidates.push(preferredPath);
    }

    // 2. Environment variables
    ENVIRONMENT_VARIABLES.forEach(envVar => {
      if (envVars[envVar]) {
        candidates.push(envVars[envVar]!);
      }
    });

    // 3. Current directory configurations
    if (configName) {
      candidates.push(path.join(baseDir, configName));
      candidates.push(path.join(baseDir, 'config', configName));
    } else {
      candidates.push(path.join(baseDir, 'routecodex.json'));
      candidates.push(path.join(baseDir, 'config', 'routecodex.json'));
    }

    // 4. Home directory configurations
    if (configName) {
      candidates.push(path.join(homedir(), '.routecodex', configName));
      candidates.push(path.join(homedir(), '.routecodex', 'config', configName));
    } else {
      candidates.push(path.join(homedir(), '.routecodex', 'config.json'));
      candidates.push(path.join(homedir(), '.routecodex', 'routecodex.json'));
    }

    // 5. Default configuration directory (with scanning)
    const defaultConfigDir = this.getDefaultConfigDirectory();
    if (allowDirectoryScan) {
      candidates.push(defaultConfigDir);
    } else if (configName) {
      candidates.push(path.join(defaultConfigDir, configName));
    } else {
      candidates.push(path.join(defaultConfigDir, 'default.json'));
    }

    return candidates;
  }

  /**
   * Expand home directory in path
   */
  private static expandPath(pathString: string): string | null {
    if (!pathString) {return null;}
    return pathString.startsWith('~')
      ? pathString.replace('~', homedir())
      : pathString;
  }

  /**
   * Determine the source of a resolved path
   */
  private static determineSource(
    path: string,
    preferredPath: string | undefined,
    envVars: Record<string, string | undefined>
  ): 'explicit' | 'environment' | 'default' {
    if (preferredPath && path === preferredPath) {
      return 'explicit';
    }

    if (Object.values(envVars).includes(path)) {
      return 'environment';
    }

    return 'default';
  }

  /**
   * Validate that a configuration path is accessible
   */
  static validateConfigPath(configPath: string): { valid: boolean; error?: string } {
    try {
      const expandedPath = this.expandPath(configPath);
      if (!expandedPath) {
        return { valid: false, error: 'Invalid path format' };
      }

      if (!fs.existsSync(expandedPath)) {
        return { valid: false, error: 'Path does not exist' };
      }

      const stat = fs.statSync(expandedPath);
      if (!stat.isFile() && !stat.isDirectory()) {
        return { valid: false, error: 'Path is neither a file nor a directory' };
      }

      return { valid: true };
    } catch (error) {
      return {
        valid: false,
        error: `Validation error: ${error instanceof Error ? error.message : String(error)}`
      };
    }
  }

  /**
   * Get all available configuration files in the standard directories
   */
  static getAvailableConfigs(): { directory: string; files: string[] }[] {
    const results: { directory: string; files: string[] }[] = [];
    const directories = [
      this.getDefaultConfigDirectory(),
      path.join(homedir(), '.routecodex'),
      path.join(process.cwd(), 'config')
    ];

    directories.forEach(dir => {
      try {
        if (fs.existsSync(dir)) {
          const files = fs.readdirSync(dir)
            .filter(file => file.toLowerCase().endsWith('.json'))
            .sort();
          results.push({ directory: dir, files });
        }
      } catch {
        // Ignore inaccessible directories
      }
    });

    return results;
  }

  /**
   * Ensure the default configuration directory exists
   */
  static ensureConfigDirectory(): string {
    const configDir = this.getDefaultConfigDirectory();

    try {
      if (!fs.existsSync(configDir)) {
        fs.mkdirSync(configDir, { recursive: true });
      }
      return configDir;
    } catch (error) {
      throw new Error(`Failed to create config directory: ${error}`);
    }
  }
}
