#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';

const cwd = process.cwd();
const pkgPath = path.join(cwd, 'package.json');
const lockPath = path.join(cwd, 'package-lock.json');
const outPath = path.join(cwd, 'src', 'build-info.ts');

const mode = String(process.env.BUILD_MODE || process.env.RCC_BUILD_MODE || 'release').toLowerCase();
const valid = new Set(['dev', 'release']);
const buildMode = valid.has(mode) ? mode : 'release';

const skipAutoBump = ['1', 'true', 'yes'].includes(
  String(process.env.ROUTECODEX_SKIP_AUTO_BUMP || process.env.BUILD_SKIP_AUTO_BUMP || '').trim().toLowerCase()
);

const pkg = readJson(pkgPath);
let version = typeof pkg?.version === 'string' ? pkg.version : '0.0.0';

if (!skipAutoBump) {
  const nextVersion = bumpPatchVersion(version);
  if (nextVersion !== version) {
    version = nextVersion;
    if (pkg) {
      pkg.version = nextVersion;
      writeJson(pkgPath, pkg);
      updatePackageLock(lockPath, nextVersion);
      console.log(`[build-info] auto-bump version → ${nextVersion}`);
    }
  }
}

const content = `// Auto-generated by scripts/gen-build-info.mjs
export interface BuildInfo { mode: 'dev' | 'release'; version: string; buildTime: string }
export const buildInfo: BuildInfo = {
  mode: '${buildMode}',
  version: '${version}',
  buildTime: '${new Date().toISOString()}'
};
`;

fs.mkdirSync(path.dirname(outPath), { recursive: true });
fs.writeFileSync(outPath, content, 'utf-8');
console.log(`[build-info] mode=${buildMode} version=${version} → ${outPath}`);

function readJson(targetPath) {
  try {
    return JSON.parse(fs.readFileSync(targetPath, 'utf-8'));
  } catch {
    return undefined;
  }
}

function writeJson(targetPath, data) {
  fs.writeFileSync(targetPath, `${JSON.stringify(data, null, 2)}\n`, 'utf-8');
}

function bumpPatchVersion(input) {
  if (!input || typeof input !== 'string') {
    return '0.0.001';
  }
  const segments = input.split('.');
  while (segments.length < 3) {
    segments.push('0');
  }
  const [major, minor, patchRaw] = segments;
  const parsedPatch = Number.parseInt(patchRaw, 10);
  const nextPatch = Number.isFinite(parsedPatch) ? parsedPatch + 1 : 1;
  const formattedPatch = String(nextPatch).padStart(3, '0');
  return `${major}.${minor}.${formattedPatch}`;
}

function updatePackageLock(targetPath, version) {
  const lock = readJson(targetPath);
  if (!lock) {
    return;
  }
  lock.version = version;
  if (lock.packages && lock.packages['']) {
    lock.packages[''].version = version;
  }
  writeJson(targetPath, lock);
}
