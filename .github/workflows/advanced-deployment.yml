name: Advanced Deployment Strategies

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      deployment_strategy:
        description: 'Deployment strategy'
        required: true
        type: choice
        options: [ 'blue-green', 'canary', 'rolling', 'recreate' ]
        default: 'canary'
      canary_percentage:
        description: 'Canary percentage (for canary deployment)'
        required: false
        type: number
        default: 10
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options: [ 'staging', 'production' ]
        default: 'staging'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOYMENT_TIMEOUT: 600  # 10分钟超时

jobs:
  # 部署前分析和准备
  deployment-analysis:
    runs-on: ubuntu-latest
    outputs:
      strategy: ${{ steps.analyze.outputs.strategy }}
      risk-level: ${{ steps.analyze.outputs.risk-level }}
      rollback-enabled: ${{ steps.analyze.outputs.rollback-enabled }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Analyze deployment risk
      id: analyze
      run: |
        # 分析部署风险
        CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | wc -l)
        
        if [ $CHANGED_FILES -gt 50 ]; then
          RISK_LEVEL="high"
          STRATEGY="canary"
        elif [ $CHANGED_FILES -gt 20 ]; then
          RISK_LEVEL="medium"
          STRATEGY="rolling"
        else
          RISK_LEVEL="low"
          STRATEGY="rolling"
        fi
        
        # 检查是否有破坏性变更
        if git log --oneline HEAD~1 HEAD | grep -i "breaking\|major\|incompatible"; then
          RISK_LEVEL="high"
          STRATEGY="blue-green"
        fi
        
        echo "strategy=${STRATEGY}" >> $GITHUB_OUTPUT
        echo "risk-level=${RISK_LEVEL}" >> $GITHUB_OUTPUT
        echo "rollback-enabled=true" >> $GITHUB_OUTPUT
        
        echo "Deployment analysis completed:"
        echo "- Strategy: ${STRATEGY}"
        echo "- Risk Level: ${RISK_LEVEL}"
        echo "- Rollback Enabled: true"

    - name: Generate deployment manifest
      run: |
        # 生成部署清单
        cat > deployment-manifest.json << EOF
        {
          "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
          "commit": "${{ github.sha }}",
          "version": "$(node -p "require('./package.json').version")",
          "strategy": "${{ steps.analyze.outputs.strategy }}",
          "risk-level": "${{ steps.analyze.outputs.risk-level }}",
          "environment": "${{ github.event.inputs.environment || 'staging' }}",
          "triggered-by": "${{ github.actor }}"
        }
        EOF
        
        cat deployment-manifest.json

  # 构建和准备容器镜像
  build-and-prepare:
    runs-on: ubuntu-latest
    needs: [deployment-analysis]
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Sign container image
      uses: sigstore/cosign-installer@v3
      run: |
        cosign sign --yes ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  # 蓝绿部署
  blue-green-deployment:
    runs-on: ubuntu-latest
    needs: [deployment-analysis, build-and-prepare]
    if: |
      (github.event.inputs.deployment_strategy == 'blue-green') ||
      (needs.deployment-analysis.outputs.strategy == 'blue-green')
    environment:
      name: ${{ github.event.inputs.environment }}-blue-green
      url: https://${{ github.event.inputs.environment }}.routecodex.com
    
    steps:
    - name: Deploy Blue Environment
      run: |
        echo "Deploying to BLUE environment..."
        # 部署蓝色环境
        helm upgrade --install routecodex-blue ./helm/routecodex \
          --namespace ${{ github.event.inputs.environment }} \
          --set image.tag=${{ github.sha }} \
          --set deployment.color=blue \
          --set ingress.enabled=false \
          --wait --timeout=${{ env.DEPLOYMENT_TIMEOUT }}s

    - name: Health Check Blue Environment
      run: |
        echo "Health checking BLUE environment..."
        # 等待蓝色环境健康
        for i in {1..30}; do
          if curl -f http://blue.${{ github.event.inputs.environment }}.routecodex.com/health; then
            echo "✅ BLUE environment is healthy"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "❌ BLUE environment health check failed"
            exit 1
          fi
          sleep 10
        done

    - name: Switch Traffic to Blue
      run: |
        echo "Switching traffic to BLUE environment..."
        # 切换流量到蓝色环境
        kubectl patch service routecodex-service \
          -n ${{ github.event.inputs.environment }} \
          -p '{"spec":{"selector":{"color":"blue"}}}'

    - name: Deploy Green Environment (Backup)
      run: |
        echo "Deploying GREEN environment as backup..."
        # 部署绿色环境作为备份
        helm upgrade --install routecodex-green ./helm/routecodex \
          --namespace ${{ github.event.inputs.environment }} \
          --set image.tag=${{ needs.build-and-prepare.outputs.image-tag }} \
          --set deployment.color=green \
          --set ingress.enabled=false \
          --wait --timeout=${{ env.DEPLOYMENT_TIMEOUT }}s

    - name: Validate Deployment
      run: |
        echo "Validating blue-green deployment..."
        # 验证部署成功
        TRAFFIC_CHECK=$(kubectl get service routecodex-service -n ${{ github.event.inputs.environment }} -o jsonpath='{.spec.selector.color}')
        if [ "$TRAFFIC_CHECK" != "blue" ]; then
          echo "❌ Traffic not properly switched to blue environment"
          exit 1
        fi
        echo "✅ Blue-green deployment successful"

  # 金丝雀部署
  canary-deployment:
    runs-on: ubuntu-latest
    needs: [deployment-analysis, build-and-prepare]
    if: |
      (github.event.inputs.deployment_strategy == 'canary') ||
      (needs.deployment-analysis.outputs.strategy == 'canary')
    environment:
      name: ${{ github.event.inputs.environment }}-canary
      url: https://${{ github.event.inputs.environment }}.routecodex.com
    
    steps:
    - name: Deploy Canary Version
      run: |
        echo "Deploying canary version (${{ github.event.inputs.canary_percentage || 10 }}%)..."
        CANARY_WEIGHT=${{ github.event.inputs.canary_percentage || 10 }}
        STABLE_WEIGHT=$((100 - CANARY_WEIGHT))
        
        # 部署金丝雀版本
        helm upgrade --install routecodex-canary ./helm/routecodex \
          --namespace ${{ github.event.inputs.environment }} \
          --set image.tag=${{ github.sha }} \
          --set deployment.canary=true \
          --set ingress.canary.weight=$CANARY_WEIGHT \
          --set replicaCount=1 \
          --wait --timeout=${{ env.DEPLOYMENT_TIMEOUT }}s

    - name: Monitor Canary Metrics
      run: |
        echo "Monitoring canary metrics for 5 minutes..."
        START_TIME=$(date +%s)
        
        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))
          
          if [ $ELAPSED -gt 300 ]; then  # 5分钟监控
            break
          fi
          
          # 获取金丝雀指标
          CANARY_REQUESTS=$(kubectl logs -n ${{ github.event.inputs.environment }} -l app=routecodex,canary=true --tail=100 | wc -l)
          CANARY_ERRORS=$(kubectl logs -n ${{ github.event.inputs.environment }} -l app=routecodex,canary=true --tail=100 | grep -i error | wc -l)
          
          ERROR_RATE=$((CANARY_ERRORS * 100 / CANARY_REQUESTS))
          
          echo "Canary error rate: ${ERROR_RATE}%"
          
          if [ $ERROR_RATE -gt 5 ]; then
            echo "❌ Canary error rate too high (${ERROR_RATE}%) - rolling back"
            exit 1
          fi
          
          sleep 30
        done

    - name: Promote Canary
      run: |
        echo "Promoting canary to full deployment..."
        # 逐步增加金丝雀流量
        for weight in 25 50 75 100; do
          kubectl patch ingress routecodex-ingress \
            -n ${{ github.event.inputs.environment }} \
            --type='json' \
            -p="[{'op': 'replace', 'path': '/metadata/annotations/nginx.ingress.kubernetes.io~1canary-weight', 'value': '$weight'}]"
          
          echo "Canary traffic increased to $weight%"
          sleep 60
        done

    - name: Complete Canary Deployment
      run: |
        echo "Completing canary deployment..."
        # 移除金丝雀标签，成为主要部署
        helm upgrade --install routecodex ./helm/routecodex \
          --namespace ${{ github.event.inputs.environment }} \
          --set image.tag=${{ github.sha }} \
          --set deployment.canary=false \
          --wait --timeout=${{ env.DEPLOYMENT_TIMEOUT }}s

  # 滚动部署
  rolling-deployment:
    runs-on: ubuntu-latest
    needs: [deployment-analysis, build-and-prepare]
    if: |
      (github.event.inputs.deployment_strategy == 'rolling') ||
      (needs.deployment-analysis.outputs.strategy == 'rolling')
    environment:
      name: ${{ github.event.inputs.environment }}-rolling
      url: https://${{ github.event.inputs.environment }}.routecodex.com
    
    strategy:
      matrix:
        batch: [1, 2, 3]  # 分3批滚动更新
    
    steps:
    - name: Rolling Update Batch ${{ matrix.batch }}
      run: |
        echo "Performing rolling update - batch ${{ matrix.batch }}/3"
        
        # 获取当前部署状态
        CURRENT_REPLICAS=$(kubectl get deployment routecodex -n ${{ github.event.inputs.environment }} -o jsonpath='{.spec.replicas}')
        BATCH_SIZE=$((CURRENT_REPLICAS / 3))
        
        if [ $BATCH_SIZE -lt 1 ]; then
          BATCH_SIZE=1
        fi
        
        echo "Updating $BATCH_SIZE replicas in batch ${{ matrix.batch }}"
        
        # 执行滚动更新
        kubectl patch deployment routecodex \
          -n ${{ github.event.inputs.environment }} \
          -p '{"spec":{"template":{"spec":{"containers":[{"name":"routecodex","image":"${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"}]}}}}'
        
        # 等待滚动更新完成
        kubectl rollout status deployment/routecodex \
          -n ${{ github.event.inputs.environment }} \
          --timeout=${{ env.DEPLOYMENT_TIMEOUT }}s

    - name: Health Check After Batch
      run: |
        echo "Health checking after batch ${{ matrix.batch }}..."
        
        # 检查部署状态
        ROLLOUT_STATUS=$(kubectl rollout status deployment/routecodex -n ${{ github.event.inputs.environment }} --timeout=30s)
        
        if [ $? -eq 0 ]; then
          echo "✅ Rolling update batch ${{ matrix.batch }} completed successfully"
        else
          echo "❌ Rolling update batch ${{ matrix.batch }} failed"
          exit 1
        fi
        
        # 等待一段时间再开始下一批
        if [ ${{ matrix.batch }} -lt 3 ]; then
          echo "Waiting before next batch..."
          sleep 60
        fi

  # 部署后验证和监控
  post-deployment-validation:
    runs-on: ubuntu-latest
    needs: [blue-green-deployment, canary-deployment, rolling-deployment]
    if: always() && (needs.blue-green-deployment.result == 'success' || needs.canary-deployment.result == 'success' || needs.rolling-deployment.result == 'success')
    
    steps:
    - name: Comprehensive Health Check
      run: |
        echo "Performing comprehensive health check..."
        
        # 检查应用健康状态
        for i in {1..10}; do
          if curl -f https://${{ github.event.inputs.environment }}.routecodex.com/health; then
            echo "✅ Application health check passed"
            break
          fi
          if [ $i -eq 10 ]; then
            echo "❌ Application health check failed"
            exit 1
          fi
          sleep 30
        done

    - name: Performance Validation
      run: |
        echo "Validating performance after deployment..."
        
        # 测试关键端点性能
        START_TIME=$(date +%s%N)
        curl -s https://${{ github.event.inputs.environment }}.routecodex.com/health > /dev/null
        END_TIME=$(date +%s%N)
        
        RESPONSE_TIME=$((($END_TIME - $START_TIME) / 1000000))
        echo "Health check response time: ${RESPONSE_TIME}ms"
        
        if [ $RESPONSE_TIME -gt 5000 ]; then
          echo "❌ Response time too high: ${RESPONSE_TIME}ms"
          exit 1
        fi

    - name: Error Rate Monitoring
      run: |
        echo "Monitoring error rates..."
        
        # 监控5分钟内的错误率
        START_TIME=$(date +%s)
        ERROR_COUNT=0
        TOTAL_REQUESTS=0
        
        while true; do
          CURRENT_TIME=$(date +%s)
          ELAPSED=$((CURRENT_TIME - START_TIME))
          
          if [ $ELAPSED -gt 300 ]; then  # 5分钟
            break
          fi
          
          # 模拟请求并检查响应
          RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://${{ github.event.inputs.environment }}.routecodex.com/health)
          TOTAL_REQUESTS=$((TOTAL_REQUESTS + 1))
          
          if [ "$RESPONSE_CODE" != "200" ]; then
            ERROR_COUNT=$((ERROR_COUNT + 1))
          fi
          
          sleep 10
        done
        
        ERROR_RATE=$((ERROR_COUNT * 100 / TOTAL_REQUESTS))
        echo "Error rate: ${ERROR_RATE}%"
        
        if [ $ERROR_RATE -gt 5 ]; then
          echo "❌ Error rate too high: ${ERROR_RATE}%"
          exit 1
        fi

    - name: Resource Usage Check
      run: |
        echo "Checking resource usage..."
        
        # 获取部署的Pod列表
        PODS=$(kubectl get pods -n ${{ github.event.inputs.environment }} -l app=routecodex -o jsonpath='{.items[*].metadata.name}')
        
        for pod in $PODS; do
          echo "Checking resource usage for pod: $pod"
          
          # 获取CPU使用率
          CPU_USAGE=$(kubectl top pod $pod -n ${{ github.event.inputs.environment }} --no-headers | awk '{print $2}' | sed 's/m//')
          
          # 获取内存使用率
          MEMORY_USAGE=$(kubectl top pod $pod -n ${{ github.event.inputs.environment }} --no-headers | awk '{print $3}' | sed 's/Mi//')
          
          echo "Pod $pod - CPU: ${CPU_USAGE}m, Memory: ${MEMORY_USAGE}Mi"
          
          # 检查是否超过阈值
          if [ $CPU_USAGE -gt 500 ]; then
            echo "⚠️  High CPU usage detected: ${CPU_USAGE}m"
          fi
          
          if [ $MEMORY_USAGE -gt 512 ]; then
            echo "⚠️  High memory usage detected: ${MEMORY_USAGE}Mi"
          fi
        done

    - name: Generate Deployment Report
      run: |
        echo "Generating deployment report..."
        
        cat > deployment-report.md << EOF
        # Deployment Report
        
        **Deployment ID**: ${{ github.sha }}
        **Timestamp**: $(date -u +%Y-%m-%dT%H:%M:%SZ)
        **Strategy**: ${{ needs.deployment-analysis.outputs.strategy }}
        **Environment**: ${{ github.event.inputs.environment }}
        **Status**: ✅ SUCCESS
        
        ## Deployment Details
        - **Image**: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        - **Duration**: ${{ env.DEPLOYMENT_TIMEOUT }}s timeout
        - **Risk Level**: ${{ needs.deployment-analysis.outputs.risk-level }}
        
        ## Validation Results
        - ✅ Health checks passed
        - ✅ Performance within acceptable limits
        - ✅ Error rate below threshold
        - ✅ Resource usage normal
        
        ## Next Steps
        - Monitor application for 24 hours
        - Review performance metrics
        - Check error logs
        
        EOF
        
        cat deployment-report.md

    - name: Upload Deployment Report
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report-${{ github.sha }}
        path: deployment-report.md
        retention-days: 90

  # 自动回滚（如果部署失败）
  auto-rollback:
    runs-on: ubuntu-latest
    needs: [post-deployment-validation]
    if: failure()
    
    steps:
    - name: Initiate Rollback
      run: |
        echo "⚠️  Deployment validation failed - initiating rollback..."
        
        # 获取上一个稳定版本
        PREVIOUS_REVISION=$(kubectl rollout history deployment/routecodex -n ${{ github.event.inputs.environment }} | tail -n 2 | head -n 1 | awk '{print $1}')
        
        echo "Rolling back to revision $PREVIOUS_REVISION..."
        
        # 执行回滚
        kubectl rollout undo deployment/routecodex \
          -n ${{ github.event.inputs.environment }} \
          --to-revision=$PREVIOUS_REVISION
        
        # 等待回滚完成
        kubectl rollout status deployment/routecodex \
          -n ${{ github.event.inputs.environment }} \
          --timeout=300s
        
        echo "✅ Rollback completed successfully"

    - name: Send Rollback Alert
      run: |
        echo "🚨 DEPLOYMENT ROLLBACK INITIATED"
        echo "Deployment SHA: ${{ github.sha }}"
        echo "Environment: ${{ github.event.inputs.environment }}"
        echo "Reason: Deployment validation failed"
        
        # 这里可以集成通知系统（Slack, Teams, etc.）
        
  # 清理和归档
  cleanup:
    runs-on: ubuntu-latest
    needs: [post-deployment-validation, auto-rollback]
    if: always()
    
    steps:
    - name: Cleanup Old Deployments
      run: |
        echo "Cleaning up old deployments..."
        
        # 保留最近5个版本，删除旧的
        kubectl get deployments -n ${{ github.event.inputs.environment }} -o name | \
          grep -v "routecodex$" | \
          head -n -5 | \
          xargs -r kubectl delete -n ${{ github.event.inputs.environment }}
        
        echo "Cleanup completed"