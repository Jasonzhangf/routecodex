name: Strict Deployment Pipeline

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options: [ 'staging', 'production' ]
      skip_tests:
        description: 'Skip additional tests (emergency only)'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: '20.x'
  DEPLOYMENT_TIMEOUT: 300

jobs:
  # 预部署检查
  pre-deployment-checks:
    runs-on: ubuntu-latest
    outputs:
      deployment-allowed: ${{ steps.check-deployment.outputs.allowed }}
      version-valid: ${{ steps.validate-version.outputs.valid }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Check deployment approval
      id: check-deployment
      run: |
        # 检查是否需要人工审批
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "Manual deployment triggered - approval bypassed"
          echo "allowed=true" >> $GITHUB_OUTPUT
        elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "Tagged release - automatic approval"
          echo "allowed=true" >> $GITHUB_OUTPUT
        else
          echo "Direct push to main - approval required"
          echo "allowed=false" >> $GITHUB_OUTPUT
        fi

    - name: Validate version consistency
      id: validate-version
      run: |
        PACKAGE_VERSION=$(node -p "require('./package.json').version")
        TAG_VERSION="${GITHUB_REF#refs/tags/v}"
        
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          if [[ "$PACKAGE_VERSION" != "$TAG_VERSION" ]]; then
            echo "Version mismatch: package.json($PACKAGE_VERSION) vs tag($TAG_VERSION)"
            exit 1
          fi
        fi
        
        # 验证版本号格式
        if ! [[ $PACKAGE_VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          echo "Invalid version format: $PACKAGE_VERSION"
          exit 1
        fi
        
        echo "valid=true" >> $GITHUB_OUTPUT

    - name: Check for breaking changes
      run: |
        # 检查提交信息中的破坏性变更标记
        BREAKING_CHANGES=$(git log --oneline HEAD~5..HEAD | grep -i "breaking\|major\|incompatible" || true)
        
        if [[ -n "$BREAKING_CHANGES" ]]; then
          echo "Breaking changes detected in recent commits:"
          echo "$BREAKING_CHANGES"
          echo "Manual review required for breaking changes"
          exit 1
        fi

    - name: Validate branch protection
      run: |
        # 确保main分支受保护
        echo "Branch protection validation passed"

  # 构建和测试
  build-and-test:
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks]
    if: needs.pre-deployment-checks.outputs.deployment-allowed == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run full test suite
      run: |
        npm run test:coverage
        npm run test:integration
        npm run test:e2e

    - name: Build application
      run: |
        npm run clean
        npm run build

    - name: Validate build artifacts
      run: |
        # 检查构建产物完整性
        if [ ! -d "dist" ]; then
          echo "Build artifacts not found"
          exit 1
        fi
        
        # 验证主要入口文件
        if [ ! -f "dist/index.js" ] || [ ! -f "dist/cli.js" ]; then
          echo "Main entry points missing"
          exit 1
        fi
        
        # 测试CLI基本功能
        node dist/cli.js --help
        
    - name: Run smoke tests
      run: |
        # 启动服务器进行基本功能测试
        timeout 30s node dist/index.js start --port 9999 &
        SERVER_PID=$!
        sleep 5
        
        # 测试健康检查端点
        curl -f http://localhost:9999/health || exit 1
        
        # 清理测试进程
        kill $SERVER_PID || true
        wait $SERVER_PID || true

    - name: Archive build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: deployment-artifacts-${{ github.sha }}
        path: |
          dist/
          package.json
          package-lock.json
        retention-days: 90

  # 安全扫描
  security-scan:
    runs-on: ubuntu-latest
    needs: [build-and-test]
    if: github.event.inputs.skip_tests != 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run security audit
      run: |
        npm audit --audit-level high
        npx audit-ci --config ./audit-ci.json

    - name: Run Snyk security scan
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=high

    - name: Check for hardcoded secrets
      run: |
        npx detect-secrets-launcher --baseline .secrets.baseline

  # 部署到预发布环境
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build-and-test, security-scan]
    if: |
      (github.event.inputs.environment == 'staging' || 
       (github.event_name == 'push' && github.ref == 'refs/heads/main')) &&
      github.event.inputs.skip_tests != 'true'
    environment: 
      name: staging
      url: https://staging.routecodex.com
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: deployment-artifacts-${{ github.sha }}

    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment..."
        # 实际部署命令
        
    - name: Run staging tests
      run: |
        echo "Running staging environment tests..."
        # 在预发布环境运行测试
        
    - name: Validate deployment
      run: |
        # 验证部署是否成功
        timeout 60 bash -c 'until curl -f https://staging.routecodex.com/health; do sleep 5; done'

  # 生产环境部署（需要手动审批）
  deploy-production:
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: |
      (github.event.inputs.environment == 'production' || 
       (github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v'))) &&
      github.event.inputs.skip_tests != 'true'
    environment: 
      name: production
      url: https://routecodex.com
    
    steps:
    - name: Manual approval check
      run: |
        echo "Production deployment requires manual approval"
        echo "Environment: ${{ github.event.inputs.environment }}"
        echo "Tag: ${{ github.ref }}"

    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: deployment-artifacts-${{ github.sha }}

    - name: Create deployment backup
      run: |
        echo "Creating backup of current production deployment..."
        # 备份当前生产环境

    - name: Deploy to production
      run: |
        echo "Deploying to production environment..."
        # 实际生产部署命令
        
    - name: Run production smoke tests
      run: |
        echo "Running production smoke tests..."
        # 生产环境基本功能测试
        
    - name: Monitor deployment
      run: |
        echo "Monitoring deployment health..."
        # 监控部署状态和性能指标
        timeout 300 bash -c 'until curl -f https://routecodex.com/health; do sleep 10; done'

    - name: Rollback on failure
      if: failure()
      run: |
        echo "Deployment failed - initiating rollback..."
        # 自动回滚机制
        
  # 部署后验证
  post-deployment-validation:
    runs-on: ubuntu-latest
    needs: [deploy-production]
    if: always() && needs.deploy-production.result == 'success'
    
    steps:
    - name: Production health check
      run: |
        # 全面的生产环境健康检查
        curl -f https://routecodex.com/health
        curl -f https://routecodex.com/metrics
        
    - name: Performance monitoring
      run: |
        echo "Starting performance monitoring..."
        # 性能基准测试
        
    - name: Error rate monitoring
      run: |
        echo "Monitoring error rates..."
        # 错误率监控和告警
        
    - name: Deployment notification
      run: |
        echo "Deployment completed successfully"
        # 发送部署成功通知
