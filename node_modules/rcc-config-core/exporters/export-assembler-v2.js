// Export V2 assembler config from canonical model
// canonical shape expected:
// {
//   providers: { [provId]: { id, type, baseUrl, headers?, models: { [modelId]: {...} } } },
//   keyVault: { [provId]: { [keyId]: { type:'apikey', value, enabled } } },
//   routing: { [category]: string[] } // entries like 'prov.model' or 'prov.model__keyId'
//   routeMeta?: { [entry]: { providerId, modelId, keyId? } }
//   _metadata?: { keyDimension?: 'perKey' | 'perPipeline' }
// }

function asRecord(v) { return v && typeof v === 'object' ? v : {}; }

function detectCompatType(providerId) {
  const id = String(providerId || '').toLowerCase();
  if (id.includes('lmstudio')) return 'lmstudio-compatibility';
  if (id.includes('glm')) return 'glm';
  return 'passthrough-compatibility';
}

export function exportAssemblerConfigV2(canonical) {
  const c = asRecord(canonical);
  const providers = asRecord(c.providers);
  const keyVault = asRecord(c.keyVault);
  const routing = asRecord(c.routing);
  const routeMetaIn = asRecord(c.routeMeta || {});
  const keyDimension = asRecord(c._metadata || {}).keyDimension || 'perKey';

  const pipelines = [];
  const routePools = {};
  const routeMeta = {};

  // Step 1: Expand routePools (to pipeline IDs) and routeMeta (keyed by pipeline ID)
  for (const [cat, arr] of Object.entries(routing)) {
    const entries = Array.isArray(arr) ? arr.map(String) : [];
    const outPipelineIds = [];
    for (const ent of entries) {
      const dot = ent.indexOf('.');
      if (dot <= 0 || dot >= ent.length - 1) continue;
      const left = ent.slice(0, dot); // providerId
      const right = ent.slice(dot + 1); // modelId or modelId__key
      let modelId = right;
      let keyId = undefined;
      const u = right.split('__');
      if (u.length === 2) { modelId = u[0]; keyId = u[1]; }

      const routeHasKey = Boolean(keyId);

      if (keyDimension === 'perKey' && !routeHasKey) {
        // expand to all enabled keys
        const vault = asRecord(keyVault[left]);
        const keys = Object.keys(vault).filter(k => vault[k]?.enabled !== false);
        if (keys.length === 0) {
          // 无 key，落到 perPipeline 单条流水线
          const pipelineId = `${left}.${modelId}`;
          routeMeta[pipelineId] = { providerId: left, modelId };
          outPipelineIds.push(pipelineId);
        } else {
          for (const kid of keys) {
            const pipelineId = `${left}_${kid}.${modelId}`;
            routeMeta[pipelineId] = { providerId: left, modelId, keyId: kid };
            outPipelineIds.push(pipelineId);
          }
        }
      } else {
        // 保持不变：已带 key 或 perPipeline → 直接转换成 pipelineId
        const pipelineId = keyId ? `${left}_${keyId}.${modelId}` : `${left}.${modelId}`;
        routeMeta[pipelineId] = { providerId: left, modelId, ...(keyId ? { keyId } : {}) };
        outPipelineIds.push(pipelineId);
      }
    }
    routePools[cat] = Array.from(new Set(outPipelineIds));
  }

  // Step 2: Build pipelines; perKey -> one per key; perPipeline -> one per route
  const seen = new Set();
  for (const [pipelineId, meta] of Object.entries(routeMeta)) {
    const provId = meta.providerId;
    const modelId = meta.modelId;
    const prov = providers[provId];
    if (!prov || !modelId) continue;

    const vault = asRecord(keyVault[provId]);
    const enabledKeys = Object.keys(vault).filter(k => vault[k]?.enabled !== false);
    const makePipeline = (keyId) => {
      const uniq = `${provId}__${modelId}__${keyId || 'nokey'}`;
      if (seen.has(uniq)) return; seen.add(uniq);
      const providerModuleConfig = {
        providerId: provId,
        type: prov.type || 'openai',
        baseUrl: prov.baseUrl || prov.baseURL,
        headers: prov.headers || undefined,
        modelId,
      };
      const pid = keyId ? `${provId}_${keyId}.${modelId}` : `${provId}.${modelId}`;
      pipelines.push({
        id: pid,
        provider: { type: 'openai' },
        modules: {
          provider: { type: 'openai', config: providerModuleConfig },
          compatibility: { type: detectCompatType(provId), config: {} },
          llmSwitch: { type: 'llmswitch-conversion-router', config: {} },
          workflow: { type: 'streaming-control', config: {} },
        },
        settings: { debugEnabled: true },
        model: { actualModelId: modelId },
        authRef: keyId ? { mode: 'perKey', providerId: provId, keyId } : { mode: 'perPipeline', providerId: provId }
      });
    };

    if (keyDimension === 'perKey') {
      // routeMeta 已按 key 展开；此处如无 key 则全量展开
      if (meta.keyId) {
        makePipeline(meta.keyId);
      } else if (enabledKeys.length) {
        for (const k of enabledKeys) makePipeline(k);
      } else {
        makePipeline(undefined);
      }
    } else {
      makePipeline(meta.keyId);
    }
  }

  return { pipelines, routePools, routeMeta };
}

// Back-compat shim for potential older imports
export function exportAssemblerConfig(canonical) {
  return exportAssemblerConfigV2(canonical);
}
