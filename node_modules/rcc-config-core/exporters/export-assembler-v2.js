// Export V2 assembler config from canonical model
// canonical shape expected:
// {
//   providers: { [provId]: { id, type, baseUrl, headers?, models: { [modelId]: {...} } } },
//   keyVault: { [provId]: { [keyId]: { type:'apikey', value, enabled } } },
//   routing: { [category]: string[] } // entries like 'prov.model' or 'prov.model__keyId'
//   routeMeta?: { [entry]: { providerId, modelId, keyId? } }
//   _metadata?: { keyDimension?: 'perKey' | 'perPipeline' }
// }

function asRecord(v) { return v && typeof v === 'object' ? v : {}; }

function detectCompatType(providerId, canonicalProvider) {
  // 优先使用 canonical provider 上的 compat 标记（由 config-core 决定）
  const compat = (canonicalProvider && typeof canonicalProvider.compat === 'string')
    ? String(canonicalProvider.compat).trim()
    : '';
  if (compat) {
    // 允许直接指定完整模块类型，或用简写标签映射
    const lc = compat.toLowerCase();
    if (lc === 'glm') return 'glm-compatibility';
    if (lc === 'lmstudio') return 'lmstudio-compatibility';
    if (lc === 'qwen') return 'qwen-compatibility';
    if (lc === 'iflow') return 'iflow-compatibility';
    if (lc === 'none') return 'passthrough-compatibility';
    return compat;
  }
  // 兼容旧逻辑：根据 providerId 推断
  const id = String(providerId || '').toLowerCase();
  if (id.includes('lmstudio')) return 'lmstudio-compatibility';
  if (id.includes('glm')) return 'glm-compatibility';
  return 'passthrough-compatibility';
}

export function exportAssemblerConfigV2(canonical) {
  const c = asRecord(canonical);
  const providers = asRecord(c.providers);
  const keyVault = asRecord(c.keyVault);
  const routing = asRecord(c.routing);
  const routeMetaIn = asRecord(c.routeMeta || {});
  const keyDimension = asRecord(c._metadata || {}).keyDimension || 'perKey';

  const pipelines = [];
  const routePools = {};
  const routeMeta = {};

  // Step 1: Expand routePools (to pipeline IDs) and routeMeta (keyed by pipeline ID)
  for (const [cat, arr] of Object.entries(routing)) {
    const entries = Array.isArray(arr) ? arr.map(String) : [];
    const outPipelineIds = [];
    for (const ent of entries) {
      const dot = ent.indexOf('.');
      if (dot <= 0 || dot >= ent.length - 1) continue;
      const left = ent.slice(0, dot); // providerId
      const right = ent.slice(dot + 1); // modelId or modelId__key
      let modelId = right;
      let keyId = undefined;
      const u = right.split('__');
      if (u.length === 2) { modelId = u[0]; keyId = u[1]; }

      const routeHasKey = Boolean(keyId);

      if (keyDimension === 'perKey' && !routeHasKey) {
        // expand to all enabled keys
        const vault = asRecord(keyVault[left]);
        const keys = Object.keys(vault).filter(k => vault[k]?.enabled !== false);
        if (keys.length === 0) {
          // 无 key，落到 perPipeline 单条流水线
          const pipelineId = `${left}.${modelId}`;
          routeMeta[pipelineId] = { providerId: left, modelId };
          outPipelineIds.push(pipelineId);
        } else {
          for (const kid of keys) {
            const pipelineId = `${left}_${kid}.${modelId}`;
            routeMeta[pipelineId] = { providerId: left, modelId, keyId: kid };
            outPipelineIds.push(pipelineId);
          }
        }
      } else {
        // 保持不变：已带 key 或 perPipeline → 直接转换成 pipelineId
        const pipelineId = keyId ? `${left}_${keyId}.${modelId}` : `${left}.${modelId}`;
        routeMeta[pipelineId] = { providerId: left, modelId, ...(keyId ? { keyId } : {}) };
        outPipelineIds.push(pipelineId);
      }
    }
    routePools[cat] = Array.from(new Set(outPipelineIds));
  }

  // Step 2: Build pipelines; perKey -> one per key; perPipeline -> one per route
  const seen = new Set();
  for (const [pipelineId, meta] of Object.entries(routeMeta)) {
    const provId = meta.providerId;
    const modelId = meta.modelId;
    const prov = providers[provId];
    if (!prov || !modelId) continue;

    const vault = asRecord(keyVault[provId]);
    const enabledKeys = Object.keys(vault).filter(k => vault[k]?.enabled !== false);
    const makePipeline = (keyId) => {
      const uniq = `${provId}__${modelId}__${keyId || 'nokey'}`;
      if (seen.has(uniq)) return; seen.add(uniq);
      // 协议族：优先使用 canonical.providerType，其次回退到原始 type
      const providerFamily = (prov && typeof prov.providerType === 'string' && prov.providerType.trim())
        ? String(prov.providerType).trim()
        : (prov.type || 'openai');
      // Provider 模块类型（新 HTTP Provider 模块为并行路径）
      let providerModuleType = providerFamily;
      if (providerFamily === 'openai') providerModuleType = 'openai-http-provider';
      else if (providerFamily === 'responses') providerModuleType = 'responses-http-provider';
      else if (providerFamily === 'anthropic') providerModuleType = 'anthropic-http-provider';
      else if (providerFamily === 'iflow') {
        providerModuleType = 'iflow';
        // Ensure OAuth is supported for iflow
        if (prov.authCapabilities) {
          prov.authCapabilities.required = ['apikey', 'oauth'];
          prov.authCapabilities.optional = [];
        }
      }
      const processMode = String(prov.process || '').toLowerCase();
      let llmSwitchType = 'llmswitch-conversion-router';
      if (providerFamily === 'responses') {
        if (!processMode || processMode === 'passthrough') {
          llmSwitchType = 'llmswitch-responses-passthrough';
        } else if (processMode === 'chat') {
          llmSwitchType = 'llmswitch-response-chat';
        }
      }
      const providerModuleConfig = {
        providerId: provId,
        type: providerModuleType,
        // 从 canonical provider 透传行为字段（如存在）
        ...(prov.providerType ? { providerType: prov.providerType } : {}),
        ...(prov.protocol ? { protocol: prov.protocol } : {}),
        baseUrl: prov.baseUrl || prov.baseURL,
        ...(prov.endpoint ? { endpoint: prov.endpoint } : {}),
        ...(prov.defaultModel ? { defaultModel: prov.defaultModel } : {}),
        ...(typeof prov.timeoutMs === 'number' ? { timeoutMs: prov.timeoutMs } : {}),
        ...(typeof prov.maxRetries === 'number' ? { maxRetries: prov.maxRetries } : {}),
        headers: prov.headers || undefined,
        ...(prov.authCapabilities ? { authCapabilities: prov.authCapabilities } : {}),
        modelId,
      };
      const pid = keyId ? `${provId}_${keyId}.${modelId}` : `${provId}.${modelId}`;
      const llmSwitchConfig = {};
      if (processMode) {
        llmSwitchConfig.process = processMode;
      }
      pipelines.push({
        id: pid,
        provider: { type: providerModuleType },
        modules: {
          provider: { type: providerModuleType, config: providerModuleConfig },
          compatibility: { type: detectCompatType(provId, prov), config: {} },
          llmSwitch: { type: llmSwitchType, config: llmSwitchConfig },
          workflow: { type: 'streaming-control', config: {} },
        },
        settings: { debugEnabled: true },
        model: { actualModelId: modelId },
        authRef: keyId ? { mode: 'perKey', providerId: provId, keyId } : { mode: 'perPipeline', providerId: provId }
      });
    };

    if (keyDimension === 'perKey') {
      // routeMeta 已按 key 展开；此处如无 key 则全量展开
      if (meta.keyId) {
        makePipeline(meta.keyId);
      } else if (enabledKeys.length) {
        for (const k of enabledKeys) makePipeline(k);
      } else {
        makePipeline(undefined);
      }
    } else {
      makePipeline(meta.keyId);
    }
  }

  return { pipelines, routePools, routeMeta };
}

// Back-compat shim for potential older imports
export function exportAssemblerConfig(canonical) {
  return exportAssemblerConfigV2(canonical);
}
