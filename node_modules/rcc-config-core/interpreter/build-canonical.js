function asRecord(v) { return v && typeof v === 'object' ? v : {}; }

function normalizeProvider(id, raw) {
  const p = asRecord(raw);
  const baseUrl = p.baseUrl || p.baseURL || p.baseurl || undefined;
  const headers = asRecord(p.headers || {});
  const type = p.type || 'openai';
  const models = asRecord(p.models || {});
  const apiKey = Array.isArray(p.apiKey)
    ? p.apiKey
    : (typeof p.apiKey === 'string' && p.apiKey.trim() ? [p.apiKey.trim()] : []);
  const authApiKey = asRecord(p.auth || {}).apiKey;
  const keys = [];
  if (Array.isArray(apiKey)) keys.push(...apiKey.filter(Boolean));
  if (typeof authApiKey === 'string' && authApiKey.trim()) keys.push(authApiKey.trim());
  return { id, type, baseUrl, headers, models, keys };
}

export function buildCanonical(system, user, options = {}) {
  const u = asRecord(user?.data || {});
  const vr = asRecord(u.virtualrouter || {});
  const providersIn = asRecord(vr.providers || u.providers || {});
  const routingIn = asRecord(vr.routing || u.routing || {});
  const keyDimension = options.keyDimension || 'perKey';

  const providers = {}; const keyVault = {};
  for (const [pid, raw] of Object.entries(providersIn)) {
    const p = normalizeProvider(pid, raw);
    providers[pid] = { id: pid, type: p.type, baseUrl: p.baseUrl, headers: p.headers, models: p.models };
    if (p.keys && p.keys.length) {
      keyVault[pid] = {};
      p.keys.forEach((v, i) => { keyVault[pid][`key${i+1}`] = { type: 'apikey', value: v, enabled: true }; });
    }
  }

  // routing: copy as-is; if empty, try infer a default from first provider/model
  const routing = {};
  if (Object.keys(routingIn).length) {
    for (const [k, arr] of Object.entries(routingIn)) {
      const list = Array.isArray(arr) ? arr.map(String) : [];
      routing[k] = list;
    }
  } else {
    // infer default
    const firstProv = Object.keys(providers)[0];
    if (firstProv) {
      const mods = Object.keys(asRecord(providers[firstProv].models));
      if (mods.length) routing['default'] = [`${firstProv}.${mods[0]}`];
    }
  }

  // expand routeMeta; do not mutate routing entries; exporter will honor perKey dimension
  const routeMeta = {};
  for (const [cat, arr] of Object.entries(routing)) {
    for (const ent of (arr || [])) {
      const s = String(ent);
      const dot = s.indexOf('.');
      if (dot <= 0 || dot >= s.length-1) continue;
      routeMeta[s] = { providerId: s.slice(0, dot), modelId: s.slice(dot+1) };
    }
  }

  return {
    providers,
    keyVault,
    routing,
    routeMeta,
    _metadata: { version: '0.1.0', builtAt: Date.now(), keyDimension }
  };
}
