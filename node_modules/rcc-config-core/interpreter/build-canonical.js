import { PROVIDER_DEFAULTS } from './provider-defaults.js';

function asRecord(v) { return v && typeof v === 'object' ? v : {}; }

function normalizeProvider(id, raw) {
  const p = asRecord(raw);
  const type = p.type || 'openai';
  // 仅对已声明默认表的 family 应用 PROVIDER_DEFAULTS，其它 provider 保持现状。
  // familyKey 同时考虑协议族(type) 与 providerId，用于区分 iflow/qwen 这类 OpenAI 协议族内置家族。
  const lowerType = String(type).toLowerCase();
  const idLower = String(id || '').toLowerCase();
  let familyKey = null;
  if (lowerType === 'responses' || lowerType === 'anthropic') {
    familyKey = lowerType;
  } else if (lowerType === 'openai') {
    if (idLower.includes('iflow')) familyKey = 'iflow';
    else if (idLower.includes('qwen')) familyKey = 'qwen';
    else familyKey = 'openai';
  }
  const defaults = familyKey && Object.prototype.hasOwnProperty.call(PROVIDER_DEFAULTS, familyKey)
    ? PROVIDER_DEFAULTS[familyKey]
    : undefined;

  const baseUrl = p.baseUrl || p.baseURL || p.baseurl || (defaults && defaults.baseUrl) || undefined;
  const headers = {
    ...(defaults && defaults.headers ? defaults.headers : {}),
    ...asRecord(p.headers || {})
  };
  const models = asRecord(p.models || {});

  // process: 新配置优先使用 provider.process，其次兼容旧的 responses.process 形状
  let process;
  if (typeof p.process === 'string' && p.process.trim()) {
    process = p.process.trim();
  } else {
    const resp = asRecord(p.responses || {});
    if (typeof resp.process === 'string' && resp.process.trim()) {
      process = resp.process.trim();
    }
  }
  const apiKey = Array.isArray(p.apiKey)
    ? p.apiKey
    : (typeof p.apiKey === 'string' && p.apiKey.trim() ? [p.apiKey.trim()] : []);
  const authApiKey = asRecord(p.auth || {}).apiKey;
  const keys = [];
  if (Array.isArray(apiKey)) keys.push(...apiKey.filter(Boolean));
  if (typeof authApiKey === 'string' && authApiKey.trim()) keys.push(authApiKey.trim());

  // 新增的 canonical provider 行为字段（仅对已知 defaults 生效）
  const providerType = p.providerType || (defaults && defaults.providerType) || familyKey || type;
  const protocol = p.protocol || (defaults && defaults.protocol) || undefined;
  const endpoint = p.endpoint || (defaults && defaults.endpoint) || undefined;
  const defaultModel = p.defaultModel || (defaults && defaults.defaultModel) || undefined;
  const timeoutMs = p.timeoutMs || (defaults && defaults.timeoutMs) || undefined;
  const maxRetries = p.maxRetries || (defaults && defaults.maxRetries) || undefined;

  const authCapsRaw = asRecord(p.authCapabilities || {});
  const authFromDefaults = defaults && defaults.auth;
  let authCapabilities = undefined;
  if (authFromDefaults || Object.keys(authCapsRaw).length) {
    authCapabilities = {
      required: Array.isArray(authCapsRaw.required) && authCapsRaw.required.length
        ? authCapsRaw.required
        : (authFromDefaults ? authFromDefaults.required : []),
      optional: Array.isArray(authCapsRaw.optional) && authCapsRaw.optional.length
        ? authCapsRaw.optional
        : (authFromDefaults ? authFromDefaults.optional : [])
    };
  }

  // 厂商兼容标记（compat）：优先使用显式配置，其次根据 providerId 推导，最后默认为 'none'
  let compat = (typeof p.compat === 'string' && p.compat.trim()) ? String(p.compat).trim() : undefined;
  if (!compat) {
    const idLower = String(id || '').toLowerCase();
    if (idLower.includes('glm')) compat = 'glm';
    else if (idLower.includes('lmstudio')) compat = 'lmstudio';
    else if (idLower.includes('qwen')) compat = 'qwen';
    else if (idLower.includes('iflow')) compat = 'iflow';
    else compat = 'none';
  }

  return {
    id,
    type,
    baseUrl,
    headers,
    models,
    process,
    keys,
    ...(providerType ? { providerType } : {}),
    ...(protocol ? { protocol } : {}),
    ...(endpoint ? { endpoint } : {}),
    ...(defaultModel ? { defaultModel } : {}),
    ...(typeof timeoutMs === 'number' ? { timeoutMs } : {}),
    ...(typeof maxRetries === 'number' ? { maxRetries } : {}),
    ...(authCapabilities ? { authCapabilities } : {}),
    ...(compat ? { compat } : {})
  };
}

export function buildCanonical(system, user, options = {}) {
  const u = asRecord(user?.data || {});
  const vr = asRecord(u.virtualrouter || {});
  const providersIn = asRecord(vr.providers || u.providers || {});
  const routingIn = asRecord(vr.routing || u.routing || {});
  const keyDimension = options.keyDimension || 'perKey';

  const providers = {}; const keyVault = {};
  for (const [pid, raw] of Object.entries(providersIn)) {
    const p = normalizeProvider(pid, raw);
    providers[pid] = {
      id: pid,
      type: p.type,
      baseUrl: p.baseUrl,
      headers: p.headers,
      models: p.models,
      ...(typeof p.process === 'string' && p.process ? { process: p.process } : {}),
      ...(p.providerType ? { providerType: p.providerType } : {}),
      ...(p.protocol ? { protocol: p.protocol } : {}),
      ...(p.endpoint ? { endpoint: p.endpoint } : {}),
      ...(p.defaultModel ? { defaultModel: p.defaultModel } : {}),
      ...(typeof p.timeoutMs === 'number' ? { timeoutMs: p.timeoutMs } : {}),
      ...(typeof p.maxRetries === 'number' ? { maxRetries: p.maxRetries } : {}),
      ...(p.authCapabilities ? { authCapabilities: p.authCapabilities } : {}),
      ...(p.compat ? { compat: p.compat } : {})
    };
    if (p.keys && p.keys.length) {
      keyVault[pid] = {};
      p.keys.forEach((v, i) => { keyVault[pid][`key${i+1}`] = { type: 'apikey', value: v, enabled: true }; });
    }
  }

  // routing: copy as-is; if empty, try infer a default from first provider/model
  const routing = {};
  if (Object.keys(routingIn).length) {
    for (const [k, arr] of Object.entries(routingIn)) {
      const list = Array.isArray(arr) ? arr.map(String) : [];
      routing[k] = list;
    }
  } else {
    // infer default
    const firstProv = Object.keys(providers)[0];
    if (firstProv) {
      const mods = Object.keys(asRecord(providers[firstProv].models));
      if (mods.length) routing['default'] = [`${firstProv}.${mods[0]}`];
    }
  }

  // expand routeMeta; do not mutate routing entries; exporter will honor perKey dimension
  const routeMeta = {};
  for (const [cat, arr] of Object.entries(routing)) {
    for (const ent of (arr || [])) {
      const s = String(ent);
      const dot = s.indexOf('.');
      if (dot <= 0 || dot >= s.length-1) continue;
      routeMeta[s] = { providerId: s.slice(0, dot), modelId: s.slice(dot+1) };
    }
  }

  return {
    providers,
    keyVault,
    routing,
    routeMeta,
    _metadata: { version: '0.1.0', builtAt: Date.now(), keyDimension }
  };
}
