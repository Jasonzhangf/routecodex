import { packageFormat, urlFormat, versionFormat } from "./formats.js";
import { validateFieldType } from "./utils/validateFieldType.js";
import { validatePeople } from "./utils/validatePeople.js";
import { validateUrlTypes } from "./utils/validateUrlTypes.js";
import { validateAuthor } from "./validators/validateAuthor.js";
import { validateBin } from "./validators/validateBin.js";
import { validateBundleDependencies } from "./validators/validateBundleDependencies.js";
import { validateConfig } from "./validators/validateConfig.js";
import { validateCpu } from "./validators/validateCpu.js";
import { validateDependencies } from "./validators/validateDependencies.js";
import { validateDescription } from "./validators/validateDescription.js";
import { validateDirectories } from "./validators/validateDirectories.js";
import { validateExports } from "./validators/validateExports.js";
import { validateLicense } from "./validators/validateLicense.js";
import { validateScripts } from "./validators/validateScripts.js";
import { validateType } from "./validators/validateType.js";
import { validateUrlOrMailto } from "./validators/validateUrlOrMailto.js";
import { validateVersion } from "./validators/validateVersion.js";
import "./validators/index.js";

//#region src/validate.ts
const getSpecMap = (isPrivate, specName = "npm") => {
	if (specName == "npm") return {
		author: {
			validate: (_, value) => validateAuthor(value),
			warning: true
		},
		bin: { validate: (_, value) => validateBin(value) },
		bugs: {
			validate: validateUrlOrMailto,
			warning: true
		},
		bundledDependencies: { validate: (_, value) => validateBundleDependencies(value) },
		bundleDependencies: { validate: (_, value) => validateBundleDependencies(value) },
		config: { validate: (_, value) => validateConfig(value) },
		contributors: { validate: validatePeople },
		cpu: { validate: (_, value) => validateCpu(value) },
		dependencies: {
			recommended: true,
			validate: (_, value) => validateDependencies(value)
		},
		description: {
			validate: (_, value) => validateDescription(value),
			warning: true
		},
		devDependencies: { validate: (_, value) => validateDependencies(value) },
		directories: { validate: (_, value) => validateDirectories(value) },
		engines: {
			recommended: true,
			type: "object"
		},
		engineStrict: { type: "boolean" },
		exports: { validate: (_, value) => validateExports(value) },
		files: { type: "array" },
		homepage: {
			format: urlFormat,
			recommended: true,
			type: "string"
		},
		keywords: {
			type: "array",
			warning: true
		},
		license: { validate: (_, value) => validateLicense(value) },
		licenses: {
			or: "license",
			type: "array",
			validate: validateUrlTypes,
			warning: true
		},
		main: { type: "string" },
		man: { types: ["string", "array"] },
		name: {
			format: packageFormat,
			required: !isPrivate,
			type: "string"
		},
		optionalDependencies: { validate: (_, value) => validateDependencies(value) },
		os: { type: "array" },
		peerDependencies: { validate: (_, value) => validateDependencies(value) },
		preferGlobal: { type: "boolean" },
		private: { type: "boolean" },
		publishConfig: { type: "object" },
		repository: {
			or: "repositories",
			types: ["string", "object"],
			validate: validateUrlTypes,
			warning: true
		},
		scripts: { validate: (_, value) => validateScripts(value) },
		type: {
			recommended: true,
			validate: (_, value) => validateType(value)
		},
		version: {
			required: !isPrivate,
			validate: (_, value) => validateVersion(value)
		}
	};
	else if (specName == "commonjs_1.0") return {
		bugs: {
			required: true,
			type: "string",
			validate: validateUrlOrMailto
		},
		builtin: { type: "boolean" },
		checksums: { type: "object" },
		contributors: {
			required: true,
			type: "array",
			validate: validatePeople
		},
		cpu: { type: "array" },
		dependencies: {
			required: true,
			validate: (_, value) => validateDependencies(value)
		},
		description: {
			required: true,
			type: "string"
		},
		directories: { type: "object" },
		engine: { type: "array" },
		homepage: {
			format: urlFormat,
			type: "string"
		},
		implements: { type: "array" },
		keywords: {
			required: true,
			type: "array"
		},
		licenses: {
			required: true,
			type: "array",
			validate: validateUrlTypes
		},
		maintainers: {
			required: true,
			type: "array",
			validate: validatePeople
		},
		name: {
			format: packageFormat,
			required: true,
			type: "string"
		},
		os: { type: "array" },
		repositories: {
			required: true,
			type: "object",
			validate: validateUrlTypes
		},
		scripts: { type: "object" },
		version: {
			format: versionFormat,
			required: true,
			type: "string"
		}
	};
	else if (specName == "commonjs_1.1") return {
		bugs: {
			type: "string",
			validate: validateUrlOrMailto,
			warning: true
		},
		builtin: { type: "boolean" },
		checksums: { type: "object" },
		contributors: {
			type: "array",
			validate: validatePeople
		},
		cpu: { type: "array" },
		dependencies: { validate: (_, value) => validateDependencies(value) },
		description: {
			type: "string",
			warning: true
		},
		directories: {
			required: true,
			type: "object"
		},
		engine: { type: "array" },
		homepage: {
			format: urlFormat,
			type: "string",
			warning: true
		},
		implements: { type: "array" },
		keywords: { type: "array" },
		licenses: {
			type: "array",
			validate: validateUrlTypes,
			warning: true
		},
		main: {
			required: true,
			type: "string"
		},
		maintainers: {
			type: "array",
			validate: validatePeople,
			warning: true
		},
		name: {
			format: packageFormat,
			required: true,
			type: "string"
		},
		os: { type: "array" },
		overlay: { type: "object" },
		repositories: {
			type: "array",
			validate: validateUrlTypes
		},
		scripts: { type: "object" },
		version: {
			format: versionFormat,
			required: true,
			type: "string"
		}
	};
	else return false;
};
const parse = (data) => {
	if (typeof data != "string") return "Invalid data - Not a string";
	let parsed;
	try {
		parsed = JSON.parse(data);
	} catch (e) {
		let errorMessage = "Invalid JSON";
		if (e instanceof Error) errorMessage = `Invalid JSON - ${e.toString()}`;
		return errorMessage;
	}
	if (typeof parsed !== "object" || parsed === null || parsed instanceof Array) return `Invalid JSON - not an object (actual type: ${typeof parsed})`;
	return parsed;
};
/**
* Validate a package.json object (or string) against the npm spec.
* @param data The package.json data to validate, either as a string or an object.
* @param specNameOrOptions The options object, or the specification name to use for validation (deprecated).
* @param options The options for validation, if using the deprecated spec name parameter.
* @returns an object with the validation results.
*/
const validate = (data, specNameOrOptions = "npm", options = {}) => {
	const parsed = typeof data == "object" ? data : parse(data);
	const out = { valid: false };
	if (typeof parsed == "string") {
		out.critical = parsed;
		return out;
	}
	let specName;
	if (typeof specNameOrOptions === "object") {
		specName = "npm";
		options = specNameOrOptions;
	} else specName = specNameOrOptions;
	const map = getSpecMap(parsed.private, specName);
	if (map === false) {
		out.critical = { "Invalid specification": specName };
		return out;
	}
	const errors = [];
	const warnings = [];
	const recommendations = [];
	let name;
	for (name in map) {
		const field = map[name];
		if (parsed[name] === void 0 && (!field.or || field.or && parsed[field.or] === void 0)) {
			if (field.required) errors.push({
				field: name,
				message: `Missing required field: ${name}`
			});
			else if (field.warning) warnings.push(`Missing recommended field: ${name}`);
			else if (field.recommended) recommendations.push(`Missing optional field: ${name}`);
			continue;
		} else if (parsed[name] === void 0) continue;
		if (field.types || field.type) {
			const typeErrors = validateFieldType(name, field, parsed[name]);
			if (typeErrors.length > 0) {
				errors.push(...typeErrors.map((e) => ({
					field: name,
					message: e
				})));
				continue;
			}
		}
		if (field.format && !field.format.test(parsed[name])) errors.push({
			field: name,
			message: `Value for field ${name}, ${parsed[name]} does not match format: ${field.format.toString()}`
		});
		if (field.validate && typeof field.validate === "function") errors.push(...field.validate(name, parsed[name]).map((e) => ({
			field: name,
			message: e
		})));
	}
	out.valid = errors.length > 0 ? false : true;
	if (errors.length > 0) out.errors = errors;
	if (options.warnings !== false && warnings.length > 0) out.warnings = warnings;
	if (options.recommendations !== false && recommendations.length > 0) out.recommendations = recommendations;
	return out;
};

//#endregion
export { validate };