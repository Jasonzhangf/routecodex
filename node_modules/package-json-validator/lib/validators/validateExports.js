//#region src/validators/validateExports.ts
const validateExportCondition = (obj, propertyName, index) => {
	const errors = [];
	const normalizedKey = typeof propertyName === "string" && propertyName.trim();
	const fieldName = normalizedKey === "" ? `property ${String(index)}` : `"${normalizedKey}"`;
	if (typeof obj === "string") {
		if (obj.trim() === "") if (typeof propertyName === "string") errors.push(`the value of ${fieldName} is empty, but should be an entry point path`);
		else errors.push("the value is empty, but should be an entry point path");
	} else if (obj && typeof obj === "object" && !Array.isArray(obj)) {
		let propertyNumber = 0;
		for (const [key, value] of Object.entries(obj)) {
			if (key.trim() === "") errors.push(`property ${propertyNumber} has an empty key, but should be an export condition`);
			const childErrors = validateExportCondition(value, key, propertyNumber);
			errors.push(...childErrors);
			propertyNumber++;
		}
	} else if (typeof propertyName === "string") errors.push(`the value of ${fieldName} should be either an entry point path or an object of export conditions`);
	else if (obj === null) errors.push("the field is `null`, but should be an `object` or `string`");
	else {
		const valueType = Array.isArray(obj) ? "Array" : typeof obj;
		errors.push(`the type should be \`object\` or \`string\`, not \`${valueType}\``);
	}
	return errors;
};
/**
* Validate the `exports` field in a package.json. The value of
* should be either a string or a Record&lt;string, object | string&gt;
*/
const validateExports = (obj) => validateExportCondition(obj);

//#endregion
export { validateExports };