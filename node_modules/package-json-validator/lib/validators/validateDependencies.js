import { packageFormat, urlFormat } from "../formats.js";
import { validRange } from "semver";

//#region src/validators/validateDependencies.ts
const isUnpublishedVersion = (version) => {
	return urlFormat.test(version) || /^git(?:\+(?:ssh|http|https|file|rsync|ftp))?:/.test(version) || /^(?:github:)?[a-zA-Z0-9]+(?:-[a-zA-Z0-9]+)*\/[\w.-]+(?:#|$)/.test(version) || version.startsWith("workspace:") || version.startsWith("patch:") || version.startsWith("npm:") || version.startsWith("file:") || version.startsWith("../") || version.startsWith("~/") || version.startsWith("./") || version.startsWith("/") || false;
};
const isValidVersionRange = (version) => {
	return !!validRange(version) || version === "*" || version === "" || version === "latest" || version.startsWith("jsr:") || version.startsWith("catalog:") || isUnpublishedVersion(version);
};
/**
* Validates dependencies, making sure the object is a set of key value pairs
* with package names and versions
* @returns An array with validation errors (if any violations are found)
*/
const validateDependencies = (value) => {
	const errors = [];
	if (value == null) errors.push("the field is `null`, but should be a record of dependencies");
	else if (typeof value === "object" && !Array.isArray(value)) for (const [pkg, version] of Object.entries(value)) {
		if (!packageFormat.test(pkg) && !(typeof version === "string" && isUnpublishedVersion(version))) errors.push(`invalid dependency package name: ${pkg}`);
		if (typeof version !== "string") {
			errors.push(`dependency version for ${pkg} should be a string: ${version}`);
			continue;
		}
		if (!isValidVersionRange(version)) errors.push(`invalid version range for dependency ${pkg}: ${version}`);
	}
	else {
		const valueType = Array.isArray(value) ? "array" : typeof value;
		errors.push(`the type should be \`object\`, not \`${valueType}\``);
	}
	return errors;
};

//#endregion
export { validateDependencies };