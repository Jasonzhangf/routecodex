{
  "id": "sample_168ff2da1f9e2058",
  "timestamp": "2026-01-16T02:04:05.886Z",
  "errorType": "invalid_lines",
  "originalArgs": "{\"file\":\"packages/data-access/adapters/sqlite-adapter.ts\",\"instructions\":\"Replace entire file with refactored version that imports from split modules\",\"changes\":[{\"kind\":\"replace\",\"target\":\"import type { IStorageAdapter, StorageConfig } from '../interfaces/storage-adapter';\\nimport type { Novel, Chapter, Scene, Element, Character, Location, TimelineEvent } from '@novelmobile/domain-models';\\nimport sqlite3Init, { Database, Sqlite3Static } from 'sqlite-wasm';\",\"lines\":\"// SQLite Adapter - Refactored into modular structure\\n// This file now acts as a coordinator importing from split modules\\n\\nimport type { IStorageAdapter, StorageConfig } from '../interfaces/storage-adapter';\\nimport type { Novel, Chapter, Scene, Element, Character, Location, TimelineEvent } from '@novelmobile/domain-models';\\nimport sqlite3Init, { Database, Sqlite3Static } from 'sqlite-wasm';\\nimport { createSchema } from './schema/index.js';\\nimport * as novelOps from './operations/novels.js';\\nimport * as chapterOps from './operations/chapters.js';\\nimport * as sceneOps from './operations/scenes.js';\\nimport * as elementOps from './operations/elements.js';\\nimport * as characterOps from './operations/characters.js';\\nimport * as locationOps from './operations/locations.js';\\nimport * as timelineEventOps from './operations/timeline-events.js';\\nimport * as transactionOps from './operations/transactions.js';\"},{\"kind\":\"replace\",\"target\":\"export class SQLiteAdapter implements IStorageAdapter {\\n  private db: Database | null = null;\\n  private sqlite3: Sqlite3Static | null = null;\\n  private config: SQLiteConfig;\\n\\n  constructor(config: SQLiteConfig = {}) {\\n    this.config = config;\\n  }\\n\\n  async initialize(): Promise<void> {\\n    this.sqlite3 = await sqlite3Init();\\n    this.db = new this.sqlite3.oo1.DB(':memory:', 'c');\\n    this._createSchema();\\n  }\",\"lines\":\"export class SQLiteAdapter implements IStorageAdapter {\\n  private db: Database | null = null;\\n  private sqlite3: Sqlite3Static | null = null;\\n  private config: SQLiteConfig;\\n\\n  constructor(config: SQLiteConfig = {}) {\\n    this.config = config;\\n  }\\n\\n  async initialize(): Promise<void> {\\n    this.sqlite3 = await sqlite3Init();\\n    this.db = new this.sqlite3.oo1.DB(':memory:', 'c');\\n    createSchema(this.db);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  private _createSchema(): void {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    // Novels table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS novels (\\n        id TEXT PRIMARY KEY,\\n        title TEXT NOT NULL,\\n        description TEXT,\\n        authorId TEXT,\\n        status TEXT,\\n        totalWords INTEGER DEFAULT 0,\\n        createdAt TEXT,\\n        updatedAt TEXT\\n      )\\n    `);\\n\\n    // Chapters table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS chapters (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        title TEXT NOT NULL,\\n        summary TEXT,\\n        status TEXT,\\n        wordCount INTEGER DEFAULT 0,\\n        orderIndex INTEGER NOT NULL,\\n        createdAt TEXT,\\n        updatedAt TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Scenes table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS scenes (\\n        id TEXT PRIMARY KEY,\\n        chapterId TEXT NOT NULL,\\n        title TEXT,\\n        content TEXT,\\n        orderIndex INTEGER NOT NULL,\\n        locationId TEXT,\\n        createdAt TEXT,\\n        updatedAt TEXT,\\n        FOREIGN KEY (chapterId) REFERENCES chapters(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Elements table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS elements (\\n        id TEXT PRIMARY KEY,\\n        sceneId TEXT NOT NULL,\\n        type TEXT NOT NULL,\\n        content TEXT NOT NULL,\\n        metadata TEXT,\\n        orderIndex INTEGER NOT NULL,\\n        FOREIGN KEY (sceneId) REFERENCES scenes(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Characters table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS characters (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        name TEXT NOT NULL,\\n        description TEXT,\\n        attributes TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Locations table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS locations (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        name TEXT NOT NULL,\\n        description TEXT,\\n        attributes TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Timeline events table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS timeline_events (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        title TEXT NOT NULL,\\n        description TEXT,\\n        timestamp TEXT,\\n        sceneId TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Create indexes for better query performance\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_chapters_novelId ON chapters(novelId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_scenes_chapterId ON scenes(chapterId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_elements_sceneId ON elements(sceneId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_characters_novelId ON characters(novelId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_locations_novelId ON locations(novelId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_timeline_novelId ON timeline_events(novelId)');\\n  }\",\"lines\":\"  // Helper to get DB instance\\n  private getDb(): Database {\\n    if (!this.db) throw new Error('Database not initialized');\\n    return this.db;\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Novel operations\\n  async createNovel(novel: Novel): Promise<Novel> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO novels (id, title, description, authorId, status, totalWords, createdAt, updatedAt)\\n      VALUES (:id, :title, :description, :authorId, :status, :totalWords, :createdAt, :updatedAt)\\n    `);\\n\\n    stmt.run({\\n      ':id': novel.id,\\n      ':title': novel.title,\\n      ':description': novel.description || null,\\n      ':authorId': novel.authorId || null,\\n      ':status': novel.status,\\n      ':totalWords': novel.totalWords || 0,\\n      ':createdAt': novel.createdAt,\\n      ':updatedAt': novel.updatedAt\\n    });\\n\\n    stmt.finalize();\\n    return novel;\\n  }\\n\\n  async getNovel(id: string): Promise<Novel | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM novels WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      title: result.title,\\n      description: result.description,\\n      authorId: result.authorId,\\n      status: result.status,\\n      totalWords: result.totalWords,\\n      createdAt: result.createdAt,\\n      updatedAt: result.updatedAt\\n    };\\n  }\\n\\n  async updateNovel(id: string, updates: Partial<Novel>): Promise<Novel> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getNovel(id);\\n    if (!existing) throw new Error('Novel not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.title !== undefined) {\\n      fields.push('title = :title');\\n      values[':title'] = updates.title;\\n    }\\n    if (updates.description !== undefined) {\\n      fields.push('description = :description');\\n      values[':description'] = updates.description;\\n    }\\n    if (updates.status !== undefined) {\\n      fields.push('status = :status');\\n      values[':status'] = updates.status;\\n    }\\n    if (updates.totalWords !== undefined) {\\n      fields.push('totalWords = :totalWords');\\n      values[':totalWords'] = updates.totalWords;\\n    }\\n\\n    fields.push('updatedAt = :updatedAt');\\n    values[':updatedAt'] = new Date().toISOString();\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE novels SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getNovel(id) as Promise<Novel>;\\n  }\\n\\n  async deleteNovel(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM novels WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listNovels(): Promise<Novel[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM novels');\\n    const results: Novel[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        title: row.title,\\n        description: row.description,\\n        authorId: row.authorId,\\n        status: row.status,\\n        totalWords: row.totalWords,\\n        createdAt: row.createdAt,\\n        updatedAt: row.updatedAt\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Novel operations - delegated to novels module\\n  async createNovel(novel: Novel): Promise<Novel> {\\n    return novelOps.createNovel(this.getDb(), novel);\\n  }\\n\\n  async getNovel(id: string): Promise<Novel | null> {\\n    return novelOps.getNovel(this.getDb(), id);\\n  }\\n\\n  async updateNovel(id: string, updates: Partial<Novel>): Promise<Novel> {\\n    return novelOps.updateNovel(this.getDb(), id, updates);\\n  }\\n\\n  async deleteNovel(id: string): Promise<void> {\\n    return novelOps.deleteNovel(this.getDb(), id);\\n  }\\n\\n  async listNovels(): Promise<Novel[]> {\\n    return novelOps.listNovels(this.getDb());\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Chapter operations\\n  async createChapter(chapter: Chapter): Promise<Chapter> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO chapters (id, novelId, title, summary, status, wordCount, orderIndex, createdAt, updatedAt)\\n      VALUES (:id, :novelId, :title, :summary, :status, :wordCount, :orderIndex, :createdAt, :updatedAt)\\n    `);\\n\\n    stmt.run({\\n      ':id': chapter.id,\\n      ':novelId': chapter.novelId,\\n      ':title': chapter.title,\\n      ':summary': chapter.summary || null,\\n      ':status': chapter.status,\\n      ':wordCount': chapter.wordCount || 0,\\n      ':orderIndex': chapter.orderIndex,\\n      ':createdAt': chapter.createdAt,\\n      ':updatedAt': chapter.updatedAt\\n    });\\n\\n    stmt.finalize();\\n    return chapter;\\n  }\\n\\n  async getChapter(id: string): Promise<Chapter | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM chapters WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      novelId: result.novelId,\\n      title: result.title,\\n      summary: result.summary,\\n      status: result.status,\\n      wordCount: result.wordCount,\\n      orderIndex: result.orderIndex,\\n      createdAt: result.createdAt,\\n      updatedAt: result.updatedAt\\n    };\\n  }\\n\\n  async updateChapter(id: string, updates: Partial<Chapter>): Promise<Chapter> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getChapter(id);\\n    if (!existing) throw new Error('Chapter not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.title !== undefined) {\\n      fields.push('title = :title');\\n      values[':title'] = updates.title;\\n    }\\n    if (updates.summary !== undefined) {\\n      fields.push('summary = :summary');\\n      values[':summary'] = updates.summary;\\n    }\\n    if (updates.status !== undefined) {\\n      fields.push('status = :status');\\n      values[':status'] = updates.status;\\n    }\\n    if (updates.wordCount !== undefined) {\\n      fields.push('wordCount = :wordCount');\\n      values[':wordCount'] = updates.wordCount;\\n    }\\n\\n    fields.push('updatedAt = :updatedAt');\\n    values[':updatedAt'] = new Date().toISOString();\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE chapters SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getChapter(id) as Promise<Chapter>;\\n  }\\n\\n  async deleteChapter(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM chapters WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listChapters(novelId: string): Promise<Chapter[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM chapters WHERE novelId = :novelId ORDER BY orderIndex');\\n    const results: Chapter[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        novelId: row.novelId,\\n        title: row.title,\\n        summary: row.summary,\\n        status: row.status,\\n        wordCount: row.wordCount,\\n        orderIndex: row.orderIndex,\\n        createdAt: row.createdAt,\\n        updatedAt: row.updatedAt\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Chapter operations - delegated to chapters module\\n  async createChapter(chapter: Chapter): Promise<Chapter> {\\n    return chapterOps.createChapter(this.getDb(), chapter);\\n  }\\n\\n  async getChapter(id: string): Promise<Chapter | null> {\\n    return chapterOps.getChapter(this.getDb(), id);\\n  }\\n\\n  async updateChapter(id: string, updates: Partial<Chapter>): Promise<Chapter> {\\n    return chapterOps.updateChapter(this.getDb(), id, updates);\\n  }\\n\\n  async deleteChapter(id: string): Promise<void> {\\n    return chapterOps.deleteChapter(this.getDb(), id);\\n  }\\n\\n  async listChapters(novelId: string): Promise<Chapter[]> {\\n    return chapterOps.listChapters(this.getDb(), novelId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Scene operations\\n  async createScene(scene: Scene): Promise<Scene> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO scenes (id, chapterId, title, content, orderIndex, locationId, createdAt, updatedAt)\\n      VALUES (:id, :chapterId, :title, :content, :orderIndex, :locationId, :createdAt, :updatedAt)\\n    `);\\n\\n    stmt.run({\\n      ':id': scene.id,\\n      ':chapterId': scene.chapterId,\\n      ':title': scene.title || null,\\n      ':content': scene.content || null,\\n      ':orderIndex': scene.orderIndex,\\n      ':locationId': scene.locationId || null,\\n      ':createdAt': scene.createdAt,\\n      ':updatedAt': scene.updatedAt\\n    });\\n\\n    stmt.finalize();\\n    return scene;\\n  }\\n\\n  async getScene(id: string): Promise<Scene | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM scenes WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      chapterId: result.chapterId,\\n      title: result.title,\\n      content: result.content,\\n      orderIndex: result.orderIndex,\\n      locationId: result.locationId,\\n      createdAt: result.createdAt,\\n      updatedAt: result.updatedAt\\n    };\\n  }\\n\\n  async updateScene(id: string, updates: Partial<Scene>): Promise<Scene> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getScene(id);\\n    if (!existing) throw new Error('Scene not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.title !== undefined) {\\n      fields.push('title = :title');\\n      values[':title'] = updates.title;\\n    }\\n    if (updates.content !== undefined) {\\n      fields.push('content = :content');\\n      values[':content'] = updates.content;\\n    }\\n    if (updates.locationId !== undefined) {\\n      fields.push('locationId = :locationId');\\n      values[':locationId'] = updates.locationId;\\n    }\\n\\n    fields.push('updatedAt = :updatedAt');\\n    values[':updatedAt'] = new Date().toISOString();\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE scenes SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getScene(id) as Promise<Scene>;\\n  }\\n\\n  async deleteScene(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM scenes WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listScenes(chapterId: string): Promise<Scene[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM scenes WHERE chapterId = :chapterId ORDER BY orderIndex');\\n    const results: Scene[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        chapterId: row.chapterId,\\n        title: row.title,\\n        content: row.content,\\n        orderIndex: row.orderIndex,\\n        locationId: row.locationId,\\n        createdAt: row.createdAt,\\n        updatedAt: row.updatedAt\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Scene operations - delegated to scenes module\\n  async createScene(scene: Scene): Promise<Scene> {\\n    return sceneOps.createScene(this.getDb(), scene);\\n  }\\n\\n  async getScene(id: string): Promise<Scene | null> {\\n    return sceneOps.getScene(this.getDb(), id);\\n  }\\n\\n  async updateScene(id: string, updates: Partial<Scene>): Promise<Scene> {\\n    return sceneOps.updateScene(this.getDb(), id, updates);\\n  }\\n\\n  async deleteScene(id: string): Promise<void> {\\n    return sceneOps.deleteScene(this.getDb(), id);\\n  }\\n\\n  async listScenes(chapterId: string): Promise<Scene[]> {\\n    return sceneOps.listScenes(this.getDb(), chapterId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Element operations\\n  async createElement(element: Element): Promise<Element> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO elements (id, sceneId, type, content, metadata, orderIndex)\\n      VALUES (:id, :sceneId, :type, :content, :metadata, :orderIndex)\\n    `);\\n\\n    stmt.run({\\n      ':id': element.id,\\n      ':sceneId': element.sceneId,\\n      ':type': element.type,\\n      ':content': element.content,\\n      ':metadata': element.metadata ? JSON.stringify(element.metadata) : null,\\n      ':orderIndex': element.orderIndex\\n    });\\n\\n    stmt.finalize();\\n    return element;\\n  }\\n\\n  async getElement(id: string): Promise<Element | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM elements WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      sceneId: result.sceneId,\\n      type: result.type,\\n      content: result.content,\\n      metadata: result.metadata ? JSON.parse(result.metadata) : undefined,\\n      orderIndex: result.orderIndex\\n    };\\n  }\\n\\n  async updateElement(id: string, updates: Partial<Element>): Promise<Element> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getElement(id);\\n    if (!existing) throw new Error('Element not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.content !== undefined) {\\n      fields.push('content = :content');\\n      values[':content'] = updates.content;\\n    }\\n    if (updates.metadata !== undefined) {\\n      fields.push('metadata = :metadata');\\n      values[':metadata'] = updates.metadata ? JSON.stringify(updates.metadata) : null;\\n    }\\n\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE elements SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getElement(id) as Promise<Element>;\\n  }\\n\\n  async deleteElement(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM elements WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listElements(sceneId: string): Promise<Element[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM elements WHERE sceneId = :sceneId ORDER BY orderIndex');\\n    const results: Element[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        sceneId: row.sceneId,\\n        type: row.type,\\n        content: row.content,\\n        metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\\n        orderIndex: row.orderIndex\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Element operations - delegated to elements module\\n  async createElement(element: Element): Promise<Element> {\\n    return elementOps.createElement(this.getDb(), element);\\n  }\\n\\n  async getElement(id: string): Promise<Element | null> {\\n    return elementOps.getElement(this.getDb(), id);\\n  }\\n\\n  async updateElement(id: string, updates: Partial<Element>): Promise<Element> {\\n    return elementOps.updateElement(this.getDb(), id, updates);\\n  }\\n\\n  async deleteElement(id: string): Promise<void> {\\n    return elementOps.deleteElement(this.getDb(), id);\\n  }\\n\\n  async listElements(sceneId: string): Promise<Element[]> {\\n    return elementOps.listElements(this.getDb(), sceneId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Character operations\\n  async createCharacter(character: Character): Promise<Character> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO characters (id, novelId, name, description, attributes)\\n      VALUES (:id, :novelId, :name, :description, :attributes)\\n    `);\\n\\n    stmt.run({\\n      ':id': character.id,\\n      ':novelId': character.novelId,\\n      ':name': character.name,\\n      ':description': character.description || null,\\n      ':attributes': character.attributes ? JSON.stringify(character.attributes) : null\\n    });\\n\\n    stmt.finalize();\\n    return character;\\n  }\\n\\n  async getCharacter(id: string): Promise<Character | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM characters WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      novelId: result.novelId,\\n      name: result.name,\\n      description: result.description,\\n      attributes: result.attributes ? JSON.parse(result.attributes) : undefined\\n    };\\n  }\\n\\n  async updateCharacter(id: string, updates: Partial<Character>): Promise<Character> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getCharacter(id);\\n    if (!existing) throw new Error('Character not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.name !== undefined) {\\n      fields.push('name = :name');\\n      values[':name'] = updates.name;\\n    }\\n    if (updates.description !== undefined) {\\n      fields.push('description = :description');\\n      values[':description'] = updates.description;\\n    }\\n    if (updates.attributes !== undefined) {\\n      fields.push('attributes = :attributes');\\n      values[':attributes'] = updates.attributes ? JSON.stringify(updates.attributes) : null;\\n    }\\n\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE characters SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getCharacter(id) as Promise<Character>;\\n  }\\n\\n  async deleteCharacter(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM characters WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listCharacters(novelId: string): Promise<Character[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM characters WHERE novelId = :novelId');\\n    const results: Character[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        novelId: row.novelId,\\n        name: row.name,\\n        description: row.description,\\n        attributes: row.attributes ? JSON.parse(row.attributes) : undefined\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Character operations - delegated to characters module\\n  async createCharacter(character: Character): Promise<Character> {\\n    return characterOps.createCharacter(this.getDb(), character);\\n  }\\n\\n  async getCharacter(id: string): Promise<Character | null> {\\n    return characterOps.getCharacter(this.getDb(), id);\\n  }\\n\\n  async updateCharacter(id: string, updates: Partial<Character>): Promise<Character> {\\n    return characterOps.updateCharacter(this.getDb(), id, updates);\\n  }\\n\\n  async deleteCharacter(id: string): Promise<void> {\\n    return characterOps.deleteCharacter(this.getDb(), id);\\n  }\\n\\n  async listCharacters(novelId: string): Promise<Character[]> {\\n    return characterOps.listCharacters(this.getDb(), novelId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Location operations\\n  async createLocation(location: Location): Promise<Location> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO locations (id, novelId, name, description, attributes)\\n      VALUES (:id, :novelId, :name, :description, :attributes)\\n    `);\\n\\n    stmt.run({\\n      ':id': location.id,\\n      ':novelId': location.novelId,\\n      ':name': location.name,\\n      ':description': location.description || null,\\n      ':attributes': location.attributes ? JSON.stringify(location.attributes) : null\\n    });\\n\\n    stmt.finalize();\\n    return location;\\n  }\\n\\n  async getLocation(id: string): Promise<Location | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM locations WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      novelId: result.novelId,\\n      name: result.name,\\n      description: result.description,\\n      attributes: result.attributes ? JSON.parse(result.attributes) : undefined\\n    };\\n  }\\n\\n  async updateLocation(id: string, updates: Partial<Location>): Promise<Location> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getLocation(id);\\n    if (!existing) throw new Error('Location not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.name !== undefined) {\\n      fields.push('name = :name');\\n      values[':name'] = updates.name;\\n    }\\n    if (updates.description !== undefined) {\\n      fields.push('description = :description');\\n      values[':description'] = updates.description;\\n    }\\n    if (updates.attributes !== undefined) {\\n      fields.push('attributes = :attributes');\\n      values[':attributes'] = updates.attributes ? JSON.stringify(updates.attributes) : null;\\n    }\\n\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE locations SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getLocation(id) as Promise<Location>;\\n  }\\n\\n  async deleteLocation(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM locations WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listLocations(novelId: string): Promise<Location[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM locations WHERE novelId = :novelId');\\n    const results: Location[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        novelId: row.novelId,\\n        name: row.name,\\n        description: row.description,\\n        attributes: row.attributes ? JSON.parse(row.attributes) : undefined\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Location operations - delegated to locations module\\n  async createLocation(location: Location): Promise<Location> {\\n    return locationOps.createLocation(this.getDb(), location);\\n  }\\n\\n  async getLocation(id: string): Promise<Location | null> {\\n    return locationOps.getLocation(this.getDb(), id);\\n  }\\n\\n  async updateLocation(id: string, updates: Partial<Location>): Promise<Location> {\\n    return locationOps.updateLocation(this.getDb(), id, updates);\\n  }\\n\\n  async deleteLocation(id: string): Promise<void> {\\n    return locationOps.deleteLocation(this.getDb(), id);\\n  }\\n\\n  async listLocations(novelId: string): Promise<Location[]> {\\n    return locationOps.listLocations(this.getDb(), novelId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // TimelineEvent operations\\n  async createTimelineEvent(event: TimelineEvent): Promise<TimelineEvent> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO timeline_events (id\",\"id,\":\"novelId\",\"title,\":\"description\",\"timestamp,\":\"sceneId)\\n    `);\\n\\n    stmt.run({\\n      ':id': event.id\",\":novelId\":\"event.novelId\",\":title\":\"event.title\",\":description\":\"event.description || null\",\":timestamp\":\"event.timestamp\",\":sceneId\":\"event.sceneId || null\"},\"n\\n    stmt.finalize();\\n    return event;\\n  }\\n\\n  async getTimelineEvent(id: string): Promise<TimelineEvent | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM timeline_events WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id\",\"n      novelId: result.novelId\",\"n      title: result.title\",\"n      description: result.description\",\"n      timestamp: result.timestamp\",\"n      sceneId: result.sceneId\\n    };\\n  }\\n\\n  async updateTimelineEvent(id: string\",\"updates\"]}",
  "normalizedArgs": "{\"file\":\"packages/data-access/adapters/sqlite-adapter.ts\",\"instructions\":\"Replace entire file with refactored version that imports from split modules\",\"changes\":[{\"kind\":\"replace\",\"target\":\"import type { IStorageAdapter, StorageConfig } from '../interfaces/storage-adapter';\\nimport type { Novel, Chapter, Scene, Element, Character, Location, TimelineEvent } from '@novelmobile/domain-models';\\nimport sqlite3Init, { Database, Sqlite3Static } from 'sqlite-wasm';\",\"lines\":\"// SQLite Adapter - Refactored into modular structure\\n// This file now acts as a coordinator importing from split modules\\n\\nimport type { IStorageAdapter, StorageConfig } from '../interfaces/storage-adapter';\\nimport type { Novel, Chapter, Scene, Element, Character, Location, TimelineEvent } from '@novelmobile/domain-models';\\nimport sqlite3Init, { Database, Sqlite3Static } from 'sqlite-wasm';\\nimport { createSchema } from './schema/index.js';\\nimport * as novelOps from './operations/novels.js';\\nimport * as chapterOps from './operations/chapters.js';\\nimport * as sceneOps from './operations/scenes.js';\\nimport * as elementOps from './operations/elements.js';\\nimport * as characterOps from './operations/characters.js';\\nimport * as locationOps from './operations/locations.js';\\nimport * as timelineEventOps from './operations/timeline-events.js';\\nimport * as transactionOps from './operations/transactions.js';\"},{\"kind\":\"replace\",\"target\":\"export class SQLiteAdapter implements IStorageAdapter {\\n  private db: Database | null = null;\\n  private sqlite3: Sqlite3Static | null = null;\\n  private config: SQLiteConfig;\\n\\n  constructor(config: SQLiteConfig = {}) {\\n    this.config = config;\\n  }\\n\\n  async initialize(): Promise<void> {\\n    this.sqlite3 = await sqlite3Init();\\n    this.db = new this.sqlite3.oo1.DB(':memory:', 'c');\\n    this._createSchema();\\n  }\",\"lines\":\"export class SQLiteAdapter implements IStorageAdapter {\\n  private db: Database | null = null;\\n  private sqlite3: Sqlite3Static | null = null;\\n  private config: SQLiteConfig;\\n\\n  constructor(config: SQLiteConfig = {}) {\\n    this.config = config;\\n  }\\n\\n  async initialize(): Promise<void> {\\n    this.sqlite3 = await sqlite3Init();\\n    this.db = new this.sqlite3.oo1.DB(':memory:', 'c');\\n    createSchema(this.db);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  private _createSchema(): void {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    // Novels table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS novels (\\n        id TEXT PRIMARY KEY,\\n        title TEXT NOT NULL,\\n        description TEXT,\\n        authorId TEXT,\\n        status TEXT,\\n        totalWords INTEGER DEFAULT 0,\\n        createdAt TEXT,\\n        updatedAt TEXT\\n      )\\n    `);\\n\\n    // Chapters table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS chapters (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        title TEXT NOT NULL,\\n        summary TEXT,\\n        status TEXT,\\n        wordCount INTEGER DEFAULT 0,\\n        orderIndex INTEGER NOT NULL,\\n        createdAt TEXT,\\n        updatedAt TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Scenes table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS scenes (\\n        id TEXT PRIMARY KEY,\\n        chapterId TEXT NOT NULL,\\n        title TEXT,\\n        content TEXT,\\n        orderIndex INTEGER NOT NULL,\\n        locationId TEXT,\\n        createdAt TEXT,\\n        updatedAt TEXT,\\n        FOREIGN KEY (chapterId) REFERENCES chapters(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Elements table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS elements (\\n        id TEXT PRIMARY KEY,\\n        sceneId TEXT NOT NULL,\\n        type TEXT NOT NULL,\\n        content TEXT NOT NULL,\\n        metadata TEXT,\\n        orderIndex INTEGER NOT NULL,\\n        FOREIGN KEY (sceneId) REFERENCES scenes(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Characters table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS characters (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        name TEXT NOT NULL,\\n        description TEXT,\\n        attributes TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Locations table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS locations (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        name TEXT NOT NULL,\\n        description TEXT,\\n        attributes TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Timeline events table\\n    this.db.exec(`\\n      CREATE TABLE IF NOT EXISTS timeline_events (\\n        id TEXT PRIMARY KEY,\\n        novelId TEXT NOT NULL,\\n        title TEXT NOT NULL,\\n        description TEXT,\\n        timestamp TEXT,\\n        sceneId TEXT,\\n        FOREIGN KEY (novelId) REFERENCES novels(id) ON DELETE CASCADE\\n      )\\n    `);\\n\\n    // Create indexes for better query performance\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_chapters_novelId ON chapters(novelId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_scenes_chapterId ON scenes(chapterId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_elements_sceneId ON elements(sceneId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_characters_novelId ON characters(novelId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_locations_novelId ON locations(novelId)');\\n    this.db.exec('CREATE INDEX IF NOT EXISTS idx_timeline_novelId ON timeline_events(novelId)');\\n  }\",\"lines\":\"  // Helper to get DB instance\\n  private getDb(): Database {\\n    if (!this.db) throw new Error('Database not initialized');\\n    return this.db;\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Novel operations\\n  async createNovel(novel: Novel): Promise<Novel> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO novels (id, title, description, authorId, status, totalWords, createdAt, updatedAt)\\n      VALUES (:id, :title, :description, :authorId, :status, :totalWords, :createdAt, :updatedAt)\\n    `);\\n\\n    stmt.run({\\n      ':id': novel.id,\\n      ':title': novel.title,\\n      ':description': novel.description || null,\\n      ':authorId': novel.authorId || null,\\n      ':status': novel.status,\\n      ':totalWords': novel.totalWords || 0,\\n      ':createdAt': novel.createdAt,\\n      ':updatedAt': novel.updatedAt\\n    });\\n\\n    stmt.finalize();\\n    return novel;\\n  }\\n\\n  async getNovel(id: string): Promise<Novel | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM novels WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      title: result.title,\\n      description: result.description,\\n      authorId: result.authorId,\\n      status: result.status,\\n      totalWords: result.totalWords,\\n      createdAt: result.createdAt,\\n      updatedAt: result.updatedAt\\n    };\\n  }\\n\\n  async updateNovel(id: string, updates: Partial<Novel>): Promise<Novel> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getNovel(id);\\n    if (!existing) throw new Error('Novel not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.title !== undefined) {\\n      fields.push('title = :title');\\n      values[':title'] = updates.title;\\n    }\\n    if (updates.description !== undefined) {\\n      fields.push('description = :description');\\n      values[':description'] = updates.description;\\n    }\\n    if (updates.status !== undefined) {\\n      fields.push('status = :status');\\n      values[':status'] = updates.status;\\n    }\\n    if (updates.totalWords !== undefined) {\\n      fields.push('totalWords = :totalWords');\\n      values[':totalWords'] = updates.totalWords;\\n    }\\n\\n    fields.push('updatedAt = :updatedAt');\\n    values[':updatedAt'] = new Date().toISOString();\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE novels SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getNovel(id) as Promise<Novel>;\\n  }\\n\\n  async deleteNovel(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM novels WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listNovels(): Promise<Novel[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM novels');\\n    const results: Novel[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        title: row.title,\\n        description: row.description,\\n        authorId: row.authorId,\\n        status: row.status,\\n        totalWords: row.totalWords,\\n        createdAt: row.createdAt,\\n        updatedAt: row.updatedAt\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Novel operations - delegated to novels module\\n  async createNovel(novel: Novel): Promise<Novel> {\\n    return novelOps.createNovel(this.getDb(), novel);\\n  }\\n\\n  async getNovel(id: string): Promise<Novel | null> {\\n    return novelOps.getNovel(this.getDb(), id);\\n  }\\n\\n  async updateNovel(id: string, updates: Partial<Novel>): Promise<Novel> {\\n    return novelOps.updateNovel(this.getDb(), id, updates);\\n  }\\n\\n  async deleteNovel(id: string): Promise<void> {\\n    return novelOps.deleteNovel(this.getDb(), id);\\n  }\\n\\n  async listNovels(): Promise<Novel[]> {\\n    return novelOps.listNovels(this.getDb());\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Chapter operations\\n  async createChapter(chapter: Chapter): Promise<Chapter> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO chapters (id, novelId, title, summary, status, wordCount, orderIndex, createdAt, updatedAt)\\n      VALUES (:id, :novelId, :title, :summary, :status, :wordCount, :orderIndex, :createdAt, :updatedAt)\\n    `);\\n\\n    stmt.run({\\n      ':id': chapter.id,\\n      ':novelId': chapter.novelId,\\n      ':title': chapter.title,\\n      ':summary': chapter.summary || null,\\n      ':status': chapter.status,\\n      ':wordCount': chapter.wordCount || 0,\\n      ':orderIndex': chapter.orderIndex,\\n      ':createdAt': chapter.createdAt,\\n      ':updatedAt': chapter.updatedAt\\n    });\\n\\n    stmt.finalize();\\n    return chapter;\\n  }\\n\\n  async getChapter(id: string): Promise<Chapter | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM chapters WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      novelId: result.novelId,\\n      title: result.title,\\n      summary: result.summary,\\n      status: result.status,\\n      wordCount: result.wordCount,\\n      orderIndex: result.orderIndex,\\n      createdAt: result.createdAt,\\n      updatedAt: result.updatedAt\\n    };\\n  }\\n\\n  async updateChapter(id: string, updates: Partial<Chapter>): Promise<Chapter> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getChapter(id);\\n    if (!existing) throw new Error('Chapter not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.title !== undefined) {\\n      fields.push('title = :title');\\n      values[':title'] = updates.title;\\n    }\\n    if (updates.summary !== undefined) {\\n      fields.push('summary = :summary');\\n      values[':summary'] = updates.summary;\\n    }\\n    if (updates.status !== undefined) {\\n      fields.push('status = :status');\\n      values[':status'] = updates.status;\\n    }\\n    if (updates.wordCount !== undefined) {\\n      fields.push('wordCount = :wordCount');\\n      values[':wordCount'] = updates.wordCount;\\n    }\\n\\n    fields.push('updatedAt = :updatedAt');\\n    values[':updatedAt'] = new Date().toISOString();\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE chapters SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getChapter(id) as Promise<Chapter>;\\n  }\\n\\n  async deleteChapter(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM chapters WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listChapters(novelId: string): Promise<Chapter[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM chapters WHERE novelId = :novelId ORDER BY orderIndex');\\n    const results: Chapter[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        novelId: row.novelId,\\n        title: row.title,\\n        summary: row.summary,\\n        status: row.status,\\n        wordCount: row.wordCount,\\n        orderIndex: row.orderIndex,\\n        createdAt: row.createdAt,\\n        updatedAt: row.updatedAt\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Chapter operations - delegated to chapters module\\n  async createChapter(chapter: Chapter): Promise<Chapter> {\\n    return chapterOps.createChapter(this.getDb(), chapter);\\n  }\\n\\n  async getChapter(id: string): Promise<Chapter | null> {\\n    return chapterOps.getChapter(this.getDb(), id);\\n  }\\n\\n  async updateChapter(id: string, updates: Partial<Chapter>): Promise<Chapter> {\\n    return chapterOps.updateChapter(this.getDb(), id, updates);\\n  }\\n\\n  async deleteChapter(id: string): Promise<void> {\\n    return chapterOps.deleteChapter(this.getDb(), id);\\n  }\\n\\n  async listChapters(novelId: string): Promise<Chapter[]> {\\n    return chapterOps.listChapters(this.getDb(), novelId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Scene operations\\n  async createScene(scene: Scene): Promise<Scene> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO scenes (id, chapterId, title, content, orderIndex, locationId, createdAt, updatedAt)\\n      VALUES (:id, :chapterId, :title, :content, :orderIndex, :locationId, :createdAt, :updatedAt)\\n    `);\\n\\n    stmt.run({\\n      ':id': scene.id,\\n      ':chapterId': scene.chapterId,\\n      ':title': scene.title || null,\\n      ':content': scene.content || null,\\n      ':orderIndex': scene.orderIndex,\\n      ':locationId': scene.locationId || null,\\n      ':createdAt': scene.createdAt,\\n      ':updatedAt': scene.updatedAt\\n    });\\n\\n    stmt.finalize();\\n    return scene;\\n  }\\n\\n  async getScene(id: string): Promise<Scene | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM scenes WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      chapterId: result.chapterId,\\n      title: result.title,\\n      content: result.content,\\n      orderIndex: result.orderIndex,\\n      locationId: result.locationId,\\n      createdAt: result.createdAt,\\n      updatedAt: result.updatedAt\\n    };\\n  }\\n\\n  async updateScene(id: string, updates: Partial<Scene>): Promise<Scene> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getScene(id);\\n    if (!existing) throw new Error('Scene not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.title !== undefined) {\\n      fields.push('title = :title');\\n      values[':title'] = updates.title;\\n    }\\n    if (updates.content !== undefined) {\\n      fields.push('content = :content');\\n      values[':content'] = updates.content;\\n    }\\n    if (updates.locationId !== undefined) {\\n      fields.push('locationId = :locationId');\\n      values[':locationId'] = updates.locationId;\\n    }\\n\\n    fields.push('updatedAt = :updatedAt');\\n    values[':updatedAt'] = new Date().toISOString();\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE scenes SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getScene(id) as Promise<Scene>;\\n  }\\n\\n  async deleteScene(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM scenes WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listScenes(chapterId: string): Promise<Scene[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM scenes WHERE chapterId = :chapterId ORDER BY orderIndex');\\n    const results: Scene[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        chapterId: row.chapterId,\\n        title: row.title,\\n        content: row.content,\\n        orderIndex: row.orderIndex,\\n        locationId: row.locationId,\\n        createdAt: row.createdAt,\\n        updatedAt: row.updatedAt\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Scene operations - delegated to scenes module\\n  async createScene(scene: Scene): Promise<Scene> {\\n    return sceneOps.createScene(this.getDb(), scene);\\n  }\\n\\n  async getScene(id: string): Promise<Scene | null> {\\n    return sceneOps.getScene(this.getDb(), id);\\n  }\\n\\n  async updateScene(id: string, updates: Partial<Scene>): Promise<Scene> {\\n    return sceneOps.updateScene(this.getDb(), id, updates);\\n  }\\n\\n  async deleteScene(id: string): Promise<void> {\\n    return sceneOps.deleteScene(this.getDb(), id);\\n  }\\n\\n  async listScenes(chapterId: string): Promise<Scene[]> {\\n    return sceneOps.listScenes(this.getDb(), chapterId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Element operations\\n  async createElement(element: Element): Promise<Element> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO elements (id, sceneId, type, content, metadata, orderIndex)\\n      VALUES (:id, :sceneId, :type, :content, :metadata, :orderIndex)\\n    `);\\n\\n    stmt.run({\\n      ':id': element.id,\\n      ':sceneId': element.sceneId,\\n      ':type': element.type,\\n      ':content': element.content,\\n      ':metadata': element.metadata ? JSON.stringify(element.metadata) : null,\\n      ':orderIndex': element.orderIndex\\n    });\\n\\n    stmt.finalize();\\n    return element;\\n  }\\n\\n  async getElement(id: string): Promise<Element | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM elements WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      sceneId: result.sceneId,\\n      type: result.type,\\n      content: result.content,\\n      metadata: result.metadata ? JSON.parse(result.metadata) : undefined,\\n      orderIndex: result.orderIndex\\n    };\\n  }\\n\\n  async updateElement(id: string, updates: Partial<Element>): Promise<Element> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getElement(id);\\n    if (!existing) throw new Error('Element not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.content !== undefined) {\\n      fields.push('content = :content');\\n      values[':content'] = updates.content;\\n    }\\n    if (updates.metadata !== undefined) {\\n      fields.push('metadata = :metadata');\\n      values[':metadata'] = updates.metadata ? JSON.stringify(updates.metadata) : null;\\n    }\\n\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE elements SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getElement(id) as Promise<Element>;\\n  }\\n\\n  async deleteElement(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM elements WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listElements(sceneId: string): Promise<Element[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM elements WHERE sceneId = :sceneId ORDER BY orderIndex');\\n    const results: Element[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        sceneId: row.sceneId,\\n        type: row.type,\\n        content: row.content,\\n        metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\\n        orderIndex: row.orderIndex\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Element operations - delegated to elements module\\n  async createElement(element: Element): Promise<Element> {\\n    return elementOps.createElement(this.getDb(), element);\\n  }\\n\\n  async getElement(id: string): Promise<Element | null> {\\n    return elementOps.getElement(this.getDb(), id);\\n  }\\n\\n  async updateElement(id: string, updates: Partial<Element>): Promise<Element> {\\n    return elementOps.updateElement(this.getDb(), id, updates);\\n  }\\n\\n  async deleteElement(id: string): Promise<void> {\\n    return elementOps.deleteElement(this.getDb(), id);\\n  }\\n\\n  async listElements(sceneId: string): Promise<Element[]> {\\n    return elementOps.listElements(this.getDb(), sceneId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Character operations\\n  async createCharacter(character: Character): Promise<Character> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO characters (id, novelId, name, description, attributes)\\n      VALUES (:id, :novelId, :name, :description, :attributes)\\n    `);\\n\\n    stmt.run({\\n      ':id': character.id,\\n      ':novelId': character.novelId,\\n      ':name': character.name,\\n      ':description': character.description || null,\\n      ':attributes': character.attributes ? JSON.stringify(character.attributes) : null\\n    });\\n\\n    stmt.finalize();\\n    return character;\\n  }\\n\\n  async getCharacter(id: string): Promise<Character | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM characters WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      novelId: result.novelId,\\n      name: result.name,\\n      description: result.description,\\n      attributes: result.attributes ? JSON.parse(result.attributes) : undefined\\n    };\\n  }\\n\\n  async updateCharacter(id: string, updates: Partial<Character>): Promise<Character> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getCharacter(id);\\n    if (!existing) throw new Error('Character not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.name !== undefined) {\\n      fields.push('name = :name');\\n      values[':name'] = updates.name;\\n    }\\n    if (updates.description !== undefined) {\\n      fields.push('description = :description');\\n      values[':description'] = updates.description;\\n    }\\n    if (updates.attributes !== undefined) {\\n      fields.push('attributes = :attributes');\\n      values[':attributes'] = updates.attributes ? JSON.stringify(updates.attributes) : null;\\n    }\\n\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE characters SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getCharacter(id) as Promise<Character>;\\n  }\\n\\n  async deleteCharacter(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM characters WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listCharacters(novelId: string): Promise<Character[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM characters WHERE novelId = :novelId');\\n    const results: Character[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        novelId: row.novelId,\\n        name: row.name,\\n        description: row.description,\\n        attributes: row.attributes ? JSON.parse(row.attributes) : undefined\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Character operations - delegated to characters module\\n  async createCharacter(character: Character): Promise<Character> {\\n    return characterOps.createCharacter(this.getDb(), character);\\n  }\\n\\n  async getCharacter(id: string): Promise<Character | null> {\\n    return characterOps.getCharacter(this.getDb(), id);\\n  }\\n\\n  async updateCharacter(id: string, updates: Partial<Character>): Promise<Character> {\\n    return characterOps.updateCharacter(this.getDb(), id, updates);\\n  }\\n\\n  async deleteCharacter(id: string): Promise<void> {\\n    return characterOps.deleteCharacter(this.getDb(), id);\\n  }\\n\\n  async listCharacters(novelId: string): Promise<Character[]> {\\n    return characterOps.listCharacters(this.getDb(), novelId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // Location operations\\n  async createLocation(location: Location): Promise<Location> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO locations (id, novelId, name, description, attributes)\\n      VALUES (:id, :novelId, :name, :description, :attributes)\\n    `);\\n\\n    stmt.run({\\n      ':id': location.id,\\n      ':novelId': location.novelId,\\n      ':name': location.name,\\n      ':description': location.description || null,\\n      ':attributes': location.attributes ? JSON.stringify(location.attributes) : null\\n    });\\n\\n    stmt.finalize();\\n    return location;\\n  }\\n\\n  async getLocation(id: string): Promise<Location | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM locations WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id,\\n      novelId: result.novelId,\\n      name: result.name,\\n      description: result.description,\\n      attributes: result.attributes ? JSON.parse(result.attributes) : undefined\\n    };\\n  }\\n\\n  async updateLocation(id: string, updates: Partial<Location>): Promise<Location> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const existing = await this.getLocation(id);\\n    if (!existing) throw new Error('Location not found');\\n\\n    const fields: string[] = [];\\n    const values: Record<string, any> = {};\\n\\n    if (updates.name !== undefined) {\\n      fields.push('name = :name');\\n      values[':name'] = updates.name;\\n    }\\n    if (updates.description !== undefined) {\\n      fields.push('description = :description');\\n      values[':description'] = updates.description;\\n    }\\n    if (updates.attributes !== undefined) {\\n      fields.push('attributes = :attributes');\\n      values[':attributes'] = updates.attributes ? JSON.stringify(updates.attributes) : null;\\n    }\\n\\n    values[':id'] = id;\\n\\n    const stmt = this.db.prepare(`UPDATE locations SET ${fields.join(', ')} WHERE id = :id`);\\n    stmt.run(values);\\n    stmt.finalize();\\n\\n    return this.getLocation(id) as Promise<Location>;\\n  }\\n\\n  async deleteLocation(id: string): Promise<void> {\\n    if (!this.db) throw new Error('Database not initialized');\\n    const stmt = this.db.prepare('DELETE FROM locations WHERE id = :id');\\n    stmt.run({ ':id': id });\\n    stmt.finalize();\\n  }\\n\\n  async listLocations(novelId: string): Promise<Location[]> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM locations WHERE novelId = :novelId');\\n    const results: Location[] = [];\\n\\n    while (stmt.step()) {\\n      const row = stmt.getAsObject() as any;\\n      results.push({\\n        id: row.id,\\n        novelId: row.novelId,\\n        name: row.name,\\n        description: row.description,\\n        attributes: row.attributes ? JSON.parse(row.attributes) : undefined\\n      });\\n    }\\n\\n    stmt.finalize();\\n    return results;\\n  }\",\"lines\":\"  // Location operations - delegated to locations module\\n  async createLocation(location: Location): Promise<Location> {\\n    return locationOps.createLocation(this.getDb(), location);\\n  }\\n\\n  async getLocation(id: string): Promise<Location | null> {\\n    return locationOps.getLocation(this.getDb(), id);\\n  }\\n\\n  async updateLocation(id: string, updates: Partial<Location>): Promise<Location> {\\n    return locationOps.updateLocation(this.getDb(), id, updates);\\n  }\\n\\n  async deleteLocation(id: string): Promise<void> {\\n    return locationOps.deleteLocation(this.getDb(), id);\\n  }\\n\\n  async listLocations(novelId: string): Promise<Location[]> {\\n    return locationOps.listLocations(this.getDb(), novelId);\\n  }\"},{\"kind\":\"replace\",\"target\":\"  // TimelineEvent operations\\n  async createTimelineEvent(event: TimelineEvent): Promise<TimelineEvent> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare(`\\n      INSERT INTO timeline_events (id\",\"id,\":\"novelId\",\"title,\":\"description\",\"timestamp,\":\"sceneId)\\n    `);\\n\\n    stmt.run({\\n      ':id': event.id\",\":novelId\":\"event.novelId\",\":title\":\"event.title\",\":description\":\"event.description || null\",\":timestamp\":\"event.timestamp\",\":sceneId\":\"event.sceneId || null\"},\"n\\n    stmt.finalize();\\n    return event;\\n  }\\n\\n  async getTimelineEvent(id: string): Promise<TimelineEvent | null> {\\n    if (!this.db) throw new Error('Database not initialized');\\n\\n    const stmt = this.db.prepare('SELECT * FROM timeline_events WHERE id = :id');\\n    const result = stmt.getAsObject({ ':id': id }) as any;\\n    stmt.finalize();\\n\\n    if (!result) return null;\\n\\n    return {\\n      id: result.id\",\"n      novelId: result.novelId\",\"n      title: result.title\",\"n      description: result.description\",\"n      timestamp: result.timestamp\",\"n      sceneId: result.sceneId\\n    };\\n  }\\n\\n  async updateTimelineEvent(id: string\",\"updates\"]}",
  "validationError": "invalid_lines",
  "source": "tool-registry.validateToolCall"
}