{
  "id": "sample_58747f26f3a23199",
  "timestamp": "2026-01-16T02:04:02.844Z",
  "errorType": "missing_changes",
  "originalArgs": "{\"file\":\"sharedmodule/llmswitch-core/src/tools/patch-args-normalizer.ts\",\"instructions\":\"[{\\\"kind\\\": \\\"replace\\\", \\\"target\\\": \\\"// Export individual fixers for advanced usage\\\\nexport const fixApplyPatchHunkHeaders = fixHunkHeadersInPatch;\\\\nexport const fixApplyPatchMissingMarkers = addMissingPatchMarkers;\\\\nexport const fixApplyPatchGitDiffConversion = convertGitDiffToApplyPatch;\\\\nexport const fixApplyPatchFieldAliases = normalizeFieldAliases;\\\", \\\"lines\\\": \\\"// Export individual fixers for advanced usage\\\\nexport const fixApplyPatchHunkHeaders = fixHunkHeadersInPatch;\\\\nexport const fixApplyPatchMissingMarkers = addMissingPatchMarkers;\\\\nexport const fixApplyPatchGitDiffConversion = convertGitDiffToApplyPatch;\\\\nexport const fixApplyPatchFieldAliases = normalizeFieldAliases;\\\\n\\\\n// ========== Unified Fixer Entry Point ==========\\\\n\\\\nexport interface PatchFixerOptions {\\\\n  fixHunkHeaders?: boolean;      // Default: true - add +/-/  prefixes where missing\\\\n  fixMissingMarkers?: boolean;   // Default: true - wrap with Begin/End Patch\\\\n  convertGitDiff?: boolean;      // Default: true - convert git diff to ApplyPatch format\\\\n  normalizeAliases?: boolean;     // Default: true - normalize input/patch fields\\\\n  strictMode?: boolean;          // Default: false - if true, only fix format, not content\\\\n}\\\\n\\\\nconst DEFAULT_OPTIONS: PatchFixerOptions = {\\\\n  fixHunkHeaders: true,\\\\n  fixMissingMarkers: true,\\\\n  convertGitDiff: true,\\\\n  normalizeAliases: true,\\\\n  strictMode: false,\\\\n};\\\\n\\\\n/**\\\\n * Unified apply_patch argument normalizer - fixes all repairable format issues.\\\\n * \\\\n * This consolidates fixes previously scattered across:\\\\n * - apply-patch-fixer.ts (compat layer)\\\\n * - tool-registry.ts (normalizeApplyPatchText)\\\\n * - tool-governor.ts (request/response validation)\\\\n * - apply-patch-structured.ts (structured patch building)\\\\n * \\\\n * @param argsString - The raw arguments string from tool call\\\\n * @param options - Fixer options (default: all fixes enabled)\\\\n * @returns Normalized arguments string, or null if input is invalid\\\\n * \\\\n * Fixable issues (non-exhaustive):\\\\n * - Missing \\\\\\\"*** Begin Patch\\\\\\\" / \\\\\\\"*** End Patch\\\\\\\" markers\\\\n * - Invalid hunk headers (lines without +/-/  prefixes)\\\\n * - Git diff format (diff --git, ---/+++, @@) not converted to ApplyPatch format\\\\n * - Field aliases (input/code/diff instead of patch)\\\\n * - Code fence wrapping (```json ... ```)  \\\\n * - Escaped newlines (\\\\\\\\\\\\\\\\n) in string literals\\\\n * \\\\n * NOT fixed (intentional - require model re-generation):\\\\n * - Context mismatches (anchor/target lines not found in file)\\\\n * - Semantic errors (wrong file paths, conflicting changes)\\\\n */\\\\nexport function normalizeApplyPatchArgs(\\\\n  argsString: string,\\\\n  options?: Partial<PatchFixerOptions>\\\\n): string | null {\\\\n  if (!argsString || typeof argsString !== 'string') {\\\\n    return null;\\\\n  }\\\\n\\\\n  const opts = { ...DEFAULT_OPTIONS, ...options };\\\\n  let args: any;\\\\n\\\\n  // Step 1: Parse JSON args (handle various formats)\\\\n  try {\\\\n    args = JSON.parse(argsString);\\\\n  } catch {\\\\n    // Raw patch string? Wrap it.\\\\n    if (looksLikeRawPatch(argsString)) {\\\\n      args = { patch: argsString };\\\\n    } else {\\\\n      return null;\\\\n    }\\\\n  }\\\\n\\\\n  if (!args || typeof args !== 'object') {\\\\n    return null;\\\\n  }\\\\n\\\\n  let modified = false;\\\\n\\\\n  // Step 2: Normalize field aliases (input/code/diff -> patch)\\\\n  if (opts.normalizeAliases) {\\\\n    const normalized = normalizeFieldAliases(args);\\\\n    if (normalized !== args) {\\\\n      args = normalized;\\\\n      modified = true;\\\\n    }\\\\n  }\\\\n\\\\n  let patch = args.patch;\\\\n\\\\n  // Step 3: Convert structured payload if present\\\\n  if (!patch && isStructuredApplyPatchPayload(args)) {\\\\n    try {\\\\n      patch = buildStructuredPatch(args);\\\\n      delete args.changes;\\\\n      delete args.file;\\\\n      delete args.instructions;\\\\n      args.patch = patch;\\\\n      modified = true;\\\\n    } catch {\\\\n      // If conversion fails, continue with other fixes\\\\n    }\\\\n  }\\\\n\\\\n  // Step 4: Process patch string if present\\\\n  if (typeof patch === 'string') {\\\\n    let processedPatch = patch;\\\\n\\\\n    // Remove code fences\\\\n    processedPatch = stripCodeFences(processedPatch);\\\\n    if (processedPatch !== patch) modified = true;\\\\n\\\\n    // Decode escaped newlines\\\\n    processedPatch = decodeEscapedNewlinesIfNeeded(processedPatch);\\\\n    if (processedPatch !== patch) modified = true;\\\\n\\\\n    // Convert git diff format\\\\n    if (opts.convertGitDiff) {\\\\n      const converted = convertGitDiffToApplyPatchIfNeeded(processedPatch);\\\\n      if (converted && converted !== processedPatch) {\\\\n        processedPatch = converted;\\\\n        modified = true;\\\\n      }\\\\n    }\\\\n\\\\n    // Fix hunk headers (add +/-/  prefixes)\\\\n    if (opts.fixHunkHeaders) {\\\\n      const fixed = fixHunkHeadersInPatch(processedPatch);\\\\n      if (fixed !== processedPatch) {\\\\n        processedPatch = fixed;\\\\n        modified = true;\\\\n      }\\\\n    }\\\\n\\\\n    // Add missing Begin/End markers\\\\n    if (opts.fixMissingMarkers) {\\\\n      const marked = addMissingPatchMarkers(processedPatch);\\\\n      if (marked !== processedPatch) {\\\\n        processedPatch = marked;\\\\n        modified = true;\\\\n      }\\\\n    }\\\\n\\\\n    args.patch = processedPatch;\\\\n  }\\\\n\\\\n  // Step 5: Return normalized JSON\\\\n  if (!modified) {\\\\n    return null; // No changes needed\\\\n  }\\\\n\\\\n  try {\\\\n    return JSON.stringify(args);\\\\n  } catch {\\\\n    return null;\\\\n  }\\\\n}\\\\n\\\\n// Helper functions\\\\n\\\\nfunction looksLikeRawPatch(text: string): boolean {\\\\n  const trimmed = text.trim();\\\\n  return (\\\\n    trimmed.includes('*** Begin Patch') ||\\\\n    trimmed.includes('*** Update File:') ||\\\\n    trimmed.includes('diff --git') ||\\\\n    /^@@\\\\\\\\s/.test(trimmed) ||\\\\n    /^---\\\\\\\\s/.test(trimmed) ||\\\\n    /^\\\\\\\\+\\\\\\\\+\\\\\\\\+\\\\\\\\s/.test(trimmed)\\\\n  );\\\\n}\\\\n\\\\nfunction convertGitDiffToApplyPatchIfNeeded(text: string): string | null {\\\\n  // Check if already in ApplyPatch format\\\\n  if (text.includes('*** Begin Patch') || text.includes('*** Update File:')) {\\\\n    return null;\\\\n  }\\\\n  // Check if looks like git diff\\\\n  if (text.includes('diff --git') || (/^---\\\\\\\\s/m.test(text) && /^\\\\\\\\+\\\\\\\\+\\\\\\\\+\\\\\\\\s/m.test(text))) {\\\\n    return convertGitDiffToApplyPatch(text);\\\\n  }\\\\n  return null;\\\\n}\\\\n\\\"}]\"}",
  "normalizedArgs": "{\"file\":\"sharedmodule/llmswitch-core/src/tools/patch-args-normalizer.ts\",\"instructions\":\"[{\\\"kind\\\": \\\"replace\\\", \\\"target\\\": \\\"// Export individual fixers for advanced usage\\\\nexport const fixApplyPatchHunkHeaders = fixHunkHeadersInPatch;\\\\nexport const fixApplyPatchMissingMarkers = addMissingPatchMarkers;\\\\nexport const fixApplyPatchGitDiffConversion = convertGitDiffToApplyPatch;\\\\nexport const fixApplyPatchFieldAliases = normalizeFieldAliases;\\\", \\\"lines\\\": \\\"// Export individual fixers for advanced usage\\\\nexport const fixApplyPatchHunkHeaders = fixHunkHeadersInPatch;\\\\nexport const fixApplyPatchMissingMarkers = addMissingPatchMarkers;\\\\nexport const fixApplyPatchGitDiffConversion = convertGitDiffToApplyPatch;\\\\nexport const fixApplyPatchFieldAliases = normalizeFieldAliases;\\\\n\\\\n// ========== Unified Fixer Entry Point ==========\\\\n\\\\nexport interface PatchFixerOptions {\\\\n  fixHunkHeaders?: boolean;      // Default: true - add +/-/  prefixes where missing\\\\n  fixMissingMarkers?: boolean;   // Default: true - wrap with Begin/End Patch\\\\n  convertGitDiff?: boolean;      // Default: true - convert git diff to ApplyPatch format\\\\n  normalizeAliases?: boolean;     // Default: true - normalize input/patch fields\\\\n  strictMode?: boolean;          // Default: false - if true, only fix format, not content\\\\n}\\\\n\\\\nconst DEFAULT_OPTIONS: PatchFixerOptions = {\\\\n  fixHunkHeaders: true,\\\\n  fixMissingMarkers: true,\\\\n  convertGitDiff: true,\\\\n  normalizeAliases: true,\\\\n  strictMode: false,\\\\n};\\\\n\\\\n/**\\\\n * Unified apply_patch argument normalizer - fixes all repairable format issues.\\\\n * \\\\n * This consolidates fixes previously scattered across:\\\\n * - apply-patch-fixer.ts (compat layer)\\\\n * - tool-registry.ts (normalizeApplyPatchText)\\\\n * - tool-governor.ts (request/response validation)\\\\n * - apply-patch-structured.ts (structured patch building)\\\\n * \\\\n * @param argsString - The raw arguments string from tool call\\\\n * @param options - Fixer options (default: all fixes enabled)\\\\n * @returns Normalized arguments string, or null if input is invalid\\\\n * \\\\n * Fixable issues (non-exhaustive):\\\\n * - Missing \\\\\\\"*** Begin Patch\\\\\\\" / \\\\\\\"*** End Patch\\\\\\\" markers\\\\n * - Invalid hunk headers (lines without +/-/  prefixes)\\\\n * - Git diff format (diff --git, ---/+++, @@) not converted to ApplyPatch format\\\\n * - Field aliases (input/code/diff instead of patch)\\\\n * - Code fence wrapping (```json ... ```)  \\\\n * - Escaped newlines (\\\\\\\\\\\\\\\\n) in string literals\\\\n * \\\\n * NOT fixed (intentional - require model re-generation):\\\\n * - Context mismatches (anchor/target lines not found in file)\\\\n * - Semantic errors (wrong file paths, conflicting changes)\\\\n */\\\\nexport function normalizeApplyPatchArgs(\\\\n  argsString: string,\\\\n  options?: Partial<PatchFixerOptions>\\\\n): string | null {\\\\n  if (!argsString || typeof argsString !== 'string') {\\\\n    return null;\\\\n  }\\\\n\\\\n  const opts = { ...DEFAULT_OPTIONS, ...options };\\\\n  let args: any;\\\\n\\\\n  // Step 1: Parse JSON args (handle various formats)\\\\n  try {\\\\n    args = JSON.parse(argsString);\\\\n  } catch {\\\\n    // Raw patch string? Wrap it.\\\\n    if (looksLikeRawPatch(argsString)) {\\\\n      args = { patch: argsString };\\\\n    } else {\\\\n      return null;\\\\n    }\\\\n  }\\\\n\\\\n  if (!args || typeof args !== 'object') {\\\\n    return null;\\\\n  }\\\\n\\\\n  let modified = false;\\\\n\\\\n  // Step 2: Normalize field aliases (input/code/diff -> patch)\\\\n  if (opts.normalizeAliases) {\\\\n    const normalized = normalizeFieldAliases(args);\\\\n    if (normalized !== args) {\\\\n      args = normalized;\\\\n      modified = true;\\\\n    }\\\\n  }\\\\n\\\\n  let patch = args.patch;\\\\n\\\\n  // Step 3: Convert structured payload if present\\\\n  if (!patch && isStructuredApplyPatchPayload(args)) {\\\\n    try {\\\\n      patch = buildStructuredPatch(args);\\\\n      delete args.changes;\\\\n      delete args.file;\\\\n      delete args.instructions;\\\\n      args.patch = patch;\\\\n      modified = true;\\\\n    } catch {\\\\n      // If conversion fails, continue with other fixes\\\\n    }\\\\n  }\\\\n\\\\n  // Step 4: Process patch string if present\\\\n  if (typeof patch === 'string') {\\\\n    let processedPatch = patch;\\\\n\\\\n    // Remove code fences\\\\n    processedPatch = stripCodeFences(processedPatch);\\\\n    if (processedPatch !== patch) modified = true;\\\\n\\\\n    // Decode escaped newlines\\\\n    processedPatch = decodeEscapedNewlinesIfNeeded(processedPatch);\\\\n    if (processedPatch !== patch) modified = true;\\\\n\\\\n    // Convert git diff format\\\\n    if (opts.convertGitDiff) {\\\\n      const converted = convertGitDiffToApplyPatchIfNeeded(processedPatch);\\\\n      if (converted && converted !== processedPatch) {\\\\n        processedPatch = converted;\\\\n        modified = true;\\\\n      }\\\\n    }\\\\n\\\\n    // Fix hunk headers (add +/-/  prefixes)\\\\n    if (opts.fixHunkHeaders) {\\\\n      const fixed = fixHunkHeadersInPatch(processedPatch);\\\\n      if (fixed !== processedPatch) {\\\\n        processedPatch = fixed;\\\\n        modified = true;\\\\n      }\\\\n    }\\\\n\\\\n    // Add missing Begin/End markers\\\\n    if (opts.fixMissingMarkers) {\\\\n      const marked = addMissingPatchMarkers(processedPatch);\\\\n      if (marked !== processedPatch) {\\\\n        processedPatch = marked;\\\\n        modified = true;\\\\n      }\\\\n    }\\\\n\\\\n    args.patch = processedPatch;\\\\n  }\\\\n\\\\n  // Step 5: Return normalized JSON\\\\n  if (!modified) {\\\\n    return null; // No changes needed\\\\n  }\\\\n\\\\n  try {\\\\n    return JSON.stringify(args);\\\\n  } catch {\\\\n    return null;\\\\n  }\\\\n}\\\\n\\\\n// Helper functions\\\\n\\\\nfunction looksLikeRawPatch(text: string): boolean {\\\\n  const trimmed = text.trim();\\\\n  return (\\\\n    trimmed.includes('*** Begin Patch') ||\\\\n    trimmed.includes('*** Update File:') ||\\\\n    trimmed.includes('diff --git') ||\\\\n    /^@@\\\\\\\\s/.test(trimmed) ||\\\\n    /^---\\\\\\\\s/.test(trimmed) ||\\\\n    /^\\\\\\\\+\\\\\\\\+\\\\\\\\+\\\\\\\\s/.test(trimmed)\\\\n  );\\\\n}\\\\n\\\\nfunction convertGitDiffToApplyPatchIfNeeded(text: string): string | null {\\\\n  // Check if already in ApplyPatch format\\\\n  if (text.includes('*** Begin Patch') || text.includes('*** Update File:')) {\\\\n    return null;\\\\n  }\\\\n  // Check if looks like git diff\\\\n  if (text.includes('diff --git') || (/^---\\\\\\\\s/m.test(text) && /^\\\\\\\\+\\\\\\\\+\\\\\\\\+\\\\\\\\s/m.test(text))) {\\\\n    return convertGitDiffToApplyPatch(text);\\\\n  }\\\\n  return null;\\\\n}\\\\n\\\"}]\"}",
  "validationError": "missing_changes",
  "source": "tool-registry.validateToolCall"
}